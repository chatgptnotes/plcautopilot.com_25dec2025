{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":"I need to investigate why the same QEEG report uploaded multiple times is giving different calculation scores each time. This is a critical issue - same input should always give same output.\n\nPlease investigate the entire flow and identify where non-deterministic behavior is occurring:\n\n1. **Data Extraction Phase** (qeegParser.js):\n   - Check if Gemini AI extraction is consistent for same PDF\n   - Look for any randomness in the extraction prompt or process\n   - Check if there are any default/fallback values being used inconsistently\n\n2. **Algorithm Calculation Phase** (algorithmCalculator.js):\n   - Verify all calculations are deterministic (no random elements)\n   - Check if there are any conditional logic that might produce different results\n   - Look for any floating-point precision issues\n   - Check getValue() method for any inconsistencies\n\n3. **Data Flow** (qeegRoutes.js):\n   - Check the complete flow from upload to final score\n   - Look for any async race conditions\n   - Check if data is being modified during processing\n\n4. **Specific areas to check**:\n   - Gemini API responses - are they deterministic for same input?\n   - Any use of Math.random() or Date.now() in calculations\n   - Any default values that might vary\n   - Any == vs === comparisons that might behave differently\n   - Threshold comparisons that might have rounding issues\n\n**IMPORTANT**: The user mentioned they upload the SAME report multiple times but get DIFFERENT scores each time. This should NEVER happen - the calculations must be deterministic.\n\nFocus on finding:\n- Where is the non-deterministic behavior coming from?\n- Is it in Gemini extraction or in calculations?\n- What specific code is causing the variation?\n\nReturn a detailed analysis of:\n1. All sources of non-deterministic behavior found\n2. The specific files and line numbers where issues exist\n3. Whether it's Gemini extraction inconsistency or calculation logic issue\n4. Recommendations for fixing each issue"},"uuid":"29ad0fac-6406-4601-93fc-b171bcd134b1","timestamp":"2025-12-03T07:33:43.010Z"}
{"parentUuid":"29ad0fac-6406-4601-93fc-b171bcd134b1","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YQRW9ELCc7iZKCpBcZbaFC","type":"message","role":"assistant","content":[{"type":"text","text":"I'll investigate the entire QEEG processing flow to identify sources of non-deterministic behavior. Let me start by examining the key files."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9352,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9352,"ephemeral_1h_input_tokens":0},"output_tokens":272,"service_tier":"standard"}},"requestId":"req_011CVjNCGdgKi24Cvs3rRLcx","type":"assistant","uuid":"fca4a15e-1534-48a3-acd8-0c0f12c64e11","timestamp":"2025-12-03T07:33:48.023Z"}
{"parentUuid":"fca4a15e-1534-48a3-acd8-0c0f12c64e11","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YQRW9ELCc7iZKCpBcZbaFC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LzV3c3pyyKKCnXUioKUbvf","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\services\\qeegParser.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9352,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9352,"ephemeral_1h_input_tokens":0},"output_tokens":272,"service_tier":"standard"}},"requestId":"req_011CVjNCGdgKi24Cvs3rRLcx","type":"assistant","uuid":"612f0a43-f2e2-4c0c-8f83-789d183d5618","timestamp":"2025-12-03T07:33:49.147Z"}
{"parentUuid":"612f0a43-f2e2-4c0c-8f83-789d183d5618","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YQRW9ELCc7iZKCpBcZbaFC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PGXfhpSbWoSoGU7ovBenQX","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\services\\algorithmCalculator.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9352,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9352,"ephemeral_1h_input_tokens":0},"output_tokens":272,"service_tier":"standard"}},"requestId":"req_011CVjNCGdgKi24Cvs3rRLcx","type":"assistant","uuid":"382c5c5e-8058-46f7-b4dc-b1990b1cb74c","timestamp":"2025-12-03T07:33:49.269Z"}
{"parentUuid":"382c5c5e-8058-46f7-b4dc-b1990b1cb74c","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YQRW9ELCc7iZKCpBcZbaFC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NMtWEmoe2XfiU7S86hBn6c","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9352,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9352,"ephemeral_1h_input_tokens":0},"output_tokens":272,"service_tier":"standard"}},"requestId":"req_011CVjNCGdgKi24Cvs3rRLcx","type":"assistant","uuid":"e7ca6d03-e8e6-475f-a8ec-feecf058a1b3","timestamp":"2025-12-03T07:33:49.541Z"}
{"parentUuid":"e7ca6d03-e8e6-475f-a8ec-feecf058a1b3","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YQRW9ELCc7iZKCpBcZbaFC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013E3L8mDueaJBFpH8SFqX9q","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\services\\geminiService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":9352,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9352,"ephemeral_1h_input_tokens":0},"output_tokens":272,"service_tier":"standard"}},"requestId":"req_011CVjNCGdgKi24Cvs3rRLcx","type":"assistant","uuid":"9b0abd09-9412-4e88-9c32-941bc473e740","timestamp":"2025-12-03T07:33:49.913Z"}
{"parentUuid":"9b0abd09-9412-4e88-9c32-941bc473e740","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PGXfhpSbWoSoGU7ovBenQX","type":"tool_result","content":"     1â†’/**\n     2â†’ * QEEG Algorithm Calculator\n     3â†’ * Based on Rhea's Report - Calculates 7 brain health parameters\n     4â†’ * Each parameter has 3 sub-metrics, scored 0-3, classified as Low/Medium/High\n     5â†’ */\n     6â†’\n     7â†’class AlgorithmCalculator {\n     8â†’  constructor(qeegData) {\n     9â†’    this.data = qeegData;\n    10â†’    this.results = {\n    11â†’      parameters: [],\n    12â†’      rawCalculations: {},\n    13â†’      overallScore: 0\n    14â†’    };\n    15â†’  }\n    16â†’\n    17â†’  /**\n    18â†’   * Main calculation method - calculates all 7 parameters\n    19â†’   */\n    20â†’  calculate() {\n    21â†’    console.log('\\nğŸ§® ========== STARTING ALGORITHM CALCULATIONS ==========');\n    22â†’    console.log('ğŸ“Š Input Data Structure:', JSON.stringify(this.data, null, 2));\n    23â†’\n    24â†’    const parameters = [\n    25â†’      this.calculateCognition(),\n    26â†’      this.calculateStress(),\n    27â†’      this.calculateFocusAttention(),\n    28â†’      this.calculateBurnoutFatigue(),\n    29â†’      this.calculateEmotionalRegulation(),\n    30â†’      this.calculateLearning(),\n    31â†’      this.calculateCreativity()\n    32â†’    ];\n    33â†’\n    34â†’    console.log('\\nâœ… Final 7 Parameter Scores Calculated:');\n    35â†’    parameters.forEach((p, i) => {\n    36â†’      console.log(`${i + 1}. ${p.name}: ${p.score}/${p.maxScore} (${p.classification}) ${this.getEmoji(p.classification)}`);\n    37â†’      p.metrics.forEach(m => {\n    38â†’        console.log(`   - ${m.name}: ${m.score} point (value: ${JSON.stringify(m.value)})`);\n    39â†’      });\n    40â†’    });\n    41â†’    console.log('========== CALCULATIONS COMPLETE ==========\\n');\n    42â†’\n    43â†’    this.results.parameters = parameters;\n    44â†’    this.results.overallScore = parameters.reduce((sum, p) => sum + p.score, 0);\n    45â†’\n    46â†’    return this.results;\n    47â†’  }\n    48â†’\n    49â†’  getEmoji(classification) {\n    50â†’    if (classification === 'Low') return 'ğŸ”´';\n    51â†’    if (classification === 'Medium') return 'ğŸŸ¡';\n    52â†’    return 'ğŸŸ¢';\n    53â†’  }\n    54â†’\n    55â†’  // ==================== HELPER METHODS ====================\n    56â†’\n    57â†’  /**\n    58â†’   * Get value from QEEG data table\n    59â†’   * @param {string} condition - 'EC' (Eyes Closed) or 'EO' (Eyes Open)\n    60â†’   * @param {string} powerType - 'absolute' or 'relative'\n    61â†’   * @param {string} channel - e.g., 'Fz', 'Cz', 'Pz'\n    62â†’   * @param {string} band - e.g., 'Theta', 'Alpha', 'Beta', 'HiBeta', 'Delta'\n    63â†’   */\n    64â†’  getValue(condition, powerType, channel, band) {\n    65â†’    try {\n    66â†’      return this.data[condition][powerType][channel][band];\n    67â†’    } catch (error) {\n    68â†’      console.error(`Error getting value: ${condition}.${powerType}.${channel}.${band}`);\n    69â†’      return null;\n    70â†’    }\n    71â†’  }\n    72â†’\n    73â†’  /**\n    74â†’   * Score a metric based on threshold\n    75â†’   * Returns 1 if condition is met (HEALTHY/NORMAL state by default)\n    76â†’   * Use 'invert: true' for stress/problem indicators\n    77â†’   */\n    78â†’  scoreMetric(value, threshold, comparison = 'less', invert = false) {\n    79â†’    if (value === null || value === undefined) return 0;\n    80â†’\n    81â†’    let result = 0;\n    82â†’\n    83â†’    if (comparison === 'less') {\n    84â†’      result = value < threshold ? 1 : 0;\n    85â†’    } else if (comparison === 'more') {\n    86â†’      result = value > threshold ? 1 : 0;\n    87â†’    } else if (comparison === 'equal') {\n    88â†’      result = value === threshold ? 1 : 0;\n    89â†’    }\n    90â†’\n    91â†’    // Invert for stress/problem indicators (where 1 point = problem detected)\n    92â†’    return invert ? (1 - result) : result;\n    93â†’  }\n    94â†’\n    95â†’  /**\n    96â†’   * Classify score to bucket (Low/Medium/High)\n    97â†’   */\n    98â†’  classifyScore(score) {\n    99â†’    if (score <= 1) return 'Low';\n   100â†’    if (score === 2) return 'Medium';\n   101â†’    return 'High';\n   102â†’  }\n   103â†’\n   104â†’  // ==================== INDIVIDUAL METRICS ====================\n   105â†’\n   106â†’  /**\n   107â†’   * Focus Score (Theta:Beta Ratio) - Used in multiple parameters\n   108â†’   * Eyes Open, Absolute Power, Fz & Cz average\n   109â†’   * < 1.5 is normal\n   110â†’   */\n   111â†’  calculateFocusScore() {\n   112â†’    console.log('\\n  ğŸ” === Calculating Focus Score (Theta:Beta) ===');\n   113â†’    const fzTheta = this.getValue('EO', 'absolute', 'Fz', 'Theta');\n   114â†’    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');\n   115â†’    const czTheta = this.getValue('EO', 'absolute', 'Cz', 'Theta');\n   116â†’    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');\n   117â†’\n   118â†’    console.log('     Raw Values:', { fzTheta, fzBeta, czTheta, czBeta });\n   119â†’\n   120â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   121â†’    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null) {\n   122â†’      console.log('     âŒ Missing values, returning 0');\n   123â†’      return { value: null, score: 0 };\n   124â†’    }\n   125â†’\n   126â†’    const fzRatio = fzTheta / fzBeta;\n   127â†’    const czRatio = czTheta / czBeta;\n   128â†’    const avgRatio = (fzRatio + czRatio) / 2;\n   129â†’    const score = this.scoreMetric(avgRatio, 1.5, 'less');\n   130â†’\n   131â†’    console.log(`     Fz ratio: ${fzRatio.toFixed(3)}, Cz ratio: ${czRatio.toFixed(3)}`);\n   132â†’    console.log(`     Average: ${avgRatio.toFixed(3)}`);\n   133â†’    console.log(`     Threshold: < 1.5 = normal`);\n   134â†’    console.log(`     Result: ${avgRatio.toFixed(3)} < 1.5 = ${avgRatio < 1.5}`);\n   135â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   136â†’\n   137â†’    return {\n   138â†’      value: avgRatio,\n   139â†’      score: score,\n   140â†’      description: `Theta:Beta Ratio = ${avgRatio.toFixed(2)} (< 1.5 is normal)`,\n   141â†’      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }\n   142â†’    };\n   143â†’  }\n   144â†’\n   145â†’  /**\n   146â†’   * Alpha Peak - Used in multiple parameters\n   147â†’   * Eyes Closed, Special (highest frequency at Pz or below)\n   148â†’   * > 9 Hz is normal\n   149â†’   */\n   150â†’  calculateAlphaPeak() {\n   151â†’    console.log('\\n  ğŸ” === Calculating Alpha Peak ===');\n   152â†’    // Get alpha peak from data - NO DEFAULT VALUE\n   153â†’    const alphaPeak = this.data.EC?.special?.alphaPeak || this.data.EC?.special?.O1 || null;\n   154â†’\n   155â†’    console.log('     Raw Value:', alphaPeak);\n   156â†’\n   157â†’    // If no data available, return 0 score\n   158â†’    if (alphaPeak === null || alphaPeak === undefined) {\n   159â†’      console.log('     âŒ No data available, returning 0');\n   160â†’      return { value: null, score: 0 };\n   161â†’    }\n   162â†’\n   163â†’    const score = this.scoreMetric(alphaPeak, 9, 'more');\n   164â†’    console.log(`     Threshold: > 9 Hz = normal`);\n   165â†’    console.log(`     Result: ${alphaPeak} > 9 = ${alphaPeak > 9}`);\n   166â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   167â†’\n   168â†’    return {\n   169â†’      value: alphaPeak,\n   170â†’      score: score,\n   171â†’      description: `Alpha Peak = ${alphaPeak.toFixed(1)} Hz (> 9 is normal)`\n   172â†’    };\n   173â†’  }\n   174â†’\n   175â†’  /**\n   176â†’   * Alpha:Theta Balance - Used in multiple parameters\n   177â†’   * Eyes Closed, Absolute Power, Fz, Cz, Pz\n   178â†’   * Order Pz > Cz > Fz is normal for eyes-closed (posterior dominance)\n   179â†’   * NOTE: Per Rhea's report, posterior dominance (Pz > Cz > Fz) is \"actually common\n   180â†’   * in eyes-closed recordings where alpha typically peaks over parietal/occipital sites\"\n   181â†’   */\n   182â†’  calculateAlphaThetaBalance() {\n   183â†’    console.log('\\n  ğŸ” === Calculating Alpha:Theta Balance ===');\n   184â†’    const fzAlpha = this.getValue('EC', 'absolute', 'Fz', 'Alpha');\n   185â†’    const fzTheta = this.getValue('EC', 'absolute', 'Fz', 'Theta');\n   186â†’    const czAlpha = this.getValue('EC', 'absolute', 'Cz', 'Alpha');\n   187â†’    const czTheta = this.getValue('EC', 'absolute', 'Cz', 'Theta');\n   188â†’    const pzAlpha = this.getValue('EC', 'absolute', 'Pz', 'Alpha');\n   189â†’    const pzTheta = this.getValue('EC', 'absolute', 'Pz', 'Theta');\n   190â†’\n   191â†’    console.log('     Raw Values - Fz:', { Alpha: fzAlpha, Theta: fzTheta });\n   192â†’    console.log('     Raw Values - Cz:', { Alpha: czAlpha, Theta: czTheta });\n   193â†’    console.log('     Raw Values - Pz:', { Alpha: pzAlpha, Theta: pzTheta });\n   194â†’\n   195â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   196â†’    if (fzAlpha == null || fzTheta == null || czAlpha == null || czTheta == null || pzAlpha == null || pzTheta == null) {\n   197â†’      console.log('     âŒ Missing values, returning 0');\n   198â†’      return { value: null, score: 0 };\n   199â†’    }\n   200â†’\n   201â†’    const fzRatio = fzAlpha / fzTheta;\n   202â†’    const czRatio = czAlpha / czTheta;\n   203â†’    const pzRatio = pzAlpha / pzTheta;\n   204â†’\n   205â†’    console.log(`     Ratios - Fz: ${fzRatio.toFixed(2)}, Cz: ${czRatio.toFixed(2)}, Pz: ${pzRatio.toFixed(2)}`);\n   206â†’    console.log(`     Expected Order: Pz > Cz > Fz (posterior dominant for EC)`);\n   207â†’    console.log(`     Actual Order: Pz(${pzRatio.toFixed(2)}) > Cz(${czRatio.toFixed(2)}) > Fz(${fzRatio.toFixed(2)})`);\n   208â†’\n   209â†’    // Normal pattern for eyes-closed: Pz > Cz > Fz (posterior dominant)\n   210â†’    const isNormalOrder = pzRatio > czRatio && czRatio > fzRatio;\n   211â†’\n   212â†’    console.log(`     Check: ${pzRatio.toFixed(2)} > ${czRatio.toFixed(2)} = ${pzRatio > czRatio}`);\n   213â†’    console.log(`     Check: ${czRatio.toFixed(2)} > ${fzRatio.toFixed(2)} = ${czRatio > fzRatio}`);\n   214â†’    console.log(`     âœ… SCORE: ${isNormalOrder ? 1 : 0}/1`);\n   215â†’\n   216â†’    return {\n   217â†’      value: { fz: fzRatio.toFixed(2), cz: czRatio.toFixed(2), pz: pzRatio.toFixed(2) },\n   218â†’      score: isNormalOrder ? 1 : 0,\n   219â†’      description: `Alpha:Theta Order = ${isNormalOrder ? 'Pz > Cz > Fz (Normal for EC)' : 'Abnormal order'}`,\n   220â†’      details: { fzRatio, czRatio, pzRatio, order: isNormalOrder }\n   221â†’    };\n   222â†’  }\n   223â†’\n   224â†’  /**\n   225â†’   * Arousal Score (HiBeta:Beta Ratio) - Used in multiple parameters\n   226â†’   * Eyes Open, Absolute Power, Fz & Cz average\n   227â†’   * < 1 is normal\n   228â†’   */\n   229â†’  calculateArousalScore() {\n   230â†’    console.log('\\n  ğŸ” === Calculating Arousal Score (HiBeta:Beta) ===');\n   231â†’    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');\n   232â†’    const fzHiBeta = this.getValue('EO', 'absolute', 'Fz', 'HiBeta');\n   233â†’    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');\n   234â†’    const czHiBeta = this.getValue('EO', 'absolute', 'Cz', 'HiBeta');\n   235â†’\n   236â†’    console.log('     Raw Values - Fz:', { Beta: fzBeta, HiBeta: fzHiBeta });\n   237â†’    console.log('     Raw Values - Cz:', { Beta: czBeta, HiBeta: czHiBeta });\n   238â†’\n   239â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   240â†’    if (fzBeta == null || fzHiBeta == null || czBeta == null || czHiBeta == null) {\n   241â†’      console.log('     âŒ Missing values, returning 0');\n   242â†’      return { value: null, score: 0 };\n   243â†’    }\n   244â†’\n   245â†’    const fzRatio = fzHiBeta / fzBeta;\n   246â†’    const czRatio = czHiBeta / czBeta;\n   247â†’    const avgRatio = (fzRatio + czRatio) / 2;\n   248â†’    const score = this.scoreMetric(avgRatio, 1, 'less');\n   249â†’\n   250â†’    console.log(`     Fz ratio (HiBeta/Beta): ${fzRatio.toFixed(3)}`);\n   251â†’    console.log(`     Cz ratio (HiBeta/Beta): ${czRatio.toFixed(3)}`);\n   252â†’    console.log(`     Average: ${avgRatio.toFixed(3)}`);\n   253â†’    console.log(`     Threshold: < 1 = normal (low arousal)`);\n   254â†’    console.log(`     Result: ${avgRatio.toFixed(3)} < 1 = ${avgRatio < 1}`);\n   255â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   256â†’\n   257â†’    return {\n   258â†’      value: avgRatio,\n   259â†’      score: score,\n   260â†’      description: `Arousal Score = ${avgRatio.toFixed(2)} (< 1 is normal)`,\n   261â†’      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }\n   262â†’    };\n   263â†’  }\n   264â†’\n   265â†’  /**\n   266â†’   * Relaxation Score - Used in multiple parameters\n   267â†’   * Eyes Closed, RELATIVE Power, Pz, Alpha/Beta\n   268â†’   * >= 10 is healthy\n   269â†’   */\n   270â†’  calculateRelaxationScore() {\n   271â†’    console.log('\\n  ğŸ” === Calculating Relaxation Score ===');\n   272â†’    console.log('     Using: EC RELATIVE power, Pz channel');\n   273â†’    const pzAlpha = this.getValue('EC', 'relative', 'Pz', 'Alpha');\n   274â†’    const pzBeta = this.getValue('EC', 'relative', 'Pz', 'Beta');\n   275â†’\n   276â†’    console.log('     Raw Values - Pz:', { Alpha: pzAlpha, Beta: pzBeta });\n   277â†’\n   278â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   279â†’    if (pzAlpha == null || pzBeta == null || pzBeta === 0) {\n   280â†’      console.log('     âš ï¸ Missing or zero Beta value, returning 0');\n   281â†’      return { value: null, score: 0 };\n   282â†’    }\n   283â†’\n   284â†’    const ratio = pzAlpha / pzBeta;\n   285â†’\n   286â†’    console.log(`     Ratio: ${pzAlpha} / ${pzBeta} = ${ratio.toFixed(2)}`);\n   287â†’    console.log(`     Threshold: >= 9.9 (accounting for rounding, ~10.0 is healthy)`);\n   288â†’    console.log(`     Result: ${ratio.toFixed(2)} >= 9.9 = ${ratio >= 9.9}`);\n   289â†’\n   290â†’    // Use >= 9.9 to account for rounding (9.96 â‰ˆ 10.0 is considered healthy)\n   291â†’    const score = ratio >= 9.9 ? 1 : 0;\n   292â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   293â†’\n   294â†’    return {\n   295â†’      value: ratio,\n   296â†’      score: score,\n   297â†’      description: `Relaxation Score = ${ratio.toFixed(2)} (>= 10 is healthy)`\n   298â†’    };\n   299â†’  }\n   300â†’\n   301â†’  /**\n   302â†’   * Regeneration (Alpha Modulation) - Used in multiple parameters\n   303â†’   * EO & EC, Relative Power, Pz, (EC-EO)/EC * 100\n   304â†’   * > 30% is healthy\n   305â†’   */\n   306â†’  calculateRegeneration() {\n   307â†’    console.log('\\n  ğŸ” === Calculating Regeneration (Alpha Modulation) ===');\n   308â†’    console.log('     Using: EC vs EO relative power at Pz');\n   309â†’    const ecAlpha = this.getValue('EC', 'relative', 'Pz', 'Alpha');\n   310â†’    const eoAlpha = this.getValue('EO', 'relative', 'Pz', 'Alpha');\n   311â†’\n   312â†’    console.log('     Raw Values:', { 'EC Alpha': ecAlpha, 'EO Alpha': eoAlpha });\n   313â†’\n   314â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   315â†’    if (ecAlpha == null || eoAlpha == null || ecAlpha === 0) {\n   316â†’      console.log('     âŒ Missing or zero EC Alpha value, returning 0');\n   317â†’      return { value: null, score: 0 };\n   318â†’    }\n   319â†’\n   320â†’    const modulation = ((ecAlpha - eoAlpha) / ecAlpha) * 100;\n   321â†’    const score = this.scoreMetric(modulation, 30, 'more');\n   322â†’\n   323â†’    console.log(`     Formula: ((EC - EO) / EC) Ã— 100`);\n   324â†’    console.log(`     Calculation: ((${ecAlpha} - ${eoAlpha}) / ${ecAlpha}) Ã— 100`);\n   325â†’    console.log(`     Modulation: ${modulation.toFixed(1)}%`);\n   326â†’    console.log(`     Threshold: > 30% = healthy (good alpha reactivity)`);\n   327â†’    console.log(`     Result: ${modulation.toFixed(1)}% > 30% = ${modulation > 30}`);\n   328â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   329â†’\n   330â†’    return {\n   331â†’      value: modulation,\n   332â†’      score: score,\n   333â†’      description: `Alpha Modulation = ${modulation.toFixed(1)}% (> 30% is healthy)`\n   334â†’    };\n   335â†’  }\n   336â†’\n   337â†’  /**\n   338â†’   * Focus Theta (Relative Power) - Used in Focus & Attention\n   339â†’   * Eyes Open, Relative Power, Fz & Cz average\n   340â†’   * < 20% is normal\n   341â†’   */\n   342â†’  calculateFocusTheta() {\n   343â†’    console.log('\\n  ğŸ” === Calculating Focus Theta ===');\n   344â†’    console.log('     Using: EO relative power at Fz and Cz');\n   345â†’    const fzTheta = this.getValue('EO', 'relative', 'Fz', 'Theta');\n   346â†’    const czTheta = this.getValue('EO', 'relative', 'Cz', 'Theta');\n   347â†’\n   348â†’    console.log('     Raw Values:', { 'Fz Theta': fzTheta, 'Cz Theta': czTheta });\n   349â†’\n   350â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   351â†’    if (fzTheta == null || czTheta == null) {\n   352â†’      console.log('     âŒ Missing values, returning 0');\n   353â†’      return { value: null, score: 0 };\n   354â†’    }\n   355â†’\n   356â†’    const avgTheta = (fzTheta + czTheta) / 2;\n   357â†’    const score = this.scoreMetric(avgTheta, 20, 'less');\n   358â†’\n   359â†’    console.log(`     Average: (${fzTheta} + ${czTheta}) / 2 = ${avgTheta.toFixed(1)}%`);\n   360â†’    console.log(`     Threshold: < 20% = normal (low frontal theta)`);\n   361â†’    console.log(`     Result: ${avgTheta.toFixed(1)}% < 20% = ${avgTheta < 20}`);\n   362â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   363â†’\n   364â†’    return {\n   365â†’      value: avgTheta,\n   366â†’      score: score,\n   367â†’      description: `Focus Theta = ${avgTheta.toFixed(1)}% (< 20% is normal)`\n   368â†’    };\n   369â†’  }\n   370â†’\n   371â†’  /**\n   372â†’   * Excessive Delta - Used in Burnout & Fatigue\n   373â†’   * Eyes Open, Relative Power, avg of Fz, C3, Cz, C4, P3, Pz, P4\n   374â†’   * < 70% is normal\n   375â†’   */\n   376â†’  calculateExcessiveDelta() {\n   377â†’    console.log('\\n  ğŸ” === Calculating Excessive Delta ===');\n   378â†’    console.log('     Using: EO relative power, averaging 7 channels');\n   379â†’    const channels = ['Fz', 'C3', 'Cz', 'C4', 'P3', 'Pz', 'P4'];\n   380â†’    let sum = 0;\n   381â†’    let count = 0;\n   382â†’    const channelValues = {};\n   383â†’\n   384â†’    for (const channel of channels) {\n   385â†’      const delta = this.getValue('EO', 'relative', channel, 'Delta');\n   386â†’      channelValues[channel] = delta !== null ? delta : 'N/A';\n   387â†’      if (delta !== null) {\n   388â†’        sum += delta;\n   389â†’        count++;\n   390â†’      }\n   391â†’    }\n   392â†’\n   393â†’    console.log('     Channel Values:', channelValues);\n   394â†’    console.log(`     Valid channels: ${count}/7`);\n   395â†’\n   396â†’    if (count === 0) {\n   397â†’      console.log('     âŒ No valid channel data, returning 0');\n   398â†’      return { value: null, score: 0 };\n   399â†’    }\n   400â†’\n   401â†’    const avgDelta = sum / count;\n   402â†’    const score = this.scoreMetric(avgDelta, 70, 'less');\n   403â†’\n   404â†’    console.log(`     Sum: ${sum.toFixed(2)}, Count: ${count}`);\n   405â†’    console.log(`     Average Delta: ${avgDelta.toFixed(1)}%`);\n   406â†’    console.log(`     Threshold: < 70% = normal (low delta during wakefulness)`);\n   407â†’    console.log(`     Result: ${avgDelta.toFixed(1)}% < 70% = ${avgDelta < 70}`);\n   408â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   409â†’\n   410â†’    return {\n   411â†’      value: avgDelta,\n   412â†’      score: score,\n   413â†’      description: `Excessive Delta = ${avgDelta.toFixed(1)}% (< 70% is normal)`\n   414â†’    };\n   415â†’  }\n   416â†’\n   417â†’  /**\n   418â†’   * Alpha Asymmetry (Frontal) - Used in Emotional Regulation\n   419â†’   * Eyes Closed, Absolute Power, F3 & F4\n   420â†’   * F4/F3 < 1 is normal\n   421â†’   */\n   422â†’  calculateAlphaAsymmetry() {\n   423â†’    console.log('\\n  ğŸ” === Calculating Alpha Asymmetry (Frontal) ===');\n   424â†’    console.log('     Using: EC absolute power at F3 and F4');\n   425â†’    const f3Alpha = this.getValue('EC', 'absolute', 'F3', 'Alpha');\n   426â†’    const f4Alpha = this.getValue('EC', 'absolute', 'F4', 'Alpha');\n   427â†’\n   428â†’    console.log('     Raw Values:', { 'F3 Alpha': f3Alpha, 'F4 Alpha': f4Alpha });\n   429â†’\n   430â†’    // Fix: Use == null to allow 0 values (valid EEG readings)\n   431â†’    if (f3Alpha == null || f4Alpha == null || f3Alpha === 0) {\n   432â†’      console.log('     âŒ Missing or zero F3 value, returning 0');\n   433â†’      return { value: null, score: 0 };\n   434â†’    }\n   435â†’\n   436â†’    const ratio = f4Alpha / f3Alpha;\n   437â†’    const score = this.scoreMetric(ratio, 1, 'less');\n   438â†’\n   439â†’    console.log(`     Ratio: F4/F3 = ${f4Alpha} / ${f3Alpha} = ${ratio.toFixed(3)}`);\n   440â†’    console.log(`     Threshold: < 1 = normal (left frontal dominance, positive affect)`);\n   441â†’    console.log(`     Result: ${ratio.toFixed(3)} < 1 = ${ratio < 1}`);\n   442â†’    console.log(`     âœ… SCORE: ${score}/1`);\n   443â†’\n   444â†’    return {\n   445â†’      value: ratio,\n   446â†’      score: score,\n   447â†’      description: `Alpha Asymmetry = ${ratio.toFixed(2)} (< 1 is normal)`\n   448â†’    };\n   449â†’  }\n   450â†’\n   451â†’  // ==================== 7 PARAMETER CALCULATIONS ====================\n   452â†’\n   453â†’  /**\n   454â†’   * 1. Cognition\n   455â†’   * - Focus Score (Theta:Beta Ratio)\n   456â†’   * - Alpha Peak\n   457â†’   * - Alpha:Theta Balance\n   458â†’   */\n   459â†’  calculateCognition() {\n   460â†’    console.log('\\nğŸ“Š Calculating COGNITION...');\n   461â†’    const metric1 = this.calculateFocusScore();\n   462â†’    const metric2 = this.calculateAlphaPeak();\n   463â†’    const metric3 = this.calculateAlphaThetaBalance();\n   464â†’\n   465â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   466â†’    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n   467â†’\n   468â†’    return {\n   469â†’      name: 'Cognition',\n   470â†’      score: totalScore,\n   471â†’      maxScore: 3,\n   472â†’      classification: this.classifyScore(totalScore),\n   473â†’      metrics: [\n   474â†’        { name: 'Focus Score (Theta:Beta)', ...metric1 },\n   475â†’        { name: 'Alpha Peak', ...metric2 },\n   476â†’        { name: 'Alpha:Theta Balance', ...metric3 }\n   477â†’      ]\n   478â†’    };\n   479â†’  }\n   480â†’\n   481â†’  /**\n   482â†’   * 2. Stress (Note: 0/3 is healthy, 3/3 is high stress)\n   483â†’   * - Arousal Score (inverted: abnormal = 1 point)\n   484â†’   * - Relaxation Score (inverted: abnormal = 1 point)\n   485â†’   * - Regeneration (inverted: abnormal = 1 point)\n   486â†’   */\n   487â†’  calculateStress() {\n   488â†’    console.log('\\nğŸ“Š === STRESS PARAMETER (0/3 = Healthy, 3/3 = High Stress) ===');\n   489â†’    const metric1 = this.calculateArousalScore();\n   490â†’    const metric2 = this.calculateRelaxationScore();\n   491â†’    const metric3 = this.calculateRegeneration();\n   492â†’\n   493â†’    // Invert scores: 0->1, 1->0 (so abnormal values add to stress score)\n   494â†’    const invertedScore1 = 1 - metric1.score;\n   495â†’    const invertedScore2 = 1 - metric2.score;\n   496â†’    const invertedScore3 = 1 - metric3.score;\n   497â†’\n   498â†’    console.log(`\\n  ğŸ”„ INVERTING SCORES (abnormal values = stress):`);\n   499â†’    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (stress): ${invertedScore1}`);\n   500â†’    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (stress): ${invertedScore2}`);\n   501â†’    console.log(`     Regeneration normal score: ${metric3.score} â†’ Inverted (stress): ${invertedScore3}`);\n   502â†’\n   503â†’    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;\n   504â†’    console.log(`\\n  ğŸ“Š STRESS TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);\n   505â†’\n   506â†’    return {\n   507â†’      name: 'Stress',\n   508â†’      score: totalScore,\n   509â†’      maxScore: 3,\n   510â†’      classification: this.classifyScore(totalScore),\n   511â†’      metrics: [\n   512â†’        { name: 'Arousal Score', ...metric1, score: invertedScore1 },\n   513â†’        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },\n   514â†’        { name: 'Regeneration (Alpha Modulation)', ...metric3, score: invertedScore3 }\n   515â†’      ]\n   516â†’    };\n   517â†’  }\n   518â†’\n   519â†’  /**\n   520â†’   * 3. Focus & Attention\n   521â†’   * - Focus Theta\n   522â†’   * - Alpha:Theta Balance\n   523â†’   * - Focus Score (Theta:Beta)\n   524â†’   */\n   525â†’  calculateFocusAttention() {\n   526â†’    console.log('\\nğŸ“Š Calculating FOCUS & ATTENTION...');\n   527â†’    const metric1 = this.calculateFocusTheta();\n   528â†’    const metric2 = this.calculateAlphaThetaBalance();\n   529â†’    const metric3 = this.calculateFocusScore();\n   530â†’\n   531â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   532â†’    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n   533â†’\n   534â†’    return {\n   535â†’      name: 'Focus & Attention',\n   536â†’      score: totalScore,\n   537â†’      maxScore: 3,\n   538â†’      classification: this.classifyScore(totalScore),\n   539â†’      metrics: [\n   540â†’        { name: 'Focus Theta', ...metric1 },\n   541â†’        { name: 'Alpha:Theta Balance', ...metric2 },\n   542â†’        { name: 'Focus Score (Theta:Beta)', ...metric3 }\n   543â†’      ]\n   544â†’    };\n   545â†’  }\n   546â†’\n   547â†’  /**\n   548â†’   * 4. Burnout & Fatigue (Note: 0/3 is healthy)\n   549â†’   * - Arousal Score (inverted: abnormal = 1 point)\n   550â†’   * - Relaxation Score (inverted: abnormal = 1 point)\n   551â†’   * - Excessive Delta (inverted: abnormal = 1 point)\n   552â†’   */\n   553â†’  calculateBurnoutFatigue() {\n   554â†’    console.log('\\nğŸ“Š === BURNOUT & FATIGUE PARAMETER (0/3 = Healthy, 3/3 = High Burnout) ===');\n   555â†’    const metric1 = this.calculateArousalScore();\n   556â†’    const metric2 = this.calculateRelaxationScore();\n   557â†’    const metric3 = this.calculateExcessiveDelta();\n   558â†’\n   559â†’    // Invert scores: 0->1, 1->0 (so abnormal values add to burnout score)\n   560â†’    const invertedScore1 = 1 - metric1.score;\n   561â†’    const invertedScore2 = 1 - metric2.score;\n   562â†’    const invertedScore3 = 1 - metric3.score;\n   563â†’\n   564â†’    console.log(`\\n  ğŸ”„ INVERTING SCORES (abnormal values = burnout):`);\n   565â†’    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (burnout): ${invertedScore1}`);\n   566â†’    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (burnout): ${invertedScore2}`);\n   567â†’    console.log(`     Excessive Delta normal score: ${metric3.score} â†’ Inverted (burnout): ${invertedScore3}`);\n   568â†’\n   569â†’    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;\n   570â†’    console.log(`\\n  ğŸ“Š BURNOUT TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);\n   571â†’\n   572â†’    return {\n   573â†’      name: 'Burnout & Fatigue',\n   574â†’      score: totalScore,\n   575â†’      maxScore: 3,\n   576â†’      classification: this.classifyScore(totalScore),\n   577â†’      metrics: [\n   578â†’        { name: 'Arousal Score', ...metric1, score: invertedScore1 },\n   579â†’        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },\n   580â†’        { name: 'Excessive Delta', ...metric3, score: invertedScore3 }\n   581â†’      ]\n   582â†’    };\n   583â†’  }\n   584â†’\n   585â†’  /**\n   586â†’   * 5. Emotional Regulation\n   587â†’   * - Alpha Asymmetry\n   588â†’   * - Arousal Score\n   589â†’   * - Regeneration\n   590â†’   */\n   591â†’  calculateEmotionalRegulation() {\n   592â†’    console.log('\\nğŸ“Š Calculating EMOTIONAL REGULATION...');\n   593â†’    const metric1 = this.calculateAlphaAsymmetry();\n   594â†’    const metric2 = this.calculateArousalScore();\n   595â†’    const metric3 = this.calculateRegeneration();\n   596â†’\n   597â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   598â†’    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n   599â†’\n   600â†’    return {\n   601â†’      name: 'Emotional Regulation',\n   602â†’      score: totalScore,\n   603â†’      maxScore: 3,\n   604â†’      classification: this.classifyScore(totalScore),\n   605â†’      metrics: [\n   606â†’        { name: 'Alpha Asymmetry (Frontal)', ...metric1 },\n   607â†’        { name: 'Arousal Score', ...metric2 },\n   608â†’        { name: 'Regeneration (Alpha Modulation)', ...metric3 }\n   609â†’      ]\n   610â†’    };\n   611â†’  }\n   612â†’\n   613â†’  /**\n   614â†’   * 6. Learning\n   615â†’   * - Alpha Peak\n   616â†’   * - Focus Score (Theta:Beta)\n   617â†’   * - Arousal Score\n   618â†’   */\n   619â†’  calculateLearning() {\n   620â†’    console.log('\\nğŸ“Š Calculating LEARNING...');\n   621â†’    const metric1 = this.calculateAlphaPeak();\n   622â†’    const metric2 = this.calculateFocusScore();\n   623â†’    const metric3 = this.calculateArousalScore();\n   624â†’\n   625â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   626â†’    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n   627â†’\n   628â†’    return {\n   629â†’      name: 'Learning',\n   630â†’      score: totalScore,\n   631â†’      maxScore: 3,\n   632â†’      classification: this.classifyScore(totalScore),\n   633â†’      metrics: [\n   634â†’        { name: 'Alpha Peak', ...metric1 },\n   635â†’        { name: 'Focus Score (Theta:Beta)', ...metric2 },\n   636â†’        { name: 'Arousal Score', ...metric3 }\n   637â†’      ]\n   638â†’    };\n   639â†’  }\n   640â†’\n   641â†’  /**\n   642â†’   * 7. Creativity\n   643â†’   * - Relaxation Score\n   644â†’   * - Focus Score (Theta:Beta)\n   645â†’   * - Alpha Peak\n   646â†’   */\n   647â†’  calculateCreativity() {\n   648â†’    console.log('\\nğŸ“Š Calculating CREATIVITY...');\n   649â†’    const metric1 = this.calculateRelaxationScore();\n   650â†’    const metric2 = this.calculateFocusScore();\n   651â†’    const metric3 = this.calculateAlphaPeak();\n   652â†’\n   653â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   654â†’    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n   655â†’\n   656â†’    return {\n   657â†’      name: 'Creativity',\n   658â†’      score: totalScore,\n   659â†’      maxScore: 3,\n   660â†’      classification: this.classifyScore(totalScore),\n   661â†’      metrics: [\n   662â†’        { name: 'Relaxation Score', ...metric1 },\n   663â†’        { name: 'Focus Score (Theta:Beta)', ...metric2 },\n   664â†’        { name: 'Alpha Peak', ...metric3 }\n   665â†’      ]\n   666â†’    };\n   667â†’  }\n   668â†’}\n   669â†’\n   670â†’module.exports = AlgorithmCalculator;\n   671â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d31b38e1-af98-44b6-ae38-098407b4b9c2","timestamp":"2025-12-03T07:33:56.246Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\services\\algorithmCalculator.js","content":"/**\n * QEEG Algorithm Calculator\n * Based on Rhea's Report - Calculates 7 brain health parameters\n * Each parameter has 3 sub-metrics, scored 0-3, classified as Low/Medium/High\n */\n\nclass AlgorithmCalculator {\n  constructor(qeegData) {\n    this.data = qeegData;\n    this.results = {\n      parameters: [],\n      rawCalculations: {},\n      overallScore: 0\n    };\n  }\n\n  /**\n   * Main calculation method - calculates all 7 parameters\n   */\n  calculate() {\n    console.log('\\nğŸ§® ========== STARTING ALGORITHM CALCULATIONS ==========');\n    console.log('ğŸ“Š Input Data Structure:', JSON.stringify(this.data, null, 2));\n\n    const parameters = [\n      this.calculateCognition(),\n      this.calculateStress(),\n      this.calculateFocusAttention(),\n      this.calculateBurnoutFatigue(),\n      this.calculateEmotionalRegulation(),\n      this.calculateLearning(),\n      this.calculateCreativity()\n    ];\n\n    console.log('\\nâœ… Final 7 Parameter Scores Calculated:');\n    parameters.forEach((p, i) => {\n      console.log(`${i + 1}. ${p.name}: ${p.score}/${p.maxScore} (${p.classification}) ${this.getEmoji(p.classification)}`);\n      p.metrics.forEach(m => {\n        console.log(`   - ${m.name}: ${m.score} point (value: ${JSON.stringify(m.value)})`);\n      });\n    });\n    console.log('========== CALCULATIONS COMPLETE ==========\\n');\n\n    this.results.parameters = parameters;\n    this.results.overallScore = parameters.reduce((sum, p) => sum + p.score, 0);\n\n    return this.results;\n  }\n\n  getEmoji(classification) {\n    if (classification === 'Low') return 'ğŸ”´';\n    if (classification === 'Medium') return 'ğŸŸ¡';\n    return 'ğŸŸ¢';\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Get value from QEEG data table\n   * @param {string} condition - 'EC' (Eyes Closed) or 'EO' (Eyes Open)\n   * @param {string} powerType - 'absolute' or 'relative'\n   * @param {string} channel - e.g., 'Fz', 'Cz', 'Pz'\n   * @param {string} band - e.g., 'Theta', 'Alpha', 'Beta', 'HiBeta', 'Delta'\n   */\n  getValue(condition, powerType, channel, band) {\n    try {\n      return this.data[condition][powerType][channel][band];\n    } catch (error) {\n      console.error(`Error getting value: ${condition}.${powerType}.${channel}.${band}`);\n      return null;\n    }\n  }\n\n  /**\n   * Score a metric based on threshold\n   * Returns 1 if condition is met (HEALTHY/NORMAL state by default)\n   * Use 'invert: true' for stress/problem indicators\n   */\n  scoreMetric(value, threshold, comparison = 'less', invert = false) {\n    if (value === null || value === undefined) return 0;\n\n    let result = 0;\n\n    if (comparison === 'less') {\n      result = value < threshold ? 1 : 0;\n    } else if (comparison === 'more') {\n      result = value > threshold ? 1 : 0;\n    } else if (comparison === 'equal') {\n      result = value === threshold ? 1 : 0;\n    }\n\n    // Invert for stress/problem indicators (where 1 point = problem detected)\n    return invert ? (1 - result) : result;\n  }\n\n  /**\n   * Classify score to bucket (Low/Medium/High)\n   */\n  classifyScore(score) {\n    if (score <= 1) return 'Low';\n    if (score === 2) return 'Medium';\n    return 'High';\n  }\n\n  // ==================== INDIVIDUAL METRICS ====================\n\n  /**\n   * Focus Score (Theta:Beta Ratio) - Used in multiple parameters\n   * Eyes Open, Absolute Power, Fz & Cz average\n   * < 1.5 is normal\n   */\n  calculateFocusScore() {\n    console.log('\\n  ğŸ” === Calculating Focus Score (Theta:Beta) ===');\n    const fzTheta = this.getValue('EO', 'absolute', 'Fz', 'Theta');\n    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');\n    const czTheta = this.getValue('EO', 'absolute', 'Cz', 'Theta');\n    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');\n\n    console.log('     Raw Values:', { fzTheta, fzBeta, czTheta, czBeta });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null) {\n      console.log('     âŒ Missing values, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const fzRatio = fzTheta / fzBeta;\n    const czRatio = czTheta / czBeta;\n    const avgRatio = (fzRatio + czRatio) / 2;\n    const score = this.scoreMetric(avgRatio, 1.5, 'less');\n\n    console.log(`     Fz ratio: ${fzRatio.toFixed(3)}, Cz ratio: ${czRatio.toFixed(3)}`);\n    console.log(`     Average: ${avgRatio.toFixed(3)}`);\n    console.log(`     Threshold: < 1.5 = normal`);\n    console.log(`     Result: ${avgRatio.toFixed(3)} < 1.5 = ${avgRatio < 1.5}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: avgRatio,\n      score: score,\n      description: `Theta:Beta Ratio = ${avgRatio.toFixed(2)} (< 1.5 is normal)`,\n      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }\n    };\n  }\n\n  /**\n   * Alpha Peak - Used in multiple parameters\n   * Eyes Closed, Special (highest frequency at Pz or below)\n   * > 9 Hz is normal\n   */\n  calculateAlphaPeak() {\n    console.log('\\n  ğŸ” === Calculating Alpha Peak ===');\n    // Get alpha peak from data - NO DEFAULT VALUE\n    const alphaPeak = this.data.EC?.special?.alphaPeak || this.data.EC?.special?.O1 || null;\n\n    console.log('     Raw Value:', alphaPeak);\n\n    // If no data available, return 0 score\n    if (alphaPeak === null || alphaPeak === undefined) {\n      console.log('     âŒ No data available, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const score = this.scoreMetric(alphaPeak, 9, 'more');\n    console.log(`     Threshold: > 9 Hz = normal`);\n    console.log(`     Result: ${alphaPeak} > 9 = ${alphaPeak > 9}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: alphaPeak,\n      score: score,\n      description: `Alpha Peak = ${alphaPeak.toFixed(1)} Hz (> 9 is normal)`\n    };\n  }\n\n  /**\n   * Alpha:Theta Balance - Used in multiple parameters\n   * Eyes Closed, Absolute Power, Fz, Cz, Pz\n   * Order Pz > Cz > Fz is normal for eyes-closed (posterior dominance)\n   * NOTE: Per Rhea's report, posterior dominance (Pz > Cz > Fz) is \"actually common\n   * in eyes-closed recordings where alpha typically peaks over parietal/occipital sites\"\n   */\n  calculateAlphaThetaBalance() {\n    console.log('\\n  ğŸ” === Calculating Alpha:Theta Balance ===');\n    const fzAlpha = this.getValue('EC', 'absolute', 'Fz', 'Alpha');\n    const fzTheta = this.getValue('EC', 'absolute', 'Fz', 'Theta');\n    const czAlpha = this.getValue('EC', 'absolute', 'Cz', 'Alpha');\n    const czTheta = this.getValue('EC', 'absolute', 'Cz', 'Theta');\n    const pzAlpha = this.getValue('EC', 'absolute', 'Pz', 'Alpha');\n    const pzTheta = this.getValue('EC', 'absolute', 'Pz', 'Theta');\n\n    console.log('     Raw Values - Fz:', { Alpha: fzAlpha, Theta: fzTheta });\n    console.log('     Raw Values - Cz:', { Alpha: czAlpha, Theta: czTheta });\n    console.log('     Raw Values - Pz:', { Alpha: pzAlpha, Theta: pzTheta });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (fzAlpha == null || fzTheta == null || czAlpha == null || czTheta == null || pzAlpha == null || pzTheta == null) {\n      console.log('     âŒ Missing values, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const fzRatio = fzAlpha / fzTheta;\n    const czRatio = czAlpha / czTheta;\n    const pzRatio = pzAlpha / pzTheta;\n\n    console.log(`     Ratios - Fz: ${fzRatio.toFixed(2)}, Cz: ${czRatio.toFixed(2)}, Pz: ${pzRatio.toFixed(2)}`);\n    console.log(`     Expected Order: Pz > Cz > Fz (posterior dominant for EC)`);\n    console.log(`     Actual Order: Pz(${pzRatio.toFixed(2)}) > Cz(${czRatio.toFixed(2)}) > Fz(${fzRatio.toFixed(2)})`);\n\n    // Normal pattern for eyes-closed: Pz > Cz > Fz (posterior dominant)\n    const isNormalOrder = pzRatio > czRatio && czRatio > fzRatio;\n\n    console.log(`     Check: ${pzRatio.toFixed(2)} > ${czRatio.toFixed(2)} = ${pzRatio > czRatio}`);\n    console.log(`     Check: ${czRatio.toFixed(2)} > ${fzRatio.toFixed(2)} = ${czRatio > fzRatio}`);\n    console.log(`     âœ… SCORE: ${isNormalOrder ? 1 : 0}/1`);\n\n    return {\n      value: { fz: fzRatio.toFixed(2), cz: czRatio.toFixed(2), pz: pzRatio.toFixed(2) },\n      score: isNormalOrder ? 1 : 0,\n      description: `Alpha:Theta Order = ${isNormalOrder ? 'Pz > Cz > Fz (Normal for EC)' : 'Abnormal order'}`,\n      details: { fzRatio, czRatio, pzRatio, order: isNormalOrder }\n    };\n  }\n\n  /**\n   * Arousal Score (HiBeta:Beta Ratio) - Used in multiple parameters\n   * Eyes Open, Absolute Power, Fz & Cz average\n   * < 1 is normal\n   */\n  calculateArousalScore() {\n    console.log('\\n  ğŸ” === Calculating Arousal Score (HiBeta:Beta) ===');\n    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');\n    const fzHiBeta = this.getValue('EO', 'absolute', 'Fz', 'HiBeta');\n    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');\n    const czHiBeta = this.getValue('EO', 'absolute', 'Cz', 'HiBeta');\n\n    console.log('     Raw Values - Fz:', { Beta: fzBeta, HiBeta: fzHiBeta });\n    console.log('     Raw Values - Cz:', { Beta: czBeta, HiBeta: czHiBeta });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (fzBeta == null || fzHiBeta == null || czBeta == null || czHiBeta == null) {\n      console.log('     âŒ Missing values, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const fzRatio = fzHiBeta / fzBeta;\n    const czRatio = czHiBeta / czBeta;\n    const avgRatio = (fzRatio + czRatio) / 2;\n    const score = this.scoreMetric(avgRatio, 1, 'less');\n\n    console.log(`     Fz ratio (HiBeta/Beta): ${fzRatio.toFixed(3)}`);\n    console.log(`     Cz ratio (HiBeta/Beta): ${czRatio.toFixed(3)}`);\n    console.log(`     Average: ${avgRatio.toFixed(3)}`);\n    console.log(`     Threshold: < 1 = normal (low arousal)`);\n    console.log(`     Result: ${avgRatio.toFixed(3)} < 1 = ${avgRatio < 1}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: avgRatio,\n      score: score,\n      description: `Arousal Score = ${avgRatio.toFixed(2)} (< 1 is normal)`,\n      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }\n    };\n  }\n\n  /**\n   * Relaxation Score - Used in multiple parameters\n   * Eyes Closed, RELATIVE Power, Pz, Alpha/Beta\n   * >= 10 is healthy\n   */\n  calculateRelaxationScore() {\n    console.log('\\n  ğŸ” === Calculating Relaxation Score ===');\n    console.log('     Using: EC RELATIVE power, Pz channel');\n    const pzAlpha = this.getValue('EC', 'relative', 'Pz', 'Alpha');\n    const pzBeta = this.getValue('EC', 'relative', 'Pz', 'Beta');\n\n    console.log('     Raw Values - Pz:', { Alpha: pzAlpha, Beta: pzBeta });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (pzAlpha == null || pzBeta == null || pzBeta === 0) {\n      console.log('     âš ï¸ Missing or zero Beta value, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const ratio = pzAlpha / pzBeta;\n\n    console.log(`     Ratio: ${pzAlpha} / ${pzBeta} = ${ratio.toFixed(2)}`);\n    console.log(`     Threshold: >= 9.9 (accounting for rounding, ~10.0 is healthy)`);\n    console.log(`     Result: ${ratio.toFixed(2)} >= 9.9 = ${ratio >= 9.9}`);\n\n    // Use >= 9.9 to account for rounding (9.96 â‰ˆ 10.0 is considered healthy)\n    const score = ratio >= 9.9 ? 1 : 0;\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: ratio,\n      score: score,\n      description: `Relaxation Score = ${ratio.toFixed(2)} (>= 10 is healthy)`\n    };\n  }\n\n  /**\n   * Regeneration (Alpha Modulation) - Used in multiple parameters\n   * EO & EC, Relative Power, Pz, (EC-EO)/EC * 100\n   * > 30% is healthy\n   */\n  calculateRegeneration() {\n    console.log('\\n  ğŸ” === Calculating Regeneration (Alpha Modulation) ===');\n    console.log('     Using: EC vs EO relative power at Pz');\n    const ecAlpha = this.getValue('EC', 'relative', 'Pz', 'Alpha');\n    const eoAlpha = this.getValue('EO', 'relative', 'Pz', 'Alpha');\n\n    console.log('     Raw Values:', { 'EC Alpha': ecAlpha, 'EO Alpha': eoAlpha });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (ecAlpha == null || eoAlpha == null || ecAlpha === 0) {\n      console.log('     âŒ Missing or zero EC Alpha value, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const modulation = ((ecAlpha - eoAlpha) / ecAlpha) * 100;\n    const score = this.scoreMetric(modulation, 30, 'more');\n\n    console.log(`     Formula: ((EC - EO) / EC) Ã— 100`);\n    console.log(`     Calculation: ((${ecAlpha} - ${eoAlpha}) / ${ecAlpha}) Ã— 100`);\n    console.log(`     Modulation: ${modulation.toFixed(1)}%`);\n    console.log(`     Threshold: > 30% = healthy (good alpha reactivity)`);\n    console.log(`     Result: ${modulation.toFixed(1)}% > 30% = ${modulation > 30}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: modulation,\n      score: score,\n      description: `Alpha Modulation = ${modulation.toFixed(1)}% (> 30% is healthy)`\n    };\n  }\n\n  /**\n   * Focus Theta (Relative Power) - Used in Focus & Attention\n   * Eyes Open, Relative Power, Fz & Cz average\n   * < 20% is normal\n   */\n  calculateFocusTheta() {\n    console.log('\\n  ğŸ” === Calculating Focus Theta ===');\n    console.log('     Using: EO relative power at Fz and Cz');\n    const fzTheta = this.getValue('EO', 'relative', 'Fz', 'Theta');\n    const czTheta = this.getValue('EO', 'relative', 'Cz', 'Theta');\n\n    console.log('     Raw Values:', { 'Fz Theta': fzTheta, 'Cz Theta': czTheta });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (fzTheta == null || czTheta == null) {\n      console.log('     âŒ Missing values, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const avgTheta = (fzTheta + czTheta) / 2;\n    const score = this.scoreMetric(avgTheta, 20, 'less');\n\n    console.log(`     Average: (${fzTheta} + ${czTheta}) / 2 = ${avgTheta.toFixed(1)}%`);\n    console.log(`     Threshold: < 20% = normal (low frontal theta)`);\n    console.log(`     Result: ${avgTheta.toFixed(1)}% < 20% = ${avgTheta < 20}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: avgTheta,\n      score: score,\n      description: `Focus Theta = ${avgTheta.toFixed(1)}% (< 20% is normal)`\n    };\n  }\n\n  /**\n   * Excessive Delta - Used in Burnout & Fatigue\n   * Eyes Open, Relative Power, avg of Fz, C3, Cz, C4, P3, Pz, P4\n   * < 70% is normal\n   */\n  calculateExcessiveDelta() {\n    console.log('\\n  ğŸ” === Calculating Excessive Delta ===');\n    console.log('     Using: EO relative power, averaging 7 channels');\n    const channels = ['Fz', 'C3', 'Cz', 'C4', 'P3', 'Pz', 'P4'];\n    let sum = 0;\n    let count = 0;\n    const channelValues = {};\n\n    for (const channel of channels) {\n      const delta = this.getValue('EO', 'relative', channel, 'Delta');\n      channelValues[channel] = delta !== null ? delta : 'N/A';\n      if (delta !== null) {\n        sum += delta;\n        count++;\n      }\n    }\n\n    console.log('     Channel Values:', channelValues);\n    console.log(`     Valid channels: ${count}/7`);\n\n    if (count === 0) {\n      console.log('     âŒ No valid channel data, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const avgDelta = sum / count;\n    const score = this.scoreMetric(avgDelta, 70, 'less');\n\n    console.log(`     Sum: ${sum.toFixed(2)}, Count: ${count}`);\n    console.log(`     Average Delta: ${avgDelta.toFixed(1)}%`);\n    console.log(`     Threshold: < 70% = normal (low delta during wakefulness)`);\n    console.log(`     Result: ${avgDelta.toFixed(1)}% < 70% = ${avgDelta < 70}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: avgDelta,\n      score: score,\n      description: `Excessive Delta = ${avgDelta.toFixed(1)}% (< 70% is normal)`\n    };\n  }\n\n  /**\n   * Alpha Asymmetry (Frontal) - Used in Emotional Regulation\n   * Eyes Closed, Absolute Power, F3 & F4\n   * F4/F3 < 1 is normal\n   */\n  calculateAlphaAsymmetry() {\n    console.log('\\n  ğŸ” === Calculating Alpha Asymmetry (Frontal) ===');\n    console.log('     Using: EC absolute power at F3 and F4');\n    const f3Alpha = this.getValue('EC', 'absolute', 'F3', 'Alpha');\n    const f4Alpha = this.getValue('EC', 'absolute', 'F4', 'Alpha');\n\n    console.log('     Raw Values:', { 'F3 Alpha': f3Alpha, 'F4 Alpha': f4Alpha });\n\n    // Fix: Use == null to allow 0 values (valid EEG readings)\n    if (f3Alpha == null || f4Alpha == null || f3Alpha === 0) {\n      console.log('     âŒ Missing or zero F3 value, returning 0');\n      return { value: null, score: 0 };\n    }\n\n    const ratio = f4Alpha / f3Alpha;\n    const score = this.scoreMetric(ratio, 1, 'less');\n\n    console.log(`     Ratio: F4/F3 = ${f4Alpha} / ${f3Alpha} = ${ratio.toFixed(3)}`);\n    console.log(`     Threshold: < 1 = normal (left frontal dominance, positive affect)`);\n    console.log(`     Result: ${ratio.toFixed(3)} < 1 = ${ratio < 1}`);\n    console.log(`     âœ… SCORE: ${score}/1`);\n\n    return {\n      value: ratio,\n      score: score,\n      description: `Alpha Asymmetry = ${ratio.toFixed(2)} (< 1 is normal)`\n    };\n  }\n\n  // ==================== 7 PARAMETER CALCULATIONS ====================\n\n  /**\n   * 1. Cognition\n   * - Focus Score (Theta:Beta Ratio)\n   * - Alpha Peak\n   * - Alpha:Theta Balance\n   */\n  calculateCognition() {\n    console.log('\\nğŸ“Š Calculating COGNITION...');\n    const metric1 = this.calculateFocusScore();\n    const metric2 = this.calculateAlphaPeak();\n    const metric3 = this.calculateAlphaThetaBalance();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n\n    return {\n      name: 'Cognition',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Focus Score (Theta:Beta)', ...metric1 },\n        { name: 'Alpha Peak', ...metric2 },\n        { name: 'Alpha:Theta Balance', ...metric3 }\n      ]\n    };\n  }\n\n  /**\n   * 2. Stress (Note: 0/3 is healthy, 3/3 is high stress)\n   * - Arousal Score (inverted: abnormal = 1 point)\n   * - Relaxation Score (inverted: abnormal = 1 point)\n   * - Regeneration (inverted: abnormal = 1 point)\n   */\n  calculateStress() {\n    console.log('\\nğŸ“Š === STRESS PARAMETER (0/3 = Healthy, 3/3 = High Stress) ===');\n    const metric1 = this.calculateArousalScore();\n    const metric2 = this.calculateRelaxationScore();\n    const metric3 = this.calculateRegeneration();\n\n    // Invert scores: 0->1, 1->0 (so abnormal values add to stress score)\n    const invertedScore1 = 1 - metric1.score;\n    const invertedScore2 = 1 - metric2.score;\n    const invertedScore3 = 1 - metric3.score;\n\n    console.log(`\\n  ğŸ”„ INVERTING SCORES (abnormal values = stress):`);\n    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (stress): ${invertedScore1}`);\n    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (stress): ${invertedScore2}`);\n    console.log(`     Regeneration normal score: ${metric3.score} â†’ Inverted (stress): ${invertedScore3}`);\n\n    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;\n    console.log(`\\n  ğŸ“Š STRESS TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);\n\n    return {\n      name: 'Stress',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Arousal Score', ...metric1, score: invertedScore1 },\n        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },\n        { name: 'Regeneration (Alpha Modulation)', ...metric3, score: invertedScore3 }\n      ]\n    };\n  }\n\n  /**\n   * 3. Focus & Attention\n   * - Focus Theta\n   * - Alpha:Theta Balance\n   * - Focus Score (Theta:Beta)\n   */\n  calculateFocusAttention() {\n    console.log('\\nğŸ“Š Calculating FOCUS & ATTENTION...');\n    const metric1 = this.calculateFocusTheta();\n    const metric2 = this.calculateAlphaThetaBalance();\n    const metric3 = this.calculateFocusScore();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n\n    return {\n      name: 'Focus & Attention',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Focus Theta', ...metric1 },\n        { name: 'Alpha:Theta Balance', ...metric2 },\n        { name: 'Focus Score (Theta:Beta)', ...metric3 }\n      ]\n    };\n  }\n\n  /**\n   * 4. Burnout & Fatigue (Note: 0/3 is healthy)\n   * - Arousal Score (inverted: abnormal = 1 point)\n   * - Relaxation Score (inverted: abnormal = 1 point)\n   * - Excessive Delta (inverted: abnormal = 1 point)\n   */\n  calculateBurnoutFatigue() {\n    console.log('\\nğŸ“Š === BURNOUT & FATIGUE PARAMETER (0/3 = Healthy, 3/3 = High Burnout) ===');\n    const metric1 = this.calculateArousalScore();\n    const metric2 = this.calculateRelaxationScore();\n    const metric3 = this.calculateExcessiveDelta();\n\n    // Invert scores: 0->1, 1->0 (so abnormal values add to burnout score)\n    const invertedScore1 = 1 - metric1.score;\n    const invertedScore2 = 1 - metric2.score;\n    const invertedScore3 = 1 - metric3.score;\n\n    console.log(`\\n  ğŸ”„ INVERTING SCORES (abnormal values = burnout):`);\n    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (burnout): ${invertedScore1}`);\n    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (burnout): ${invertedScore2}`);\n    console.log(`     Excessive Delta normal score: ${metric3.score} â†’ Inverted (burnout): ${invertedScore3}`);\n\n    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;\n    console.log(`\\n  ğŸ“Š BURNOUT TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);\n\n    return {\n      name: 'Burnout & Fatigue',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Arousal Score', ...metric1, score: invertedScore1 },\n        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },\n        { name: 'Excessive Delta', ...metric3, score: invertedScore3 }\n      ]\n    };\n  }\n\n  /**\n   * 5. Emotional Regulation\n   * - Alpha Asymmetry\n   * - Arousal Score\n   * - Regeneration\n   */\n  calculateEmotionalRegulation() {\n    console.log('\\nğŸ“Š Calculating EMOTIONAL REGULATION...');\n    const metric1 = this.calculateAlphaAsymmetry();\n    const metric2 = this.calculateArousalScore();\n    const metric3 = this.calculateRegeneration();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n\n    return {\n      name: 'Emotional Regulation',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Alpha Asymmetry (Frontal)', ...metric1 },\n        { name: 'Arousal Score', ...metric2 },\n        { name: 'Regeneration (Alpha Modulation)', ...metric3 }\n      ]\n    };\n  }\n\n  /**\n   * 6. Learning\n   * - Alpha Peak\n   * - Focus Score (Theta:Beta)\n   * - Arousal Score\n   */\n  calculateLearning() {\n    console.log('\\nğŸ“Š Calculating LEARNING...');\n    const metric1 = this.calculateAlphaPeak();\n    const metric2 = this.calculateFocusScore();\n    const metric3 = this.calculateArousalScore();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n\n    return {\n      name: 'Learning',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Alpha Peak', ...metric1 },\n        { name: 'Focus Score (Theta:Beta)', ...metric2 },\n        { name: 'Arousal Score', ...metric3 }\n      ]\n    };\n  }\n\n  /**\n   * 7. Creativity\n   * - Relaxation Score\n   * - Focus Score (Theta:Beta)\n   * - Alpha Peak\n   */\n  calculateCreativity() {\n    console.log('\\nğŸ“Š Calculating CREATIVITY...');\n    const metric1 = this.calculateRelaxationScore();\n    const metric2 = this.calculateFocusScore();\n    const metric3 = this.calculateAlphaPeak();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);\n\n    return {\n      name: 'Creativity',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [\n        { name: 'Relaxation Score', ...metric1 },\n        { name: 'Focus Score (Theta:Beta)', ...metric2 },\n        { name: 'Alpha Peak', ...metric3 }\n      ]\n    };\n  }\n}\n\nmodule.exports = AlgorithmCalculator;\n","numLines":671,"startLine":1,"totalLines":671}}}
{"parentUuid":"d31b38e1-af98-44b6-ae38-098407b4b9c2","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013E3L8mDueaJBFpH8SFqX9q","type":"tool_result","content":"     1â†’const { GoogleGenerativeAI } = require('@google/generative-ai');\n     2â†’\n     3â†’class GeminiService {\n     4â†’  constructor() {\n     5â†’    console.log('\\nğŸ”§ Initializing Gemini Service...');\n     6â†’    this.apiKey = process.env.GEMINI_API_KEY;\n     7â†’\n     8â†’    if (!this.apiKey) {\n     9â†’      console.error('âŒ CRITICAL: GEMINI_API_KEY not found in environment variables!');\n    10â†’      console.error('   Please check your .env file');\n    11â†’    } else {\n    12â†’      console.log('âœ… Gemini API Key found');\n    13â†’      console.log('   Key length:', this.apiKey.length);\n    14â†’      console.log('   Key preview:', `${this.apiKey.substring(0, 15)}...`);\n    15â†’    }\n    16â†’\n    17â†’    this.genAI = this.apiKey ? new GoogleGenerativeAI(this.apiKey) : null;\n    18â†’    this.model = null;\n    19â†’    console.log('âœ… Gemini Service initialized\\n');\n    20â†’  }\n    21â†’\n    22â†’  /**\n    23â†’   * Fetch available Gemini models\n    24â†’   */\n    25â†’  async fetchAvailableModels() {\n    26â†’    try {\n    27â†’      console.log('ğŸ” Fetching available Gemini models for PDF generation...');\n    28â†’\n    29â†’      const response = await fetch(\n    30â†’        `https://generativelanguage.googleapis.com/v1/models?key=${this.apiKey}`\n    31â†’      );\n    32â†’\n    33â†’      if (!response.ok) {\n    34â†’        throw new Error(`API returned ${response.status}: ${response.statusText}`);\n    35â†’      }\n    36â†’\n    37â†’      const data = await response.json();\n    38â†’\n    39â†’      const supportedModels = (data.models || []).filter(model =>\n    40â†’        model.supportedGenerationMethods?.includes('generateContent')\n    41â†’      );\n    42â†’\n    43â†’      console.log(`âœ… Found ${supportedModels.length} models for PDF generation`);\n    44â†’      return supportedModels;\n    45â†’    } catch (error) {\n    46â†’      console.error('âŒ Failed to fetch models:', error.message);\n    47â†’      return [];\n    48â†’    }\n    49â†’  }\n    50â†’\n    51â†’  /**\n    52â†’   * Select best model for PDF generation\n    53â†’   */\n    54â†’  selectBestModel(models) {\n    55â†’    if (!models || models.length === 0) return null;\n    56â†’\n    57â†’    // Prefer flash models for speed\n    58â†’    const preferences = ['flash', 'pro'];\n    59â†’\n    60â†’    for (const preference of preferences) {\n    61â†’      const found = models.find(m =>\n    62â†’        m.name.toLowerCase().includes(preference)\n    63â†’      );\n    64â†’      if (found) {\n    65â†’        console.log(`âœ… Selected model for PDF: ${found.name}`);\n    66â†’        return found.name;\n    67â†’      }\n    68â†’    }\n    69â†’\n    70â†’    console.log(`âœ… Using first available model: ${models[0].name}`);\n    71â†’    return models[0].name;\n    72â†’  }\n    73â†’\n    74â†’  /**\n    75â†’   * Initialize the Gemini model\n    76â†’   */\n    77â†’  async initModel() {\n    78â†’    if (!this.genAI) {\n    79â†’      throw new Error('Gemini API not initialized. Please check GEMINI_API_KEY.');\n    80â†’    }\n    81â†’\n    82â†’    console.log('ğŸ”§ Initializing Gemini model for PDF generation...');\n    83â†’    console.log('ğŸ”‘ API Key status:', this.apiKey ? 'Present' : 'MISSING');\n    84â†’\n    85â†’    // Fetch available models dynamically\n    86â†’    const availableModels = await this.fetchAvailableModels();\n    87â†’\n    88â†’    if (availableModels.length === 0) {\n    89â†’      console.error('\\nâŒ No models available for PDF generation!');\n    90â†’      console.error('Please check your GEMINI_API_KEY at https://aistudio.google.com/apikey\\n');\n    91â†’      throw new Error('No Gemini models available. Check your API key.');\n    92â†’    }\n    93â†’\n    94â†’    // Select best model\n    95â†’    const modelName = this.selectBestModel(availableModels);\n    96â†’\n    97â†’    if (!modelName) {\n    98â†’      throw new Error('Could not select a valid model for PDF generation');\n    99â†’    }\n   100â†’\n   101â†’    // Initialize model with full path\n   102â†’    console.log(`ğŸ”§ Initializing model: ${modelName}`);\n   103â†’    this.model = this.genAI.getGenerativeModel({ model: modelName });\n   104â†’\n   105â†’    // Test the model\n   106â†’    console.log('ğŸ“ Testing model...');\n   107â†’    try {\n   108â†’      const testResult = await this.model.generateContent('Hello');\n   109â†’      const testResponse = await testResult.response;\n   110â†’      testResponse.text();\n   111â†’      console.log('âœ… Model initialized and tested successfully for PDF generation');\n   112â†’    } catch (testError) {\n   113â†’      console.error(`âŒ Model test failed:`, testError.message);\n   114â†’      throw new Error(`Failed to test model ${modelName}: ${testError.message}`);\n   115â†’    }\n   116â†’\n   117â†’    return this.model;\n   118â†’  }\n   119â†’\n   120â†’  /**\n   121â†’   * System prompt for brain performance report generation\n   122â†’   */\n   123â†’  getReportGenerationPrompt() {\n   124â†’    return `You are an expert neuroscience report generator powered by AI. Your task is to create a comprehensive, visually appealing, and easy-to-understand brain performance infographic report for patients.\n   125â†’\n   126â†’ğŸ¯ YOUR ROLE:\n   127â†’Generate a professional single-page A4 infographic-style brain health report based on QEEG (Quantitative Electroencephalography) analysis results. The report must be informative yet accessible to non-medical readers.\n   128â†’\n   129â†’ğŸ“Š INPUT DATA:\n   130â†’You will receive 7 brain performance parameters with their scores, classifications, and sub-metrics:\n   131â†’1. **Cognition** - Mental processing, focus ability, and alpha-theta balance\n   132â†’2. **Stress** - Arousal levels, relaxation capacity, and regeneration ability\n   133â†’3. **Focus & Attention** - Concentration ability, theta levels, and mental alertness\n   134â†’4. **Burnout & Fatigue** - Energy levels, exhaustion markers, and delta wave patterns\n   135â†’5. **Emotional Regulation** - Mood stability, frontal alpha asymmetry, and emotional control\n   136â†’6. **Learning** - Cognitive flexibility, memory formation, and neural plasticity\n   137â†’7. **Creativity** - Divergent thinking, relaxation state, and innovative capacity\n   138â†’\n   139â†’ğŸ“‹ SCORING SYSTEM:\n   140â†’- Each parameter is scored from 0-3 points\n   141â†’- Classification: Low (0-1), Medium (2), High (3)\n   142â†’- Sub-metrics contribute individual points to the total score\n   143â†’- **Special Note**: For Stress and Burnout parameters, LOWER scores are BETTER (0/3 = Healthy, 3/3 = High Problem)\n   144â†’\n   145â†’ğŸ¨ INFOGRAPHIC REPORT REQUIREMENTS:\n   146â†’\n   147â†’1. **Visual Design**:\n   148â†’   - Modern, clean, and colorful layout\n   149â†’   - Use vibrant but professional colors\n   150â†’   - Each parameter should have a distinct visual identity\n   151â†’   - Icons and graphical elements for each brain function\n   152â†’   - Color-coded scoring system (Green = Optimal, Yellow = Moderate, Red = Needs Attention)\n   153â†’\n   154â†’2. **Content Structure**:\n   155â†’   - Patient-friendly language (avoid heavy medical jargon)\n   156â†’   - One-line impactful summary for each parameter\n   157â†’   - Clear explanation of what each metric means in daily life\n   158â†’   - Practical interpretation of scores\n   159â†’   - Holistic overall summary\n   160â†’\n   161â†’3. **Parameter Presentation**:\n   162â†’   - Parameter name in bold, large font\n   163â†’   - Score displayed prominently (e.g., \"2/3 - Medium\")\n   164â†’   - Color-coded badge/banner based on classification\n   165â†’   - List all sub-metrics with checkmarks (âœ“) or crosses (âœ—)\n   166â†’   - Simple explanation of what each sub-metric indicates\n   167â†’\n   168â†’4. **Color Coding Guidelines**:\n   169â†’   For HEALTH parameters (Cognition, Focus, Emotional Regulation, Learning, Creativity):\n   170â†’   - High (3/3): #38A169 (Green) - Excellent performance\n   171â†’   - Medium (2/3): #F59E0B (Amber) - Good, room for improvement\n   172â†’   - Low (0-1/3): #E53E3E (Red) - Needs attention\n   173â†’\n   174â†’   For PROBLEM parameters (Stress, Burnout):\n   175â†’   - Low (0/3): #38A169 (Green) - Healthy, no issues\n   176â†’   - Medium (1-2/3): #F59E0B (Amber) - Moderate concern\n   177â†’   - High (3/3): #E53E3E (Red) - High concern\n   178â†’\n   179â†’5. **Interpretations Guidelines**:\n   180â†’   - Explain what HIGH scores mean for each parameter\n   181â†’   - Explain what LOW scores mean\n   182â†’   - Connect brain metrics to real-life implications\n   183â†’   - Examples:\n   184â†’     * \"High Focus & Attention (3/3): Your brain shows excellent concentration ability and minimal distracting theta activity\"\n   185â†’     * \"Low Stress (0/3): Great news! Your brain shows healthy relaxation patterns and low arousal\"\n   186â†’     * \"Medium Cognition (2/3): Good cognitive function with room for optimization in alpha-theta balance\"\n   187â†’\n   188â†’6. **Sub-Metrics Explanation Examples**:\n   189â†’   - \"Focus Score (Theta:Beta Ratio): âœ“ Optimal - Your frontal brain regions show balanced activity for sustained attention\"\n   190â†’   - \"Relaxation Score: âœ— Below threshold - Your brain may have difficulty shifting into relaxed states\"\n   191â†’   - \"Alpha Peak: âœ“ Normal - Healthy alpha rhythm frequency indicates good brain maturation\"\n   192â†’\n   193â†’7. **Overall Summary Requirements**:\n   194â†’   - Synthesize all 7 parameters into a cohesive narrative\n   195â†’   - Highlight strengths and areas for improvement\n   196â†’   - Provide context about what the overall pattern suggests\n   197â†’   - Maintain encouraging and constructive tone\n   198â†’   - 3-5 sentences maximum\n   199â†’\n   200â†’8. **Recommendations**:\n   201â†’   - Provide 4-6 actionable, personalized recommendations\n   202â†’   - Base suggestions on the actual scores received\n   203â†’   - Include lifestyle, cognitive training, or mindfulness suggestions\n   204â†’   - Keep recommendations practical and achievable\n   205â†’\n   206â†’ğŸ“¤ OUTPUT FORMAT:\n   207â†’\n   208â†’Return ONLY a valid JSON object (no markdown, no code blocks, no explanations) with this EXACT structure:\n   209â†’\n   210â†’{\n   211â†’  \"title\": \"Brain Performance Analysis Report\",\n   212â†’  \"patientSummary\": \"A comprehensive 3-5 sentence summary synthesizing all parameters, highlighting key strengths and areas for growth, with an encouraging tone\",\n   213â†’  \"parameters\": [\n   214â†’    {\n   215â†’      \"name\": \"Cognition\",\n   216â†’      \"score\": 2,\n   217â†’      \"maxScore\": 3,\n   218â†’      \"bucket\": \"Medium\",\n   219â†’      \"bucketColor\": \"#F59E0B\",\n   220â†’      \"icon\": \"ğŸ§ \",\n   221â†’      \"summary\": \"One impactful sentence summarizing this parameter's meaning and result\",\n   222â†’      \"subparameters\": [\n   223â†’        {\n   224â†’          \"name\": \"Focus Score (Theta:Beta Ratio)\",\n   225â†’          \"score\": 1,\n   226â†’          \"interpretation\": \"Clear explanation of what this score means in daily life\",\n   227â†’          \"details\": \"Technical detail if helpful: actual value and threshold\"\n   228â†’        }\n   229â†’      ]\n   230â†’    }\n   231â†’  ],\n   232â†’  \"recommendations\": [\n   233â†’    \"Specific actionable recommendation based on the actual scores\",\n   234â†’    \"Another personalized suggestion\",\n   235â†’    \"Lifestyle tip relevant to the results\",\n   236â†’    \"Cognitive exercise or mindfulness practice if applicable\"\n   237â†’  ],\n   238â†’  \"layoutSuggestions\": {\n   239â†’    \"colorScheme\": \"Professional palette: Deep blue header (#323956), parameter colors as specified, white background (#FFFFFF)\",\n   240â†’    \"structure\": \"Grid layout: 2 columns for parameters, header with title and patient info, summary and recommendations at bottom\"\n   241â†’  }\n   242â†’}\n   243â†’\n   244â†’ğŸš¨ CRITICAL REQUIREMENTS:\n   245â†’1. Return PURE JSON only - no ```json```, no markdown, no extra text\n   246â†’2. Include ALL subparameters from input data - don't skip any\n   247â†’3. Use the EXACT maxScore value from input (always 3 for these parameters)\n   248â†’4. Remember: For Stress and Burnout, LOW scores are GOOD, HIGH scores are CONCERNING\n   249â†’5. Each subparameter must have a score (0 or 1), interpretation, and optional details\n   250â†’6. Icons should be brain-related emojis: ğŸ§  ğŸ’¡ ğŸ¯ âš¡ ğŸ˜Œ ğŸ“š ğŸ¨ or similar\n   251â†’7. Make interpretations relatable - focus on real-world meaning, not just EEG jargon\n   252â†’8. Ensure bucketColor uses valid hex codes\n   253â†’9. Overall tone: Professional yet warm, informative yet encouraging\n   254â†’\n   255â†’âœ¨ QUALITY CHECKLIST:\n   256â†’- Are all 7 parameters included?\n   257â†’- Do all parameters have their sub-metrics listed?\n   258â†’- Are interpretations written in simple, patient-friendly language?\n   259â†’- Is the color coding correct (especially for Stress/Burnout inverse scoring)?\n   260â†’- Does the summary provide a holistic view?\n   261â†’- Are recommendations specific and actionable?\n   262â†’\n   263â†’Generate the report now based on the brain parameters data provided below.`;\n   264â†’  }\n   265â†’\n   266â†’  /**\n   267â†’   * Generate brain performance report using Gemini AI\n   268â†’   * @param {Object} brainParameters - The 7 brain parameters with scores and buckets\n   269â†’   * @returns {Promise<Object>} Generated report structure\n   270â†’   */\n   271â†’  async generateBrainPerformanceReport(brainParameters) {\n   272â†’    try {\n   273â†’      console.log('\\nğŸ”‘ Checking Gemini API configuration...');\n   274â†’      console.log('   API Key exists:', !!this.apiKey);\n   275â†’      console.log('   API Key length:', this.apiKey ? this.apiKey.length : 0);\n   276â†’      console.log('   API Key preview:', this.apiKey ? `${this.apiKey.substring(0, 10)}...` : 'MISSING');\n   277â†’\n   278â†’      if (!this.model) {\n   279â†’        console.log('ğŸ“± Initializing Gemini model...');\n   280â†’        await this.initModel();\n   281â†’      }\n   282â†’\n   283â†’      console.log('ğŸ¤– Generating brain performance report with Gemini AI...');\n   284â†’      console.log('ğŸ“Š Input parameters count:', Object.keys(brainParameters).length);\n   285â†’\n   286â†’      // Create the prompt with system instructions and data\n   287â†’      const systemPrompt = this.getReportGenerationPrompt();\n   288â†’      const dataPrompt = `\\n\\nBrain Parameters Data:\\n${JSON.stringify(brainParameters, null, 2)}\\n\\nPlease generate the infographic report description in JSON format as specified.`;\n   289â†’\n   290â†’      const fullPrompt = systemPrompt + dataPrompt;\n   291â†’      console.log('ğŸ“ Prompt length:', fullPrompt.length, 'characters');\n   292â†’\n   293â†’      // Generate content\n   294â†’      console.log('â³ Calling Gemini API...');\n   295â†’      const result = await this.model.generateContent(fullPrompt);\n   296â†’      const response = await result.response;\n   297â†’      const text = response.text();\n   298â†’\n   299â†’      console.log('âœ… Gemini response received!');\n   300â†’      console.log('   Response length:', text.length, 'characters');\n   301â†’\n   302â†’      // Try to parse JSON from the response\n   303â†’      let reportData;\n   304â†’      try {\n   305â†’        // Remove markdown code blocks if present\n   306â†’        const jsonText = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n   307â†’        reportData = JSON.parse(jsonText);\n   308â†’      } catch (parseError) {\n   309â†’        console.error('Failed to parse JSON response:', parseError);\n   310â†’        // Return raw text if JSON parsing fails\n   311â†’        reportData = {\n   312â†’          title: 'Brain Performance Report',\n   313â†’          rawContent: text,\n   314â†’          parameters: [],\n   315â†’          error: 'Failed to parse structured response'\n   316â†’        };\n   317â†’      }\n   318â†’\n   319â†’      return {\n   320â†’        success: true,\n   321â†’        data: reportData,\n   322â†’        rawResponse: text\n   323â†’      };\n   324â†’\n   325â†’    } catch (error) {\n   326â†’      console.error('\\nâŒ === GEMINI API ERROR ===');\n   327â†’      console.error('Error Type:', error.constructor.name);\n   328â†’      console.error('Error Message:', error.message);\n   329â†’      console.error('Error Code:', error.code || 'N/A');\n   330â†’      console.error('Error Status:', error.status || 'N/A');\n   331â†’      console.error('Full Error:', JSON.stringify(error, null, 2));\n   332â†’      console.error('Stack:', error.stack);\n   333â†’      console.error('==========================\\n');\n   334â†’\n   335â†’      return {\n   336â†’        success: false,\n   337â†’        error: error.message,\n   338â†’        errorDetails: {\n   339â†’          type: error.constructor.name,\n   340â†’          code: error.code,\n   341â†’          status: error.status\n   342â†’        },\n   343â†’        data: null\n   344â†’      };\n   345â†’    }\n   346â†’  }\n   347â†’\n   348â†’  /**\n   349â†’   * Generate simple text completion\n   350â†’   * @param {string} prompt - The prompt text\n   351â†’   * @returns {Promise<string>} Generated text\n   352â†’   */\n   353â†’  async generateText(prompt) {\n   354â†’    try {\n   355â†’      if (!this.model) {\n   356â†’        await this.initModel();\n   357â†’      }\n   358â†’\n   359â†’      const result = await this.model.generateContent(prompt);\n   360â†’      const response = await result.response;\n   361â†’      return response.text();\n   362â†’\n   363â†’    } catch (error) {\n   364â†’      console.error('Error generating text with Gemini:', error);\n   365â†’      throw error;\n   366â†’    }\n   367â†’  }\n   368â†’\n   369â†’  /**\n   370â†’   * Test Gemini API connection\n   371â†’   */\n   372â†’  async testConnection() {\n   373â†’    try {\n   374â†’      const response = await this.generateText('Hello! Please respond with \"OK\" if you can read this.');\n   375â†’      console.log('Gemini API test response:', response);\n   376â†’      return { success: true, response };\n   377â†’    } catch (error) {\n   378â†’      console.error('Gemini API test failed:', error);\n   379â†’      return { success: false, error: error.message };\n   380â†’    }\n   381â†’  }\n   382â†’}\n   383â†’\n   384â†’module.exports = new GeminiService();\n   385â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"90cd6a18-eebf-47b1-833f-ec2cb8032550","timestamp":"2025-12-03T07:33:56.249Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\services\\geminiService.js","content":"const { GoogleGenerativeAI } = require('@google/generative-ai');\n\nclass GeminiService {\n  constructor() {\n    console.log('\\nğŸ”§ Initializing Gemini Service...');\n    this.apiKey = process.env.GEMINI_API_KEY;\n\n    if (!this.apiKey) {\n      console.error('âŒ CRITICAL: GEMINI_API_KEY not found in environment variables!');\n      console.error('   Please check your .env file');\n    } else {\n      console.log('âœ… Gemini API Key found');\n      console.log('   Key length:', this.apiKey.length);\n      console.log('   Key preview:', `${this.apiKey.substring(0, 15)}...`);\n    }\n\n    this.genAI = this.apiKey ? new GoogleGenerativeAI(this.apiKey) : null;\n    this.model = null;\n    console.log('âœ… Gemini Service initialized\\n');\n  }\n\n  /**\n   * Fetch available Gemini models\n   */\n  async fetchAvailableModels() {\n    try {\n      console.log('ğŸ” Fetching available Gemini models for PDF generation...');\n\n      const response = await fetch(\n        `https://generativelanguage.googleapis.com/v1/models?key=${this.apiKey}`\n      );\n\n      if (!response.ok) {\n        throw new Error(`API returned ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n\n      const supportedModels = (data.models || []).filter(model =>\n        model.supportedGenerationMethods?.includes('generateContent')\n      );\n\n      console.log(`âœ… Found ${supportedModels.length} models for PDF generation`);\n      return supportedModels;\n    } catch (error) {\n      console.error('âŒ Failed to fetch models:', error.message);\n      return [];\n    }\n  }\n\n  /**\n   * Select best model for PDF generation\n   */\n  selectBestModel(models) {\n    if (!models || models.length === 0) return null;\n\n    // Prefer flash models for speed\n    const preferences = ['flash', 'pro'];\n\n    for (const preference of preferences) {\n      const found = models.find(m =>\n        m.name.toLowerCase().includes(preference)\n      );\n      if (found) {\n        console.log(`âœ… Selected model for PDF: ${found.name}`);\n        return found.name;\n      }\n    }\n\n    console.log(`âœ… Using first available model: ${models[0].name}`);\n    return models[0].name;\n  }\n\n  /**\n   * Initialize the Gemini model\n   */\n  async initModel() {\n    if (!this.genAI) {\n      throw new Error('Gemini API not initialized. Please check GEMINI_API_KEY.');\n    }\n\n    console.log('ğŸ”§ Initializing Gemini model for PDF generation...');\n    console.log('ğŸ”‘ API Key status:', this.apiKey ? 'Present' : 'MISSING');\n\n    // Fetch available models dynamically\n    const availableModels = await this.fetchAvailableModels();\n\n    if (availableModels.length === 0) {\n      console.error('\\nâŒ No models available for PDF generation!');\n      console.error('Please check your GEMINI_API_KEY at https://aistudio.google.com/apikey\\n');\n      throw new Error('No Gemini models available. Check your API key.');\n    }\n\n    // Select best model\n    const modelName = this.selectBestModel(availableModels);\n\n    if (!modelName) {\n      throw new Error('Could not select a valid model for PDF generation');\n    }\n\n    // Initialize model with full path\n    console.log(`ğŸ”§ Initializing model: ${modelName}`);\n    this.model = this.genAI.getGenerativeModel({ model: modelName });\n\n    // Test the model\n    console.log('ğŸ“ Testing model...');\n    try {\n      const testResult = await this.model.generateContent('Hello');\n      const testResponse = await testResult.response;\n      testResponse.text();\n      console.log('âœ… Model initialized and tested successfully for PDF generation');\n    } catch (testError) {\n      console.error(`âŒ Model test failed:`, testError.message);\n      throw new Error(`Failed to test model ${modelName}: ${testError.message}`);\n    }\n\n    return this.model;\n  }\n\n  /**\n   * System prompt for brain performance report generation\n   */\n  getReportGenerationPrompt() {\n    return `You are an expert neuroscience report generator powered by AI. Your task is to create a comprehensive, visually appealing, and easy-to-understand brain performance infographic report for patients.\n\nğŸ¯ YOUR ROLE:\nGenerate a professional single-page A4 infographic-style brain health report based on QEEG (Quantitative Electroencephalography) analysis results. The report must be informative yet accessible to non-medical readers.\n\nğŸ“Š INPUT DATA:\nYou will receive 7 brain performance parameters with their scores, classifications, and sub-metrics:\n1. **Cognition** - Mental processing, focus ability, and alpha-theta balance\n2. **Stress** - Arousal levels, relaxation capacity, and regeneration ability\n3. **Focus & Attention** - Concentration ability, theta levels, and mental alertness\n4. **Burnout & Fatigue** - Energy levels, exhaustion markers, and delta wave patterns\n5. **Emotional Regulation** - Mood stability, frontal alpha asymmetry, and emotional control\n6. **Learning** - Cognitive flexibility, memory formation, and neural plasticity\n7. **Creativity** - Divergent thinking, relaxation state, and innovative capacity\n\nğŸ“‹ SCORING SYSTEM:\n- Each parameter is scored from 0-3 points\n- Classification: Low (0-1), Medium (2), High (3)\n- Sub-metrics contribute individual points to the total score\n- **Special Note**: For Stress and Burnout parameters, LOWER scores are BETTER (0/3 = Healthy, 3/3 = High Problem)\n\nğŸ¨ INFOGRAPHIC REPORT REQUIREMENTS:\n\n1. **Visual Design**:\n   - Modern, clean, and colorful layout\n   - Use vibrant but professional colors\n   - Each parameter should have a distinct visual identity\n   - Icons and graphical elements for each brain function\n   - Color-coded scoring system (Green = Optimal, Yellow = Moderate, Red = Needs Attention)\n\n2. **Content Structure**:\n   - Patient-friendly language (avoid heavy medical jargon)\n   - One-line impactful summary for each parameter\n   - Clear explanation of what each metric means in daily life\n   - Practical interpretation of scores\n   - Holistic overall summary\n\n3. **Parameter Presentation**:\n   - Parameter name in bold, large font\n   - Score displayed prominently (e.g., \"2/3 - Medium\")\n   - Color-coded badge/banner based on classification\n   - List all sub-metrics with checkmarks (âœ“) or crosses (âœ—)\n   - Simple explanation of what each sub-metric indicates\n\n4. **Color Coding Guidelines**:\n   For HEALTH parameters (Cognition, Focus, Emotional Regulation, Learning, Creativity):\n   - High (3/3): #38A169 (Green) - Excellent performance\n   - Medium (2/3): #F59E0B (Amber) - Good, room for improvement\n   - Low (0-1/3): #E53E3E (Red) - Needs attention\n\n   For PROBLEM parameters (Stress, Burnout):\n   - Low (0/3): #38A169 (Green) - Healthy, no issues\n   - Medium (1-2/3): #F59E0B (Amber) - Moderate concern\n   - High (3/3): #E53E3E (Red) - High concern\n\n5. **Interpretations Guidelines**:\n   - Explain what HIGH scores mean for each parameter\n   - Explain what LOW scores mean\n   - Connect brain metrics to real-life implications\n   - Examples:\n     * \"High Focus & Attention (3/3): Your brain shows excellent concentration ability and minimal distracting theta activity\"\n     * \"Low Stress (0/3): Great news! Your brain shows healthy relaxation patterns and low arousal\"\n     * \"Medium Cognition (2/3): Good cognitive function with room for optimization in alpha-theta balance\"\n\n6. **Sub-Metrics Explanation Examples**:\n   - \"Focus Score (Theta:Beta Ratio): âœ“ Optimal - Your frontal brain regions show balanced activity for sustained attention\"\n   - \"Relaxation Score: âœ— Below threshold - Your brain may have difficulty shifting into relaxed states\"\n   - \"Alpha Peak: âœ“ Normal - Healthy alpha rhythm frequency indicates good brain maturation\"\n\n7. **Overall Summary Requirements**:\n   - Synthesize all 7 parameters into a cohesive narrative\n   - Highlight strengths and areas for improvement\n   - Provide context about what the overall pattern suggests\n   - Maintain encouraging and constructive tone\n   - 3-5 sentences maximum\n\n8. **Recommendations**:\n   - Provide 4-6 actionable, personalized recommendations\n   - Base suggestions on the actual scores received\n   - Include lifestyle, cognitive training, or mindfulness suggestions\n   - Keep recommendations practical and achievable\n\nğŸ“¤ OUTPUT FORMAT:\n\nReturn ONLY a valid JSON object (no markdown, no code blocks, no explanations) with this EXACT structure:\n\n{\n  \"title\": \"Brain Performance Analysis Report\",\n  \"patientSummary\": \"A comprehensive 3-5 sentence summary synthesizing all parameters, highlighting key strengths and areas for growth, with an encouraging tone\",\n  \"parameters\": [\n    {\n      \"name\": \"Cognition\",\n      \"score\": 2,\n      \"maxScore\": 3,\n      \"bucket\": \"Medium\",\n      \"bucketColor\": \"#F59E0B\",\n      \"icon\": \"ğŸ§ \",\n      \"summary\": \"One impactful sentence summarizing this parameter's meaning and result\",\n      \"subparameters\": [\n        {\n          \"name\": \"Focus Score (Theta:Beta Ratio)\",\n          \"score\": 1,\n          \"interpretation\": \"Clear explanation of what this score means in daily life\",\n          \"details\": \"Technical detail if helpful: actual value and threshold\"\n        }\n      ]\n    }\n  ],\n  \"recommendations\": [\n    \"Specific actionable recommendation based on the actual scores\",\n    \"Another personalized suggestion\",\n    \"Lifestyle tip relevant to the results\",\n    \"Cognitive exercise or mindfulness practice if applicable\"\n  ],\n  \"layoutSuggestions\": {\n    \"colorScheme\": \"Professional palette: Deep blue header (#323956), parameter colors as specified, white background (#FFFFFF)\",\n    \"structure\": \"Grid layout: 2 columns for parameters, header with title and patient info, summary and recommendations at bottom\"\n  }\n}\n\nğŸš¨ CRITICAL REQUIREMENTS:\n1. Return PURE JSON only - no ```json```, no markdown, no extra text\n2. Include ALL subparameters from input data - don't skip any\n3. Use the EXACT maxScore value from input (always 3 for these parameters)\n4. Remember: For Stress and Burnout, LOW scores are GOOD, HIGH scores are CONCERNING\n5. Each subparameter must have a score (0 or 1), interpretation, and optional details\n6. Icons should be brain-related emojis: ğŸ§  ğŸ’¡ ğŸ¯ âš¡ ğŸ˜Œ ğŸ“š ğŸ¨ or similar\n7. Make interpretations relatable - focus on real-world meaning, not just EEG jargon\n8. Ensure bucketColor uses valid hex codes\n9. Overall tone: Professional yet warm, informative yet encouraging\n\nâœ¨ QUALITY CHECKLIST:\n- Are all 7 parameters included?\n- Do all parameters have their sub-metrics listed?\n- Are interpretations written in simple, patient-friendly language?\n- Is the color coding correct (especially for Stress/Burnout inverse scoring)?\n- Does the summary provide a holistic view?\n- Are recommendations specific and actionable?\n\nGenerate the report now based on the brain parameters data provided below.`;\n  }\n\n  /**\n   * Generate brain performance report using Gemini AI\n   * @param {Object} brainParameters - The 7 brain parameters with scores and buckets\n   * @returns {Promise<Object>} Generated report structure\n   */\n  async generateBrainPerformanceReport(brainParameters) {\n    try {\n      console.log('\\nğŸ”‘ Checking Gemini API configuration...');\n      console.log('   API Key exists:', !!this.apiKey);\n      console.log('   API Key length:', this.apiKey ? this.apiKey.length : 0);\n      console.log('   API Key preview:', this.apiKey ? `${this.apiKey.substring(0, 10)}...` : 'MISSING');\n\n      if (!this.model) {\n        console.log('ğŸ“± Initializing Gemini model...');\n        await this.initModel();\n      }\n\n      console.log('ğŸ¤– Generating brain performance report with Gemini AI...');\n      console.log('ğŸ“Š Input parameters count:', Object.keys(brainParameters).length);\n\n      // Create the prompt with system instructions and data\n      const systemPrompt = this.getReportGenerationPrompt();\n      const dataPrompt = `\\n\\nBrain Parameters Data:\\n${JSON.stringify(brainParameters, null, 2)}\\n\\nPlease generate the infographic report description in JSON format as specified.`;\n\n      const fullPrompt = systemPrompt + dataPrompt;\n      console.log('ğŸ“ Prompt length:', fullPrompt.length, 'characters');\n\n      // Generate content\n      console.log('â³ Calling Gemini API...');\n      const result = await this.model.generateContent(fullPrompt);\n      const response = await result.response;\n      const text = response.text();\n\n      console.log('âœ… Gemini response received!');\n      console.log('   Response length:', text.length, 'characters');\n\n      // Try to parse JSON from the response\n      let reportData;\n      try {\n        // Remove markdown code blocks if present\n        const jsonText = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n        reportData = JSON.parse(jsonText);\n      } catch (parseError) {\n        console.error('Failed to parse JSON response:', parseError);\n        // Return raw text if JSON parsing fails\n        reportData = {\n          title: 'Brain Performance Report',\n          rawContent: text,\n          parameters: [],\n          error: 'Failed to parse structured response'\n        };\n      }\n\n      return {\n        success: true,\n        data: reportData,\n        rawResponse: text\n      };\n\n    } catch (error) {\n      console.error('\\nâŒ === GEMINI API ERROR ===');\n      console.error('Error Type:', error.constructor.name);\n      console.error('Error Message:', error.message);\n      console.error('Error Code:', error.code || 'N/A');\n      console.error('Error Status:', error.status || 'N/A');\n      console.error('Full Error:', JSON.stringify(error, null, 2));\n      console.error('Stack:', error.stack);\n      console.error('==========================\\n');\n\n      return {\n        success: false,\n        error: error.message,\n        errorDetails: {\n          type: error.constructor.name,\n          code: error.code,\n          status: error.status\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Generate simple text completion\n   * @param {string} prompt - The prompt text\n   * @returns {Promise<string>} Generated text\n   */\n  async generateText(prompt) {\n    try {\n      if (!this.model) {\n        await this.initModel();\n      }\n\n      const result = await this.model.generateContent(prompt);\n      const response = await result.response;\n      return response.text();\n\n    } catch (error) {\n      console.error('Error generating text with Gemini:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test Gemini API connection\n   */\n  async testConnection() {\n    try {\n      const response = await this.generateText('Hello! Please respond with \"OK\" if you can read this.');\n      console.log('Gemini API test response:', response);\n      return { success: true, response };\n    } catch (error) {\n      console.error('Gemini API test failed:', error);\n      return { success: false, error: error.message };\n    }\n  }\n}\n\nmodule.exports = new GeminiService();\n","numLines":385,"startLine":1,"totalLines":385}}}
{"parentUuid":"90cd6a18-eebf-47b1-833f-ec2cb8032550","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LzV3c3pyyKKCnXUioKUbvf","type":"tool_result","content":"     1â†’const fs = require('fs');\n     2â†’const path = require('path');\n     3â†’const { GoogleGenerativeAI } = require('@google/generative-ai');\n     4â†’const pdfParse = require('pdf-parse');\n     5â†’const XLSX = require('xlsx');\n     6â†’\n     7â†’// Initialize Gemini AI client\n     8â†’const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);\n     9â†’let geminiModel = null;\n    10â†’\n    11â†’class QEEGParser {\n    12â†’  /**\n    13â†’   * Fetch available Gemini models that support generateContent\n    14â†’   * @returns {Promise<Array>} List of available models\n    15â†’   */\n    16â†’  static async fetchAvailableModels() {\n    17â†’    try {\n    18â†’      console.log('ğŸ” Fetching available Gemini models...');\n    19â†’\n    20â†’      const response = await fetch(\n    21â†’        `https://generativelanguage.googleapis.com/v1/models?key=${process.env.GEMINI_API_KEY}`\n    22â†’      );\n    23â†’\n    24â†’      if (!response.ok) {\n    25â†’        throw new Error(`API returned ${response.status}: ${response.statusText}`);\n    26â†’      }\n    27â†’\n    28â†’      const data = await response.json();\n    29â†’\n    30â†’      // Filter models that support generateContent\n    31â†’      const supportedModels = (data.models || []).filter(model =>\n    32â†’        model.supportedGenerationMethods?.includes('generateContent')\n    33â†’      );\n    34â†’\n    35â†’      console.log(`âœ… Found ${supportedModels.length} models that support generateContent:`);\n    36â†’      supportedModels.forEach(model => {\n    37â†’        console.log(`   - ${model.name}`);\n    38â†’      });\n    39â†’\n    40â†’      return supportedModels;\n    41â†’    } catch (error) {\n    42â†’      console.error('âŒ Failed to fetch models:', error.message);\n    43â†’      return [];\n    44â†’    }\n    45â†’  }\n    46â†’\n    47â†’  /**\n    48â†’   * Select best available model from list\n    49â†’   * @param {Array} models - List of available models\n    50â†’   * @returns {string|null} Model name to use\n    51â†’   */\n    52â†’  static selectBestModel(models) {\n    53â†’    if (!models || models.length === 0) return null;\n    54â†’\n    55â†’    // Priority: flash models (fastest) > pro models > any other\n    56â†’    const preferences = ['flash', 'pro'];\n    57â†’\n    58â†’    for (const preference of preferences) {\n    59â†’      const found = models.find(m =>\n    60â†’        m.name.toLowerCase().includes(preference)\n    61â†’      );\n    62â†’      if (found) {\n    63â†’        console.log(`âœ… Selected model: ${found.name}`);\n    64â†’        return found.name;\n    65â†’      }\n    66â†’    }\n    67â†’\n    68â†’    // Fallback to first available\n    69â†’    console.log(`âœ… Using first available model: ${models[0].name}`);\n    70â†’    return models[0].name;\n    71â†’  }\n    72â†’\n    73â†’  /**\n    74â†’   * Validate Gemini API key is configured and appears valid\n    75â†’   * @throws {Error} if API key is missing or invalid format\n    76â†’   */\n    77â†’  static validateAPIKey() {\n    78â†’    const apiKey = process.env.GEMINI_API_KEY;\n    79â†’\n    80â†’    // Check if key exists\n    81â†’    if (!apiKey || apiKey.trim() === '') {\n    82â†’      const error = new Error('GEMINI_API_KEY environment variable is not set');\n    83â†’      error.code = 'MISSING_API_KEY';\n    84â†’      throw error;\n    85â†’    }\n    86â†’\n    87â†’    // Check if key is placeholder\n    88â†’    if (apiKey === 'your-gemini-api-key-here' || apiKey.includes('placeholder')) {\n    89â†’      const error = new Error('GEMINI_API_KEY is set to placeholder value. Please configure a valid Gemini API key.');\n    90â†’      error.code = 'INVALID_API_KEY';\n    91â†’      throw error;\n    92â†’    }\n    93â†’\n    94â†’    console.log('âœ… Gemini API key validation passed');\n    95â†’    return true;\n    96â†’  }\n    97â†’\n    98â†’  /**\n    99â†’   * Test Gemini API connection with a simple request\n   100â†’   * @returns {Promise<boolean>} true if connection successful\n   101â†’   * @throws {Error} if connection fails\n   102â†’   */\n   103â†’  static async testAPIConnection() {\n   104â†’    try {\n   105â†’      this.validateAPIKey();\n   106â†’\n   107â†’      console.log('ğŸ”Œ Testing Gemini API connection...');\n   108â†’\n   109â†’      if (!geminiModel) {\n   110â†’        console.log('ğŸ”‘ API Key check:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');\n   111â†’\n   112â†’        // Fetch available models dynamically\n   113â†’        const availableModels = await this.fetchAvailableModels();\n   114â†’\n   115â†’        if (availableModels.length === 0) {\n   116â†’          throw new Error('No Gemini models available. Check your API key at https://aistudio.google.com/apikey');\n   117â†’        }\n   118â†’\n   119â†’        // Select best model\n   120â†’        const modelName = this.selectBestModel(availableModels);\n   121â†’\n   122â†’        if (!modelName) {\n   123â†’          throw new Error('Could not select a valid model');\n   124â†’        }\n   125â†’\n   126â†’        // Initialize model with full path\n   127â†’        console.log(`ğŸ”§ Initializing model: ${modelName}`);\n   128â†’        geminiModel = genAI.getGenerativeModel({ model: modelName });\n   129â†’\n   130â†’        // Test it with simple call\n   131â†’        console.log('ğŸ“ Testing model with simple call...');\n   132â†’        const testResult = await geminiModel.generateContent('Hello');\n   133â†’        await testResult.response;\n   134â†’        console.log('âœ… Model initialized and tested successfully');\n   135â†’      }\n   136â†’\n   137â†’      const result = await geminiModel.generateContent('Reply with OK');\n   138â†’      const response = await result.response;\n   139â†’      const text = response.text();\n   140â†’\n   141â†’      if (text) {\n   142â†’        console.log('âœ… Gemini API connection successful');\n   143â†’        return true;\n   144â†’      } else {\n   145â†’        throw new Error('Gemini API returned unexpected response');\n   146â†’      }\n   147â†’\n   148â†’    } catch (error) {\n   149â†’      console.error('âŒ Gemini API connection test failed:', error.message);\n   150â†’      const enhancedError = new Error(`Gemini API connection test failed: ${error.message}`);\n   151â†’      enhancedError.code = 'API_CONNECTION_FAILED';\n   152â†’      enhancedError.originalError = error;\n   153â†’      throw enhancedError;\n   154â†’    }\n   155â†’  }\n   156â†’\n   157â†’  /**\n   158â†’   * Detect report type (raw power values or Z-scores)\n   159â†’   * @param {Object} file - Multer file object\n   160â†’   * @returns {Promise<string>} 'raw' or 'zscore'\n   161â†’   */\n   162â†’  static async detectReportType(file) {\n   163â†’    try {\n   164â†’      console.log(`ğŸ” Detecting report type for: ${file.originalname}`);\n   165â†’\n   166â†’      const dataBuffer = fs.readFileSync(file.path);\n   167â†’      const pdfData = await pdfParse(dataBuffer);\n   168â†’      const text = pdfData.text.toLowerCase();\n   169â†’\n   170â†’      // Keyword detection\n   171â†’      const zscoreKeywords = ['z-score', 'z score', 'z =', 'z=', 'standard deviation', 'sd from mean'];\n   172â†’      const rawKeywords = ['absolute power (Î¼vÂ²)', 'absolute power (uvÂ²)', 'relative power (%)', 'Î¼vÂ²', 'uvÂ²'];\n   173â†’\n   174â†’      let zscoreCount = 0;\n   175â†’      let rawCount = 0;\n   176â†’\n   177â†’      // Count keyword occurrences\n   178â†’      zscoreKeywords.forEach(keyword => {\n   179â†’        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;\n   180â†’        zscoreCount += matches;\n   181â†’      });\n   182â†’\n   183â†’      rawKeywords.forEach(keyword => {\n   184â†’        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;\n   185â†’        rawCount += matches;\n   186â†’      });\n   187â†’\n   188â†’      console.log(`   Z-score keywords found: ${zscoreCount}`);\n   189â†’      console.log(`   Raw power keywords found: ${rawCount}`);\n   190â†’\n   191â†’      // Decision logic\n   192â†’      if (zscoreCount > rawCount && zscoreCount >= 3) {\n   193â†’        console.log(`âœ… Detected: Z-SCORE report`);\n   194â†’        return 'zscore';\n   195â†’      } else if (rawCount > zscoreCount && rawCount >= 2) {\n   196â†’        console.log(`âœ… Detected: RAW POWER report`);\n   197â†’        return 'raw';\n   198â†’      } else if (zscoreCount > 0 && rawCount > 0) {\n   199â†’        // Mixed report - check for table structure\n   200â†’        if (text.includes('z-score table') || text.includes('z score table')) {\n   201â†’          console.log(`âš ï¸ Mixed report detected - preferring Z-SCORE`);\n   202â†’          return 'zscore';\n   203â†’        } else {\n   204â†’          console.log(`âš ï¸ Mixed report detected - preferring RAW POWER`);\n   205â†’          return 'raw';\n   206â†’        }\n   207â†’      } else {\n   208â†’        // Fallback: assume raw if unclear\n   209â†’        console.warn(`âš ï¸ Could not clearly detect report type - defaulting to RAW POWER`);\n   210â†’        return 'raw';\n   211â†’      }\n   212â†’\n   213â†’    } catch (error) {\n   214â†’      console.error(`âŒ Error detecting report type for ${file.originalname}:`, error.message);\n   215â†’      // Safe default\n   216â†’      console.warn(`   Defaulting to RAW POWER mode`);\n   217â†’      return 'raw';\n   218â†’    }\n   219â†’  }\n   220â†’\n   221â†’  /**\n   222â†’   * Main method to parse uploaded files\n   223â†’   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data\n   224â†’   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data\n   225â†’   * @returns {Object} Parsed QEEG data\n   226â†’   */\n   227â†’  static async parse(eyesOpenFile, eyesClosedFile) {\n   228â†’    try {\n   229â†’      console.log('\\nğŸ“„ === QEEG File Parsing Started ===');\n   230â†’      console.log('  - Eyes Open:', eyesOpenFile?.originalname);\n   231â†’      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);\n   232â†’\n   233â†’      // STEP 1: Detect report types\n   234â†’      console.log('\\nğŸ” STEP 1: Detecting report types...');\n   235â†’      const eoReportType = await this.detectReportType(eyesOpenFile);\n   236â†’      const ecReportType = await this.detectReportType(eyesClosedFile);\n   237â†’\n   238â†’      console.log(`\\nğŸ“Š Detection Results:`);\n   239â†’      console.log(`  - Eyes Open: ${eoReportType.toUpperCase()}`);\n   240â†’      console.log(`  - Eyes Closed: ${ecReportType.toUpperCase()}`);\n   241â†’\n   242â†’      // STEP 2: Validate matching types\n   243â†’      console.log('\\nâœ“ STEP 2: Validating report type consistency...');\n   244â†’      if (eoReportType !== ecReportType) {\n   245â†’        const error = new Error(\n   246â†’          `âŒ Mismatched report types detected!\\n\\n` +\n   247â†’          `Eyes Open is ${eoReportType.toUpperCase()}, but Eyes Closed is ${ecReportType.toUpperCase()}.\\n\\n` +\n   248â†’          `Both files must be the same type (either both RAW POWER or both Z-SCORE reports).\\n` +\n   249â†’          `Please upload matching report types and try again.`\n   250â†’        );\n   251â†’        error.code = 'REPORT_TYPE_MISMATCH';\n   252â†’        throw error;\n   253â†’      }\n   254â†’\n   255â†’      const reportType = eoReportType;\n   256â†’      console.log(`âœ… Report type validated: ${reportType.toUpperCase()} mode\\n`);\n   257â†’\n   258â†’      // STEP 3: Determine file formats (pdf, csv, excel)\n   259â†’      console.log('ğŸ“ STEP 3: Determining file formats...');\n   260â†’      const eoFileType = this.getFileType(eyesOpenFile.originalname);\n   261â†’      const ecFileType = this.getFileType(eyesClosedFile.originalname);\n   262â†’      console.log(`  - Eyes Open: ${eoFileType}`);\n   263â†’      console.log(`  - Eyes Closed: ${ecFileType}\\n`);\n   264â†’\n   265â†’      // STEP 4: Parse each file with appropriate method\n   266â†’      console.log('ğŸ“– STEP 4: Extracting data from files...');\n   267â†’      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO', reportType);\n   268â†’      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC', reportType);\n   269â†’\n   270â†’      // STEP 5: Combine data with metadata\n   271â†’      console.log('\\nğŸ”— STEP 5: Combining data...');\n   272â†’      const combinedData = {\n   273â†’        EO: eyesOpenData,\n   274â†’        EC: eyesClosedData,\n   275â†’        dataType: reportType // Add metadata\n   276â†’      };\n   277â†’\n   278â†’      console.log(`âœ… QEEG files parsed successfully in ${reportType.toUpperCase()} mode`);\n   279â†’      console.log('=== QEEG File Parsing Completed ===\\n');\n   280â†’      return combinedData;\n   281â†’\n   282â†’    } catch (error) {\n   283â†’      console.error('\\nâŒ === QEEG File Parsing Failed ===');\n   284â†’      console.error('Error:', error.message);\n   285â†’      if (error.code === 'REPORT_TYPE_MISMATCH') {\n   286â†’        // Re-throw mismatch errors with original message\n   287â†’        throw error;\n   288â†’      } else {\n   289â†’        throw new Error(`Failed to parse QEEG files: ${error.message}`);\n   290â†’      }\n   291â†’    }\n   292â†’  }\n   293â†’\n   294â†’  /**\n   295â†’   * Determine file type from filename\n   296â†’   */\n   297â†’  static getFileType(filename) {\n   298â†’    const ext = path.extname(filename).toLowerCase();\n   299â†’    if (ext === '.pdf') return 'pdf';\n   300â†’    if (ext === '.csv') return 'csv';\n   301â†’    if (ext === '.xlsx' || ext === '.xls') return 'excel';\n   302â†’    throw new Error(`Unsupported file type: ${ext}`);\n   303â†’  }\n   304â†’\n   305â†’  /**\n   306â†’   * Parse a single file based on its type\n   307â†’   */\n   308â†’  static async parseFile(file, fileType, condition, reportType = 'raw') {\n   309â†’    if (fileType === 'pdf') {\n   310â†’      return await this.parsePDF(file, condition, reportType);\n   311â†’    } else if (fileType === 'csv') {\n   312â†’      return this.parseCSV(file);\n   313â†’    } else if (fileType === 'excel') {\n   314â†’      return this.parseExcel(file);\n   315â†’    }\n   316â†’    throw new Error(`Unknown file type: ${fileType}`);\n   317â†’  }\n   318â†’\n   319â†’  /**\n   320â†’   * Get extraction prompt based on report type\n   321â†’   * @param {string} condition - 'EO' or 'EC'\n   322â†’   * @param {string} reportType - 'raw' or 'zscore'\n   323â†’   * @param {string} pdfText - PDF text content\n   324â†’   * @returns {string} Extraction prompt\n   325â†’   */\n   326â†’  static getExtractionPrompt(condition, reportType, pdfText) {\n   327â†’    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';\n   328â†’\n   329â†’    if (reportType === 'zscore') {\n   330â†’      // Z-SCORE extraction prompt\n   331â†’      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.\n   332â†’\n   333â†’**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.\n   334â†’- Negative values = below average (lower than normal)\n   335â†’- Zero (0) = average (normal)\n   336â†’- Positive values = above average (higher than normal)\n   337â†’\n   338â†’Look for tables labeled with \"Z-score\", \"Z score\", \"Z\", or \"Standard Deviation\" in the headers.\n   339â†’\n   340â†’Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2\n   341â†’\n   342â†’For each channel, extract Z-scores for these frequency bands:\n   343â†’- Delta (1-4 Hz)\n   344â†’- Theta (4-8 Hz)\n   345â†’- Alpha (8-13 Hz)\n   346â†’- Beta (13-30 Hz)\n   347â†’- HiBeta / High Beta (20-30 Hz)\n   348â†’\n   349â†’Also extract:\n   350â†’- Alpha Peak Frequency (Hz) and its Z-score if available\n   351â†’\n   352â†’If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.\n   353â†’\n   354â†’**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:\n   355â†’- No markdown formatting (no \\`\\`\\`json or \\`\\`\\`)\n   356â†’- No explanations before or after\n   357â†’- No comments\n   358â†’- Just pure JSON that starts with { and ends with }\n   359â†’\n   360â†’Return ONLY this EXACT JSON format:\n   361â†’{\n   362â†’  \"zscores\": {\n   363â†’    \"absolute\": {\n   364â†’      \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   365â†’      \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   366â†’      \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   367â†’      \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   368â†’      \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   369â†’      \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   370â†’      \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   371â†’      \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   372â†’      \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n   373â†’    },\n   374â†’    \"relative\": {\n   375â†’      \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   376â†’      \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   377â†’      \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   378â†’      \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   379â†’      \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   380â†’      \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   381â†’      \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   382â†’      \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   383â†’      \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n   384â†’    }\n   385â†’  },\n   386â†’  \"special\": {\n   387â†’    \"alphaPeak\": 10.0,\n   388â†’    \"alphaPeakZscore\": 0.0\n   389â†’  }\n   390â†’}\n   391â†’\n   392â†’PDF Content:\n   393â†’${pdfText.substring(0, 15000)}`;\n   394â†’\n   395â†’    } else {\n   396â†’      // RAW POWER extraction prompt (existing)\n   397â†’      return `You are a QEEG data extraction expert. Extract the following data from this ${conditionName} QEEG report:\n   398â†’\n   399â†’Extract two tables:\n   400â†’1. **Absolute Power (Î¼VÂ²)** table\n   401â†’2. **Relative Power (%)** table\n   402â†’\n   403â†’For each table, extract values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2\n   404â†’\n   405â†’For each channel, extract values for these frequency bands:\n   406â†’- Delta\n   407â†’- Theta\n   408â†’- Alpha\n   409â†’- Beta\n   410â†’- HiBeta (High Beta)\n   411â†’\n   412â†’Also extract Alpha Peak Frequency (APF) if available.\n   413â†’\n   414â†’**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:\n   415â†’- No markdown formatting (no \\`\\`\\`json or \\`\\`\\`)\n   416â†’- No explanations before or after\n   417â†’- No comments\n   418â†’- Just pure JSON that starts with { and ends with }\n   419â†’\n   420â†’Return the data in this EXACT JSON format:\n   421â†’{\n   422â†’  \"absolute\": {\n   423â†’    \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   424â†’    \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   425â†’    \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   426â†’    \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   427â†’    \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   428â†’    \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   429â†’    \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   430â†’    \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   431â†’    \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n   432â†’  },\n   433â†’  \"relative\": {\n   434â†’    \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   435â†’    \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   436â†’    \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   437â†’    \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   438â†’    \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   439â†’    \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   440â†’    \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   441â†’    \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n   442â†’    \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n   443â†’  },\n   444â†’  \"special\": {\n   445â†’    \"alphaPeak\": 10.0,\n   446â†’    \"O1\": 10.0\n   447â†’  }\n   448â†’}\n   449â†’\n   450â†’PDF Content:\n   451â†’${pdfText.substring(0, 15000)}`;\n   452â†’    }\n   453â†’  }\n   454â†’\n   455â†’  /**\n   456â†’   * Parse PDF file using Gemini AI\n   457â†’   * @param {Object} file - Multer file object\n   458â†’   * @param {string} condition - 'EO' or 'EC'\n   459â†’   * @param {string} reportType - 'raw' or 'zscore'\n   460â†’   */\n   461â†’  static async parsePDF(file, condition, reportType = 'raw') {\n   462â†’    console.log(`  ğŸ” Parsing PDF with Gemini AI (${condition}, ${reportType.toUpperCase()} mode)...`);\n   463â†’\n   464â†’    try {\n   465â†’      // Validate API key before attempting to use it\n   466â†’      this.validateAPIKey();\n   467â†’\n   468â†’\n   469â†’      // Read PDF file\n   470â†’      const dataBuffer = fs.readFileSync(file.path);\n   471â†’      const pdfData = await pdfParse(dataBuffer);\n   472â†’\n   473â†’      // Extract text from PDF\n   474â†’      const pdfText = pdfData.text;\n   475â†’\n   476â†’      // Get appropriate extraction prompt based on report type\n   477â†’      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);\n   478â†’\n   479â†’      // Initialize Gemini model if not already done\n   480â†’      if (!geminiModel) {\n   481â†’        console.log('  ğŸ”§ Initializing Gemini model for data extraction...');\n   482â†’        console.log('  ğŸ”‘ API Key status:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');\n   483â†’        console.log('  ğŸ”‘ API Key length:', process.env.GEMINI_API_KEY?.length || 0);\n   484â†’        console.log('  ğŸ”‘ API Key preview:', process.env.GEMINI_API_KEY ? `${process.env.GEMINI_API_KEY.substring(0, 20)}...` : 'N/A');\n   485â†’\n   486â†’        // Fetch available models dynamically\n   487â†’        const availableModels = await this.fetchAvailableModels();\n   488â†’\n   489â†’        if (availableModels.length === 0) {\n   490â†’          console.error('\\n  âŒ === NO MODELS AVAILABLE ===');\n   491â†’          console.error('  Please check:');\n   492â†’          console.error('  1. GEMINI_API_KEY is correct in .env file');\n   493â†’          console.error('  2. API key has proper permissions');\n   494â†’          console.error('  3. Visit: https://aistudio.google.com/apikey to get a new key');\n   495â†’          console.error('  4. Make sure Generative Language API is enabled');\n   496â†’          console.error('  ================================\\n');\n   497â†’          throw new Error('No Gemini models available. Check your API key.');\n   498â†’        }\n   499â†’\n   500â†’        // Select best model\n   501â†’        const modelName = this.selectBestModel(availableModels);\n   502â†’\n   503â†’        if (!modelName) {\n   504â†’          throw new Error('Could not select a valid model from available models');\n   505â†’        }\n   506â†’\n   507â†’        // Initialize model with full path\n   508â†’        console.log(`  ğŸ”§ Initializing model: ${modelName}`);\n   509â†’        geminiModel = genAI.getGenerativeModel({ model: modelName });\n   510â†’\n   511â†’        // Test the model with a simple call\n   512â†’        console.log(`  ğŸ“ Testing ${modelName} with simple call...`);\n   513â†’        try {\n   514â†’          const testResult = await geminiModel.generateContent('Hello');\n   515â†’          const testResponse = await testResult.response;\n   516â†’          const testText = testResponse.text();\n   517â†’\n   518â†’          console.log(`  âœ… Model initialized and tested successfully`);\n   519â†’          console.log(`  ğŸ“ Test response: ${testText.substring(0, 50)}...`);\n   520â†’        } catch (testError) {\n   521â†’          console.error(`  âŒ Model test failed:`, testError.message);\n   522â†’          throw new Error(`Failed to test model ${modelName}: ${testError.message}`);\n   523â†’        }\n   524â†’      }\n   525â†’\n   526â†’      console.log(`  ğŸ¤– Using Gemini AI for data extraction (${condition})...`);\n   527â†’\n   528â†’      // Call Gemini API\n   529â†’      const result = await geminiModel.generateContent(prompt);\n   530â†’      const response = await result.response;\n   531â†’      const text = response.text();\n   532â†’\n   533â†’      console.log(`  ğŸ“ Gemini response received (${condition}), length: ${text.length} characters`);\n   534â†’\n   535â†’      // Parse JSON from response (remove markdown code blocks if present)\n   536â†’      let extractedData;\n   537â†’      try {\n   538â†’        const jsonText = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n   539â†’        extractedData = JSON.parse(jsonText);\n   540â†’        console.log(`  âœ… PDF data extracted successfully with Gemini (${condition})`);\n   541â†’      } catch (parseError) {\n   542â†’        console.error(`  âŒ Failed to parse JSON from Gemini response (${condition}):`, parseError.message);\n   543â†’        console.error(`  ğŸ“„ Raw response:`, text.substring(0, 500));\n   544â†’        throw new Error(`Failed to parse JSON from Gemini response: ${parseError.message}`);\n   545â†’      }\n   546â†’\n   547â†’      // Add detailed logging\n   548â†’      console.log(`  ğŸ“Š Data extraction summary (${condition}):`);\n   549â†’      console.log(`     - Absolute power channels: ${Object.keys(extractedData.absolute || {}).length}`);\n   550â†’      console.log(`     - Relative power channels: ${Object.keys(extractedData.relative || {}).length}`);\n   551â†’      console.log(`     - Special values: ${JSON.stringify(extractedData.special || {})}`);\n   552â†’\n   553â†’      // Log sample extracted values for verification (prove it's real patient data, not static)\n   554â†’      console.log(`\\n  ğŸ“‹ Sample Extracted Values (${condition}) - Proof of Dynamic Extraction:`);\n   555â†’      if (extractedData.absolute?.Fz) {\n   556â†’        console.log(`     - Fz Absolute: Theta=${extractedData.absolute.Fz.Theta}, Beta=${extractedData.absolute.Fz.Beta}`);\n   557â†’      }\n   558â†’      if (extractedData.absolute?.Pz) {\n   559â†’        console.log(`     - Pz Absolute: Alpha=${extractedData.absolute.Pz.Alpha}, HiBeta=${extractedData.absolute.Pz.HiBeta}`);\n   560â†’      }\n   561â†’      if (extractedData.relative?.Pz) {\n   562â†’        console.log(`     - Pz Relative: Alpha=${extractedData.relative.Pz.Alpha}, Beta=${extractedData.relative.Pz.Beta}`);\n   563â†’      }\n   564â†’      if (extractedData.absolute?.F3 && extractedData.absolute?.F4) {\n   565â†’        console.log(`     - F3/F4 Absolute Alpha: F3=${extractedData.absolute.F3.Alpha}, F4=${extractedData.absolute.F4.Alpha}`);\n   566â†’      }\n   567â†’      if (extractedData.special?.alphaPeak) {\n   568â†’        console.log(`     - Alpha Peak Frequency: ${extractedData.special.alphaPeak} Hz`);\n   569â†’      }\n   570â†’\n   571â†’      // Validate extracted data has minimum required fields\n   572â†’      const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];\n   573â†’      const absoluteChannels = Object.keys(extractedData.absolute || {});\n   574â†’      const relativeChannels = Object.keys(extractedData.relative || {});\n   575â†’\n   576â†’      const missingAbsolute = requiredChannels.filter(ch => !absoluteChannels.includes(ch));\n   577â†’      const missingRelative = requiredChannels.filter(ch => !relativeChannels.includes(ch));\n   578â†’\n   579â†’      if (missingAbsolute.length > 0) {\n   580â†’        console.warn(`  âš ï¸  Missing absolute power channels: ${missingAbsolute.join(', ')}`);\n   581â†’      }\n   582â†’      if (missingRelative.length > 0) {\n   583â†’        console.warn(`  âš ï¸  Missing relative power channels: ${missingRelative.join(', ')}`);\n   584â†’      }\n   585â†’\n   586â†’      return extractedData;\n   587â†’\n   588â†’    } catch (error) {\n   589â†’      console.error(`  âŒ Gemini API error (${condition}):`, error.message);\n   590â†’\n   591â†’      // Log more details for debugging\n   592â†’      if (error.response) {\n   593â†’        console.error(`  âŒ Gemini API Status:`, error.response?.status);\n   594â†’        console.error(`  âŒ Gemini API Error:`, error.response?.data);\n   595â†’      }\n   596â†’\n   597â†’      console.error(`  ğŸ“„ Error stack:`, error.stack);\n   598â†’\n   599â†’      // Re-throw with more context\n   600â†’      const enhancedError = new Error(`Failed to extract QEEG data from PDF using Gemini (${condition}): ${error.message}`);\n   601â†’      enhancedError.code = 'PDF_EXTRACTION_FAILED';\n   602â†’      enhancedError.originalError = error;\n   603â†’      enhancedError.condition = condition;\n   604â†’      throw enhancedError;\n   605â†’    }\n   606â†’  }\n   607â†’\n   608â†’  /**\n   609â†’   * Parse CSV file\n   610â†’   */\n   611â†’  static parseCSV(file) {\n   612â†’    console.log('  ğŸ“Š Parsing CSV file...');\n   613â†’\n   614â†’    // Read CSV file\n   615â†’    const workbook = XLSX.readFile(file.path);\n   616â†’    const sheetName = workbook.SheetNames[0];\n   617â†’    const worksheet = workbook.Sheets[sheetName];\n   618â†’    const jsonData = XLSX.utils.sheet_to_json(worksheet);\n   619â†’\n   620â†’    // Convert CSV data to our format\n   621â†’    const data = this.convertCSVToFormat(jsonData);\n   622â†’\n   623â†’    console.log('  âœ… CSV parsed successfully');\n   624â†’    return data;\n   625â†’  }\n   626â†’\n   627â†’  /**\n   628â†’   * Parse Excel file\n   629â†’   */\n   630â†’  static parseExcel(file) {\n   631â†’    console.log('  ğŸ“Š Parsing Excel file...');\n   632â†’\n   633â†’    // Read Excel file\n   634â†’    const workbook = XLSX.readFile(file.path);\n   635â†’    const sheetName = workbook.SheetNames[0];\n   636â†’    const worksheet = workbook.Sheets[sheetName];\n   637â†’    const jsonData = XLSX.utils.sheet_to_json(worksheet);\n   638â†’\n   639â†’    // Convert Excel data to our format\n   640â†’    const data = this.convertExcelToFormat(jsonData);\n   641â†’\n   642â†’    console.log('  âœ… Excel parsed successfully');\n   643â†’    return data;\n   644â†’  }\n   645â†’\n   646â†’  /**\n   647â†’   * Convert CSV data to expected format\n   648â†’   */\n   649â†’  static convertCSVToFormat(csvData) {\n   650â†’    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta\n   651â†’    const result = {\n   652â†’      absolute: {},\n   653â†’      relative: {},\n   654â†’      special: { alphaPeak: 10.0, O1: 10.0 }\n   655â†’    };\n   656â†’\n   657â†’    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];\n   658â†’    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];\n   659â†’\n   660â†’    for (const row of csvData) {\n   661â†’      const channel = row.Channel;\n   662â†’      const powerType = row.PowerType?.toLowerCase();\n   663â†’\n   664â†’      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {\n   665â†’        result[powerType][channel] = {\n   666â†’          Delta: parseFloat(row.Delta) || 0,\n   667â†’          Theta: parseFloat(row.Theta) || 0,\n   668â†’          Alpha: parseFloat(row.Alpha) || 0,\n   669â†’          Beta: parseFloat(row.Beta) || 0,\n   670â†’          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0\n   671â†’        };\n   672â†’      }\n   673â†’    }\n   674â†’\n   675â†’    return result;\n   676â†’  }\n   677â†’\n   678â†’  /**\n   679â†’   * Convert Excel data to expected format (same as CSV for now)\n   680â†’   */\n   681â†’  static convertExcelToFormat(excelData) {\n   682â†’    return this.convertCSVToFormat(excelData);\n   683â†’  }\n   684â†’}\n   685â†’\n   686â†’module.exports = QEEGParser;\n   687â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bc7fc6dc-bf02-4f47-ae0b-619c82c5eaac","timestamp":"2025-12-03T07:34:06.884Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\services\\qeegParser.js","content":"const fs = require('fs');\nconst path = require('path');\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\nconst pdfParse = require('pdf-parse');\nconst XLSX = require('xlsx');\n\n// Initialize Gemini AI client\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);\nlet geminiModel = null;\n\nclass QEEGParser {\n  /**\n   * Fetch available Gemini models that support generateContent\n   * @returns {Promise<Array>} List of available models\n   */\n  static async fetchAvailableModels() {\n    try {\n      console.log('ğŸ” Fetching available Gemini models...');\n\n      const response = await fetch(\n        `https://generativelanguage.googleapis.com/v1/models?key=${process.env.GEMINI_API_KEY}`\n      );\n\n      if (!response.ok) {\n        throw new Error(`API returned ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n\n      // Filter models that support generateContent\n      const supportedModels = (data.models || []).filter(model =>\n        model.supportedGenerationMethods?.includes('generateContent')\n      );\n\n      console.log(`âœ… Found ${supportedModels.length} models that support generateContent:`);\n      supportedModels.forEach(model => {\n        console.log(`   - ${model.name}`);\n      });\n\n      return supportedModels;\n    } catch (error) {\n      console.error('âŒ Failed to fetch models:', error.message);\n      return [];\n    }\n  }\n\n  /**\n   * Select best available model from list\n   * @param {Array} models - List of available models\n   * @returns {string|null} Model name to use\n   */\n  static selectBestModel(models) {\n    if (!models || models.length === 0) return null;\n\n    // Priority: flash models (fastest) > pro models > any other\n    const preferences = ['flash', 'pro'];\n\n    for (const preference of preferences) {\n      const found = models.find(m =>\n        m.name.toLowerCase().includes(preference)\n      );\n      if (found) {\n        console.log(`âœ… Selected model: ${found.name}`);\n        return found.name;\n      }\n    }\n\n    // Fallback to first available\n    console.log(`âœ… Using first available model: ${models[0].name}`);\n    return models[0].name;\n  }\n\n  /**\n   * Validate Gemini API key is configured and appears valid\n   * @throws {Error} if API key is missing or invalid format\n   */\n  static validateAPIKey() {\n    const apiKey = process.env.GEMINI_API_KEY;\n\n    // Check if key exists\n    if (!apiKey || apiKey.trim() === '') {\n      const error = new Error('GEMINI_API_KEY environment variable is not set');\n      error.code = 'MISSING_API_KEY';\n      throw error;\n    }\n\n    // Check if key is placeholder\n    if (apiKey === 'your-gemini-api-key-here' || apiKey.includes('placeholder')) {\n      const error = new Error('GEMINI_API_KEY is set to placeholder value. Please configure a valid Gemini API key.');\n      error.code = 'INVALID_API_KEY';\n      throw error;\n    }\n\n    console.log('âœ… Gemini API key validation passed');\n    return true;\n  }\n\n  /**\n   * Test Gemini API connection with a simple request\n   * @returns {Promise<boolean>} true if connection successful\n   * @throws {Error} if connection fails\n   */\n  static async testAPIConnection() {\n    try {\n      this.validateAPIKey();\n\n      console.log('ğŸ”Œ Testing Gemini API connection...');\n\n      if (!geminiModel) {\n        console.log('ğŸ”‘ API Key check:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');\n\n        // Fetch available models dynamically\n        const availableModels = await this.fetchAvailableModels();\n\n        if (availableModels.length === 0) {\n          throw new Error('No Gemini models available. Check your API key at https://aistudio.google.com/apikey');\n        }\n\n        // Select best model\n        const modelName = this.selectBestModel(availableModels);\n\n        if (!modelName) {\n          throw new Error('Could not select a valid model');\n        }\n\n        // Initialize model with full path\n        console.log(`ğŸ”§ Initializing model: ${modelName}`);\n        geminiModel = genAI.getGenerativeModel({ model: modelName });\n\n        // Test it with simple call\n        console.log('ğŸ“ Testing model with simple call...');\n        const testResult = await geminiModel.generateContent('Hello');\n        await testResult.response;\n        console.log('âœ… Model initialized and tested successfully');\n      }\n\n      const result = await geminiModel.generateContent('Reply with OK');\n      const response = await result.response;\n      const text = response.text();\n\n      if (text) {\n        console.log('âœ… Gemini API connection successful');\n        return true;\n      } else {\n        throw new Error('Gemini API returned unexpected response');\n      }\n\n    } catch (error) {\n      console.error('âŒ Gemini API connection test failed:', error.message);\n      const enhancedError = new Error(`Gemini API connection test failed: ${error.message}`);\n      enhancedError.code = 'API_CONNECTION_FAILED';\n      enhancedError.originalError = error;\n      throw enhancedError;\n    }\n  }\n\n  /**\n   * Detect report type (raw power values or Z-scores)\n   * @param {Object} file - Multer file object\n   * @returns {Promise<string>} 'raw' or 'zscore'\n   */\n  static async detectReportType(file) {\n    try {\n      console.log(`ğŸ” Detecting report type for: ${file.originalname}`);\n\n      const dataBuffer = fs.readFileSync(file.path);\n      const pdfData = await pdfParse(dataBuffer);\n      const text = pdfData.text.toLowerCase();\n\n      // Keyword detection\n      const zscoreKeywords = ['z-score', 'z score', 'z =', 'z=', 'standard deviation', 'sd from mean'];\n      const rawKeywords = ['absolute power (Î¼vÂ²)', 'absolute power (uvÂ²)', 'relative power (%)', 'Î¼vÂ²', 'uvÂ²'];\n\n      let zscoreCount = 0;\n      let rawCount = 0;\n\n      // Count keyword occurrences\n      zscoreKeywords.forEach(keyword => {\n        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;\n        zscoreCount += matches;\n      });\n\n      rawKeywords.forEach(keyword => {\n        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;\n        rawCount += matches;\n      });\n\n      console.log(`   Z-score keywords found: ${zscoreCount}`);\n      console.log(`   Raw power keywords found: ${rawCount}`);\n\n      // Decision logic\n      if (zscoreCount > rawCount && zscoreCount >= 3) {\n        console.log(`âœ… Detected: Z-SCORE report`);\n        return 'zscore';\n      } else if (rawCount > zscoreCount && rawCount >= 2) {\n        console.log(`âœ… Detected: RAW POWER report`);\n        return 'raw';\n      } else if (zscoreCount > 0 && rawCount > 0) {\n        // Mixed report - check for table structure\n        if (text.includes('z-score table') || text.includes('z score table')) {\n          console.log(`âš ï¸ Mixed report detected - preferring Z-SCORE`);\n          return 'zscore';\n        } else {\n          console.log(`âš ï¸ Mixed report detected - preferring RAW POWER`);\n          return 'raw';\n        }\n      } else {\n        // Fallback: assume raw if unclear\n        console.warn(`âš ï¸ Could not clearly detect report type - defaulting to RAW POWER`);\n        return 'raw';\n      }\n\n    } catch (error) {\n      console.error(`âŒ Error detecting report type for ${file.originalname}:`, error.message);\n      // Safe default\n      console.warn(`   Defaulting to RAW POWER mode`);\n      return 'raw';\n    }\n  }\n\n  /**\n   * Main method to parse uploaded files\n   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data\n   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data\n   * @returns {Object} Parsed QEEG data\n   */\n  static async parse(eyesOpenFile, eyesClosedFile) {\n    try {\n      console.log('\\nğŸ“„ === QEEG File Parsing Started ===');\n      console.log('  - Eyes Open:', eyesOpenFile?.originalname);\n      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);\n\n      // STEP 1: Detect report types\n      console.log('\\nğŸ” STEP 1: Detecting report types...');\n      const eoReportType = await this.detectReportType(eyesOpenFile);\n      const ecReportType = await this.detectReportType(eyesClosedFile);\n\n      console.log(`\\nğŸ“Š Detection Results:`);\n      console.log(`  - Eyes Open: ${eoReportType.toUpperCase()}`);\n      console.log(`  - Eyes Closed: ${ecReportType.toUpperCase()}`);\n\n      // STEP 2: Validate matching types\n      console.log('\\nâœ“ STEP 2: Validating report type consistency...');\n      if (eoReportType !== ecReportType) {\n        const error = new Error(\n          `âŒ Mismatched report types detected!\\n\\n` +\n          `Eyes Open is ${eoReportType.toUpperCase()}, but Eyes Closed is ${ecReportType.toUpperCase()}.\\n\\n` +\n          `Both files must be the same type (either both RAW POWER or both Z-SCORE reports).\\n` +\n          `Please upload matching report types and try again.`\n        );\n        error.code = 'REPORT_TYPE_MISMATCH';\n        throw error;\n      }\n\n      const reportType = eoReportType;\n      console.log(`âœ… Report type validated: ${reportType.toUpperCase()} mode\\n`);\n\n      // STEP 3: Determine file formats (pdf, csv, excel)\n      console.log('ğŸ“ STEP 3: Determining file formats...');\n      const eoFileType = this.getFileType(eyesOpenFile.originalname);\n      const ecFileType = this.getFileType(eyesClosedFile.originalname);\n      console.log(`  - Eyes Open: ${eoFileType}`);\n      console.log(`  - Eyes Closed: ${ecFileType}\\n`);\n\n      // STEP 4: Parse each file with appropriate method\n      console.log('ğŸ“– STEP 4: Extracting data from files...');\n      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO', reportType);\n      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC', reportType);\n\n      // STEP 5: Combine data with metadata\n      console.log('\\nğŸ”— STEP 5: Combining data...');\n      const combinedData = {\n        EO: eyesOpenData,\n        EC: eyesClosedData,\n        dataType: reportType // Add metadata\n      };\n\n      console.log(`âœ… QEEG files parsed successfully in ${reportType.toUpperCase()} mode`);\n      console.log('=== QEEG File Parsing Completed ===\\n');\n      return combinedData;\n\n    } catch (error) {\n      console.error('\\nâŒ === QEEG File Parsing Failed ===');\n      console.error('Error:', error.message);\n      if (error.code === 'REPORT_TYPE_MISMATCH') {\n        // Re-throw mismatch errors with original message\n        throw error;\n      } else {\n        throw new Error(`Failed to parse QEEG files: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Determine file type from filename\n   */\n  static getFileType(filename) {\n    const ext = path.extname(filename).toLowerCase();\n    if (ext === '.pdf') return 'pdf';\n    if (ext === '.csv') return 'csv';\n    if (ext === '.xlsx' || ext === '.xls') return 'excel';\n    throw new Error(`Unsupported file type: ${ext}`);\n  }\n\n  /**\n   * Parse a single file based on its type\n   */\n  static async parseFile(file, fileType, condition, reportType = 'raw') {\n    if (fileType === 'pdf') {\n      return await this.parsePDF(file, condition, reportType);\n    } else if (fileType === 'csv') {\n      return this.parseCSV(file);\n    } else if (fileType === 'excel') {\n      return this.parseExcel(file);\n    }\n    throw new Error(`Unknown file type: ${fileType}`);\n  }\n\n  /**\n   * Get extraction prompt based on report type\n   * @param {string} condition - 'EO' or 'EC'\n   * @param {string} reportType - 'raw' or 'zscore'\n   * @param {string} pdfText - PDF text content\n   * @returns {string} Extraction prompt\n   */\n  static getExtractionPrompt(condition, reportType, pdfText) {\n    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';\n\n    if (reportType === 'zscore') {\n      // Z-SCORE extraction prompt\n      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.\n\n**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.\n- Negative values = below average (lower than normal)\n- Zero (0) = average (normal)\n- Positive values = above average (higher than normal)\n\nLook for tables labeled with \"Z-score\", \"Z score\", \"Z\", or \"Standard Deviation\" in the headers.\n\nExtract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2\n\nFor each channel, extract Z-scores for these frequency bands:\n- Delta (1-4 Hz)\n- Theta (4-8 Hz)\n- Alpha (8-13 Hz)\n- Beta (13-30 Hz)\n- HiBeta / High Beta (20-30 Hz)\n\nAlso extract:\n- Alpha Peak Frequency (Hz) and its Z-score if available\n\nIf you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.\n\n**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:\n- No markdown formatting (no \\`\\`\\`json or \\`\\`\\`)\n- No explanations before or after\n- No comments\n- Just pure JSON that starts with { and ends with }\n\nReturn ONLY this EXACT JSON format:\n{\n  \"zscores\": {\n    \"absolute\": {\n      \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n    },\n    \"relative\": {\n      \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n      \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n    }\n  },\n  \"special\": {\n    \"alphaPeak\": 10.0,\n    \"alphaPeakZscore\": 0.0\n  }\n}\n\nPDF Content:\n${pdfText.substring(0, 15000)}`;\n\n    } else {\n      // RAW POWER extraction prompt (existing)\n      return `You are a QEEG data extraction expert. Extract the following data from this ${conditionName} QEEG report:\n\nExtract two tables:\n1. **Absolute Power (Î¼VÂ²)** table\n2. **Relative Power (%)** table\n\nFor each table, extract values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2\n\nFor each channel, extract values for these frequency bands:\n- Delta\n- Theta\n- Alpha\n- Beta\n- HiBeta (High Beta)\n\nAlso extract Alpha Peak Frequency (APF) if available.\n\n**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:\n- No markdown formatting (no \\`\\`\\`json or \\`\\`\\`)\n- No explanations before or after\n- No comments\n- Just pure JSON that starts with { and ends with }\n\nReturn the data in this EXACT JSON format:\n{\n  \"absolute\": {\n    \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n  },\n  \"relative\": {\n    \"Fz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"Cz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"Pz\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"F3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"F4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"C3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"C4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"P3\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 },\n    \"P4\": { \"Delta\": 0.0, \"Theta\": 0.0, \"Alpha\": 0.0, \"Beta\": 0.0, \"HiBeta\": 0.0 }\n  },\n  \"special\": {\n    \"alphaPeak\": 10.0,\n    \"O1\": 10.0\n  }\n}\n\nPDF Content:\n${pdfText.substring(0, 15000)}`;\n    }\n  }\n\n  /**\n   * Parse PDF file using Gemini AI\n   * @param {Object} file - Multer file object\n   * @param {string} condition - 'EO' or 'EC'\n   * @param {string} reportType - 'raw' or 'zscore'\n   */\n  static async parsePDF(file, condition, reportType = 'raw') {\n    console.log(`  ğŸ” Parsing PDF with Gemini AI (${condition}, ${reportType.toUpperCase()} mode)...`);\n\n    try {\n      // Validate API key before attempting to use it\n      this.validateAPIKey();\n\n\n      // Read PDF file\n      const dataBuffer = fs.readFileSync(file.path);\n      const pdfData = await pdfParse(dataBuffer);\n\n      // Extract text from PDF\n      const pdfText = pdfData.text;\n\n      // Get appropriate extraction prompt based on report type\n      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);\n\n      // Initialize Gemini model if not already done\n      if (!geminiModel) {\n        console.log('  ğŸ”§ Initializing Gemini model for data extraction...');\n        console.log('  ğŸ”‘ API Key status:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');\n        console.log('  ğŸ”‘ API Key length:', process.env.GEMINI_API_KEY?.length || 0);\n        console.log('  ğŸ”‘ API Key preview:', process.env.GEMINI_API_KEY ? `${process.env.GEMINI_API_KEY.substring(0, 20)}...` : 'N/A');\n\n        // Fetch available models dynamically\n        const availableModels = await this.fetchAvailableModels();\n\n        if (availableModels.length === 0) {\n          console.error('\\n  âŒ === NO MODELS AVAILABLE ===');\n          console.error('  Please check:');\n          console.error('  1. GEMINI_API_KEY is correct in .env file');\n          console.error('  2. API key has proper permissions');\n          console.error('  3. Visit: https://aistudio.google.com/apikey to get a new key');\n          console.error('  4. Make sure Generative Language API is enabled');\n          console.error('  ================================\\n');\n          throw new Error('No Gemini models available. Check your API key.');\n        }\n\n        // Select best model\n        const modelName = this.selectBestModel(availableModels);\n\n        if (!modelName) {\n          throw new Error('Could not select a valid model from available models');\n        }\n\n        // Initialize model with full path\n        console.log(`  ğŸ”§ Initializing model: ${modelName}`);\n        geminiModel = genAI.getGenerativeModel({ model: modelName });\n\n        // Test the model with a simple call\n        console.log(`  ğŸ“ Testing ${modelName} with simple call...`);\n        try {\n          const testResult = await geminiModel.generateContent('Hello');\n          const testResponse = await testResult.response;\n          const testText = testResponse.text();\n\n          console.log(`  âœ… Model initialized and tested successfully`);\n          console.log(`  ğŸ“ Test response: ${testText.substring(0, 50)}...`);\n        } catch (testError) {\n          console.error(`  âŒ Model test failed:`, testError.message);\n          throw new Error(`Failed to test model ${modelName}: ${testError.message}`);\n        }\n      }\n\n      console.log(`  ğŸ¤– Using Gemini AI for data extraction (${condition})...`);\n\n      // Call Gemini API\n      const result = await geminiModel.generateContent(prompt);\n      const response = await result.response;\n      const text = response.text();\n\n      console.log(`  ğŸ“ Gemini response received (${condition}), length: ${text.length} characters`);\n\n      // Parse JSON from response (remove markdown code blocks if present)\n      let extractedData;\n      try {\n        const jsonText = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n        extractedData = JSON.parse(jsonText);\n        console.log(`  âœ… PDF data extracted successfully with Gemini (${condition})`);\n      } catch (parseError) {\n        console.error(`  âŒ Failed to parse JSON from Gemini response (${condition}):`, parseError.message);\n        console.error(`  ğŸ“„ Raw response:`, text.substring(0, 500));\n        throw new Error(`Failed to parse JSON from Gemini response: ${parseError.message}`);\n      }\n\n      // Add detailed logging\n      console.log(`  ğŸ“Š Data extraction summary (${condition}):`);\n      console.log(`     - Absolute power channels: ${Object.keys(extractedData.absolute || {}).length}`);\n      console.log(`     - Relative power channels: ${Object.keys(extractedData.relative || {}).length}`);\n      console.log(`     - Special values: ${JSON.stringify(extractedData.special || {})}`);\n\n      // Log sample extracted values for verification (prove it's real patient data, not static)\n      console.log(`\\n  ğŸ“‹ Sample Extracted Values (${condition}) - Proof of Dynamic Extraction:`);\n      if (extractedData.absolute?.Fz) {\n        console.log(`     - Fz Absolute: Theta=${extractedData.absolute.Fz.Theta}, Beta=${extractedData.absolute.Fz.Beta}`);\n      }\n      if (extractedData.absolute?.Pz) {\n        console.log(`     - Pz Absolute: Alpha=${extractedData.absolute.Pz.Alpha}, HiBeta=${extractedData.absolute.Pz.HiBeta}`);\n      }\n      if (extractedData.relative?.Pz) {\n        console.log(`     - Pz Relative: Alpha=${extractedData.relative.Pz.Alpha}, Beta=${extractedData.relative.Pz.Beta}`);\n      }\n      if (extractedData.absolute?.F3 && extractedData.absolute?.F4) {\n        console.log(`     - F3/F4 Absolute Alpha: F3=${extractedData.absolute.F3.Alpha}, F4=${extractedData.absolute.F4.Alpha}`);\n      }\n      if (extractedData.special?.alphaPeak) {\n        console.log(`     - Alpha Peak Frequency: ${extractedData.special.alphaPeak} Hz`);\n      }\n\n      // Validate extracted data has minimum required fields\n      const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];\n      const absoluteChannels = Object.keys(extractedData.absolute || {});\n      const relativeChannels = Object.keys(extractedData.relative || {});\n\n      const missingAbsolute = requiredChannels.filter(ch => !absoluteChannels.includes(ch));\n      const missingRelative = requiredChannels.filter(ch => !relativeChannels.includes(ch));\n\n      if (missingAbsolute.length > 0) {\n        console.warn(`  âš ï¸  Missing absolute power channels: ${missingAbsolute.join(', ')}`);\n      }\n      if (missingRelative.length > 0) {\n        console.warn(`  âš ï¸  Missing relative power channels: ${missingRelative.join(', ')}`);\n      }\n\n      return extractedData;\n\n    } catch (error) {\n      console.error(`  âŒ Gemini API error (${condition}):`, error.message);\n\n      // Log more details for debugging\n      if (error.response) {\n        console.error(`  âŒ Gemini API Status:`, error.response?.status);\n        console.error(`  âŒ Gemini API Error:`, error.response?.data);\n      }\n\n      console.error(`  ğŸ“„ Error stack:`, error.stack);\n\n      // Re-throw with more context\n      const enhancedError = new Error(`Failed to extract QEEG data from PDF using Gemini (${condition}): ${error.message}`);\n      enhancedError.code = 'PDF_EXTRACTION_FAILED';\n      enhancedError.originalError = error;\n      enhancedError.condition = condition;\n      throw enhancedError;\n    }\n  }\n\n  /**\n   * Parse CSV file\n   */\n  static parseCSV(file) {\n    console.log('  ğŸ“Š Parsing CSV file...');\n\n    // Read CSV file\n    const workbook = XLSX.readFile(file.path);\n    const sheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[sheetName];\n    const jsonData = XLSX.utils.sheet_to_json(worksheet);\n\n    // Convert CSV data to our format\n    const data = this.convertCSVToFormat(jsonData);\n\n    console.log('  âœ… CSV parsed successfully');\n    return data;\n  }\n\n  /**\n   * Parse Excel file\n   */\n  static parseExcel(file) {\n    console.log('  ğŸ“Š Parsing Excel file...');\n\n    // Read Excel file\n    const workbook = XLSX.readFile(file.path);\n    const sheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[sheetName];\n    const jsonData = XLSX.utils.sheet_to_json(worksheet);\n\n    // Convert Excel data to our format\n    const data = this.convertExcelToFormat(jsonData);\n\n    console.log('  âœ… Excel parsed successfully');\n    return data;\n  }\n\n  /**\n   * Convert CSV data to expected format\n   */\n  static convertCSVToFormat(csvData) {\n    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta\n    const result = {\n      absolute: {},\n      relative: {},\n      special: { alphaPeak: 10.0, O1: 10.0 }\n    };\n\n    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];\n    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];\n\n    for (const row of csvData) {\n      const channel = row.Channel;\n      const powerType = row.PowerType?.toLowerCase();\n\n      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {\n        result[powerType][channel] = {\n          Delta: parseFloat(row.Delta) || 0,\n          Theta: parseFloat(row.Theta) || 0,\n          Alpha: parseFloat(row.Alpha) || 0,\n          Beta: parseFloat(row.Beta) || 0,\n          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0\n        };\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert Excel data to expected format (same as CSV for now)\n   */\n  static convertExcelToFormat(excelData) {\n    return this.convertCSVToFormat(excelData);\n  }\n}\n\nmodule.exports = QEEGParser;\n","numLines":687,"startLine":1,"totalLines":687}}}
{"parentUuid":"bc7fc6dc-bf02-4f47-ae0b-619c82c5eaac","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NMtWEmoe2XfiU7S86hBn6c","type":"tool_result","content":"     1â†’const express = require('express');\n     2â†’const multer = require('multer');\n     3â†’const path = require('path');\n     4â†’const fs = require('fs');\n     5â†’const QEEGParser = require('../services/qeegParser');\n     6â†’const AlgorithmCalculator = require('../services/algorithmCalculator');\n     7â†’const ZScoreCalculator = require('../services/zscoreCalculator');\n     8â†’// OLD generators (keeping for fallback)\n     9â†’const PDFReportGenerator = require('../services/pdfGenerator');\n    10â†’const TemplateBasedPDFGenerator = require('../services/pdfGeneratorTemplate');\n    11â†’const templateManager = require('../services/pdf/templateManager');\n    12â†’const AIPdfGenerator = require('../services/aiPdfGenerator');\n    13â†’const SupabaseStorage = require('../services/supabaseStorage');\n    14â†’\n    15â†’// NEW: Gemini AI Service for report generation\n    16â†’let GeminiService = null;\n    17â†’try {\n    18â†’  GeminiService = require('../services/geminiService');\n    19â†’  console.log('âœ… Gemini AI Service loaded successfully');\n    20â†’} catch (error) {\n    21â†’  console.error('âŒ CRITICAL: Gemini AI Service failed to load!');\n    22â†’  console.error('   Error:', error.message);\n    23â†’  console.error('   Stack:', error.stack);\n    24â†’}\n    25â†’\n    26â†’// NEW: Gemini PDF Generator - Uses Gemini AI for content generation\n    27â†’let GeminiPdfGenerator = null;\n    28â†’try {\n    29â†’  GeminiPdfGenerator = require('../services/geminiPdfGenerator');\n    30â†’  console.log('âœ… Gemini PDF Generator loaded successfully');\n    31â†’  console.log('   Generator available:', !!GeminiPdfGenerator);\n    32â†’} catch (error) {\n    33â†’  console.error('âŒ CRITICAL: Gemini PDF Generator failed to load!');\n    34â†’  console.error('   Error:', error.message);\n    35â†’  console.error('   Stack:', error.stack);\n    36â†’}\n    37â†’\n    38â†’// OLD: Enhanced AI PDF Generator with OpenAI (keeping as fallback)\n    39â†’let EnhancedAIPdfGenerator = null;\n    40â†’try {\n    41â†’  EnhancedAIPdfGenerator = require('../services/aiPdfGeneratorEnhanced');\n    42â†’  console.log('âœ… Enhanced AI PDF Generator loaded successfully');\n    43â†’} catch (error) {\n    44â†’  console.warn('âš ï¸  Enhanced AI PDF Generator failed to load:', error.message);\n    45â†’  console.warn('   Will use fallback PDF generator');\n    46â†’}\n    47â†’\n    48â†’const router = express.Router();\n    49â†’\n    50â†’// Configure multer for file uploads\n    51â†’const storage = multer.diskStorage({\n    52â†’  destination: function (req, file, cb) {\n    53â†’    const uploadDir = path.join(__dirname, '../uploads');\n    54â†’    // Ensure upload directory exists\n    55â†’    if (!fs.existsSync(uploadDir)) {\n    56â†’      fs.mkdirSync(uploadDir, { recursive: true });\n    57â†’    }\n    58â†’    cb(null, uploadDir);\n    59â†’  },\n    60â†’  filename: function (req, file, cb) {\n    61â†’    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    62â†’    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n    63â†’  }\n    64â†’});\n    65â†’\n    66â†’const upload = multer({\n    67â†’  storage: storage,\n    68â†’  limits: {\n    69â†’    fileSize: 10 * 1024 * 1024 // 10MB limit\n    70â†’  },\n    71â†’  fileFilter: function (req, file, cb) {\n    72â†’    const allowedExtensions = ['.pdf', '.csv', '.xlsx', '.xls'];\n    73â†’    const ext = path.extname(file.originalname).toLowerCase();\n    74â†’    if (allowedExtensions.includes(ext)) {\n    75â†’      cb(null, true);\n    76â†’    } else {\n    77â†’      cb(new Error(`Only ${allowedExtensions.join(', ')} files are allowed`));\n    78â†’    }\n    79â†’  }\n    80â†’});\n    81â†’\n    82â†’/**\n    83â†’ * POST /api/qeeg/process\n    84â†’ * Process QEEG files and calculate 7 brain health parameters\n    85â†’ */\n    86â†’router.post('/process', upload.fields([\n    87â†’  { name: 'eyesOpen', maxCount: 1 },\n    88â†’  { name: 'eyesClosed', maxCount: 1 }\n    89â†’]), async (req, res) => {\n    90â†’  let eyesOpenFile = null;\n    91â†’  let eyesClosedFile = null;\n    92â†’\n    93â†’  try {\n    94â†’    console.log('\\nğŸ”¬ === QEEG Processing Started ===\\n');\n    95â†’\n    96â†’    // Get uploaded files\n    97â†’    const files = req.files;\n    98â†’    if (!files || !files.eyesOpen || !files.eyesClosed) {\n    99â†’      return res.status(400).json({\n   100â†’        error: true,\n   101â†’        message: 'Both Eyes Open and Eyes Closed files are required'\n   102â†’      });\n   103â†’    }\n   104â†’\n   105â†’    eyesOpenFile = files.eyesOpen[0];\n   106â†’    eyesClosedFile = files.eyesClosed[0];\n   107â†’\n   108â†’    console.log('ğŸ“ Files received:');\n   109â†’    console.log('  - Eyes Open:', eyesOpenFile.originalname, `(${(eyesOpenFile.size / 1024).toFixed(2)} KB)`);\n   110â†’    console.log('  - Eyes Closed:', eyesClosedFile.originalname, `(${(eyesClosedFile.size / 1024).toFixed(2)} KB)`);\n   111â†’\n   112â†’    // Get patient info from request body\n   113â†’    const {\n   114â†’      patientId,\n   115â†’      patientName,\n   116â†’      clinicName,\n   117â†’      dateOfBirth,\n   118â†’      age,\n   119â†’      gender,\n   120â†’      handedness\n   121â†’    } = req.body;\n   122â†’\n   123â†’    console.log('\\nğŸ‘¤ Patient Information:');\n   124â†’    console.log('  - Patient ID:', patientId);\n   125â†’    console.log('  - Patient Name:', patientName);\n   126â†’    console.log('  - Clinic:', clinicName);\n   127â†’    console.log('  - Date of Birth:', dateOfBirth);\n   128â†’    console.log('  - Age:', age);\n   129â†’    console.log('  - Gender:', gender);\n   130â†’    console.log('  - Handedness:', handedness);\n   131â†’\n   132â†’    // Validate OpenAI API configuration before processing (OPTIONAL - don't fail if missing)\n   133â†’    console.log('\\nğŸ” Checking OpenAI API configuration...');\n   134â†’    try {\n   135â†’      await QEEGParser.testAPIConnection();\n   136â†’      console.log('âœ… OpenAI API configured properly');\n   137â†’    } catch (apiError) {\n   138â†’      console.warn('âš ï¸  OpenAI API not configured or failed test:', apiError.message);\n   139â†’      console.warn('   Continuing with processing anyway...');\n   140â†’      // Don't throw error - allow processing to continue without OpenAI\n   141â†’    }\n   142â†’\n   143â†’    // Step 1: Parse QEEG files\n   144â†’    console.log('\\nğŸ“Š Step 1: Parsing QEEG files...');\n   145â†’    const qeegData = await QEEGParser.parse(eyesOpenFile, eyesClosedFile);\n   146â†’\n   147â†’    // Validate that we got real patient data\n   148â†’    console.log('\\nğŸ“Š QEEG Data Validation:');\n   149â†’    console.log('  - Eyes Open (EO) channels:', Object.keys(qeegData.EO?.absolute || {}).length);\n   150â†’    console.log('  - Eyes Closed (EC) channels:', Object.keys(qeegData.EC?.absolute || {}).length);\n   151â†’    console.log('  - Using REAL PATIENT DATA (not sample data)');\n   152â†’    console.log('  - Patient:', patientName, `(ID: ${patientId})`);\n   153â†’\n   154â†’    // Verify non-zero values (proof of real data extraction)\n   155â†’    const eoFzTheta = qeegData.EO?.absolute?.Fz?.Theta || 0;\n   156â†’    const ecPzAlpha = qeegData.EC?.absolute?.Pz?.Alpha || 0;\n   157â†’    console.log('  - Sample Values (proof of extraction):');\n   158â†’    console.log(`    * EO Fz Theta: ${eoFzTheta}`);\n   159â†’    console.log(`    * EC Pz Alpha: ${ecPzAlpha}`);\n   160â†’\n   161â†’    // Warn if all values are zero (indicates parsing failure)\n   162â†’    if (eoFzTheta === 0 && ecPzAlpha === 0) {\n   163â†’      console.warn('  âš ï¸  WARNING: Sample values are zero - possible parsing issue!');\n   164â†’    }\n   165â†’\n   166â†’    // COMPREHENSIVE VALIDATION CHECKS\n   167â†’    console.log('\\nğŸ” Comprehensive Data Validation:');\n   168â†’\n   169â†’    // Check 1: Verify key channels have data\n   170â†’    const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4'];\n   171â†’    let missingChannels = 0;\n   172â†’    requiredChannels.forEach(ch => {\n   173â†’      const hasEO = qeegData.EO?.absolute?.[ch]?.Theta !== undefined;\n   174â†’      const hasEC = qeegData.EC?.absolute?.[ch]?.Alpha !== undefined;\n   175â†’      if (!hasEO || !hasEC) {\n   176â†’        console.warn(`  âš ï¸  Missing data for channel ${ch}`);\n   177â†’        missingChannels++;\n   178â†’      }\n   179â†’    });\n   180â†’    if (missingChannels === 0) {\n   181â†’      console.log('  âœ… All required channels have data');\n   182â†’    }\n   183â†’\n   184â†’    // Check 2: Verify values are in reasonable ranges (not all zeros or defaults)\n   185â†’    const testValues = [\n   186â†’      qeegData.EO?.absolute?.Fz?.Theta,\n   187â†’      qeegData.EO?.absolute?.Fz?.Beta,\n   188â†’      qeegData.EC?.absolute?.Pz?.Alpha,\n   189â†’      qeegData.EC?.relative?.Pz?.Alpha,\n   190â†’      qeegData.EC?.relative?.Pz?.Beta\n   191â†’    ];\n   192â†’    const uniqueValues = new Set(testValues.filter(v => v !== null && v !== undefined));\n   193â†’    if (uniqueValues.size <= 1) {\n   194â†’      console.warn('  âš ï¸  WARNING: All test values are the same - possible static data!');\n   195â†’    } else {\n   196â†’      console.log(`  âœ… Data shows ${uniqueValues.size} unique values (not static)`);\n   197â†’    }\n   198â†’\n   199â†’    // Check 3: Verify relative power sums to ~100% for a sample channel\n   200â†’    if (qeegData.EO?.relative?.Fz) {\n   201â†’      const fzBands = qeegData.EO.relative.Fz;\n   202â†’      const sum = (fzBands.Delta || 0) + (fzBands.Theta || 0) +\n   203â†’                  (fzBands.Alpha || 0) + (fzBands.Beta || 0) +\n   204â†’                  (fzBands.HiBeta || 0);\n   205â†’      console.log(`  ğŸ“Š Relative power sum (EO Fz): ${sum.toFixed(1)}%`);\n   206â†’      if (sum < 80 || sum > 120) {\n   207â†’        console.warn(`  âš ï¸  WARNING: Relative power sum is ${sum.toFixed(1)}% (expected ~100%)`);\n   208â†’      } else {\n   209â†’        console.log('  âœ… Relative power validation passed');\n   210â†’      }\n   211â†’    }\n   212â†’\n   213â†’    // Check 4: Verify critical values for calculations exist\n   214â†’    const criticalValues = {\n   215â†’      'Relaxation (Pz EC Relative Alpha)': qeegData.EC?.relative?.Pz?.Alpha,\n   216â†’      'Relaxation (Pz EC Relative Beta)': qeegData.EC?.relative?.Pz?.Beta,\n   217â†’      'Focus (Fz EO Theta)': qeegData.EO?.absolute?.Fz?.Theta,\n   218â†’      'Focus (Fz EO Beta)': qeegData.EO?.absolute?.Fz?.Beta,\n   219â†’      'Alpha Peak': qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1\n   220â†’    };\n   221â†’\n   222â†’    console.log('\\n  ğŸ¯ Critical Values Check:');\n   223â†’    let missingCritical = 0;\n   224â†’    Object.entries(criticalValues).forEach(([name, value]) => {\n   225â†’      if (value === null || value === undefined) {\n   226â†’        console.warn(`  âŒ MISSING: ${name}`);\n   227â†’        missingCritical++;\n   228â†’      } else {\n   229â†’        console.log(`  âœ… ${name}: ${value}`);\n   230â†’      }\n   231â†’    });\n   232â†’\n   233â†’    if (missingCritical > 0) {\n   234â†’      console.warn(`\\n  âš ï¸  WARNING: ${missingCritical} critical values missing - calculations may be inaccurate!`);\n   235â†’    } else {\n   236â†’      console.log('\\n  âœ… All critical values present - ready for calculation');\n   237â†’    }\n   238â†’\n   239â†’    // Step 2: Calculate parameters with appropriate calculator\n   240â†’    console.log('\\nğŸ§® Step 2: Calculating 7 brain health parameters...');\n   241â†’\n   242â†’    // Route to appropriate calculator based on data type\n   243â†’    const dataType = qeegData.dataType || 'raw';\n   244â†’    console.log(`ğŸ“Š Data Type: ${dataType.toUpperCase()} mode`);\n   245â†’\n   246â†’    let calculator;\n   247â†’    if (dataType === 'zscore') {\n   248â†’      console.log('   Using Z-Score Calculator');\n   249â†’      calculator = new ZScoreCalculator(qeegData);\n   250â†’    } else {\n   251â†’      console.log('   Using Raw Power Calculator');\n   252â†’      calculator = new AlgorithmCalculator(qeegData);\n   253â†’    }\n   254â†’\n   255â†’    const results = calculator.calculate();\n   256â†’\n   257â†’    console.log('\\nâœ… Calculation completed successfully!');\n   258â†’    console.log('ğŸ“ˆ Results Summary:');\n   259â†’    results.parameters.forEach(param => {\n   260â†’      console.log(`  - ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n   261â†’    });\n   262â†’    console.log(`  - Overall Score: ${results.overallScore}/21`);\n   263â†’\n   264â†’    // COMPREHENSIVE DEBUG SUMMARY\n   265â†’    console.log('\\n' + '='.repeat(80));\n   266â†’    console.log('ğŸ“‹ COMPREHENSIVE DEBUG SUMMARY - FULL PIPELINE');\n   267â†’    console.log('='.repeat(80));\n   268â†’\n   269â†’    console.log('\\n1ï¸âƒ£  DATA EXTRACTION PHASE:');\n   270â†’    console.log(`    Patient: ${patientName} (ID: ${patientId})`);\n   271â†’    console.log(`    Data Type: ${dataType.toUpperCase()} mode`);\n   272â†’    console.log(`    EO Channels: ${Object.keys(qeegData.EO?.absolute || {}).length}`);\n   273â†’    console.log(`    EC Channels: ${Object.keys(qeegData.EC?.absolute || {}).length}`);\n   274â†’\n   275â†’    console.log('\\n2ï¸âƒ£  SAMPLE EXTRACTED DATA:');\n   276â†’    console.log('    Key Values Used in Calculations:');\n   277â†’    console.log(`    - Fz EO Absolute Theta: ${qeegData.EO?.absolute?.Fz?.Theta || 'N/A'}`);\n   278â†’    console.log(`    - Fz EO Absolute Beta: ${qeegData.EO?.absolute?.Fz?.Beta || 'N/A'}`);\n   279â†’    console.log(`    - Pz EC Relative Alpha: ${qeegData.EC?.relative?.Pz?.Alpha || 'N/A'}`);\n   280â†’    console.log(`    - Pz EC Relative Beta: ${qeegData.EC?.relative?.Pz?.Beta || 'N/A'}`);\n   281â†’    console.log(`    - Alpha Peak: ${qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1 || 'N/A'} Hz`);\n   282â†’\n   283â†’    console.log('\\n3ï¸âƒ£  CALCULATION RESULTS:');\n   284â†’    results.parameters.forEach((param, idx) => {\n   285â†’      console.log(`    ${idx + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n   286â†’      param.metrics.forEach(metric => {\n   287â†’        console.log(`       - ${metric.name}: ${metric.score} point`);\n   288â†’        if (metric.description) {\n   289â†’          console.log(`         ${metric.description}`);\n   290â†’        }\n   291â†’      });\n   292â†’    });\n   293â†’\n   294â†’    console.log('\\n4ï¸âƒ£  EXPECTED vs ACTUAL (for Rhea\\'s Report):');\n   295â†’    const expectedScores = {\n   296â†’      'Cognition': { expected: 2, actual: results.parameters.find(p => p.name === 'Cognition')?.score },\n   297â†’      'Stress': { expected: 0, actual: results.parameters.find(p => p.name === 'Stress')?.score },\n   298â†’      'Focus & Attention': { expected: 2, actual: results.parameters.find(p => p.name === 'Focus & Attention')?.score },\n   299â†’      'Burnout & Fatigue': { expected: 0, actual: results.parameters.find(p => p.name === 'Burnout & Fatigue')?.score },\n   300â†’      'Emotional Regulation': { expected: 3, actual: results.parameters.find(p => p.name === 'Emotional Regulation')?.score },\n   301â†’      'Learning': { expected: 2, actual: results.parameters.find(p => p.name === 'Learning')?.score },\n   302â†’      'Creativity': { expected: 2, actual: results.parameters.find(p => p.name === 'Creativity')?.score }\n   303â†’    };\n   304â†’\n   305â†’    console.log('    (Expected values are for Rhea\\'s Report only)');\n   306â†’    Object.entries(expectedScores).forEach(([name, scores]) => {\n   307â†’      const match = scores.expected === scores.actual ? 'âœ…' : 'âŒ';\n   308â†’      console.log(`    ${match} ${name}: Expected ${scores.expected}/3, Got ${scores.actual}/3`);\n   309â†’    });\n   310â†’\n   311â†’    console.log('\\n' + '='.repeat(80));\n   312â†’    console.log('END OF DEBUG SUMMARY');\n   313â†’    console.log('='.repeat(80) + '\\n');\n   314â†’\n   315â†’    // Step 3: Auto-generate PDF report\n   316â†’    console.log('\\nğŸ“„ Step 3: Auto-generating PDF report...');\n   317â†’    let pdfUrl = null;\n   318â†’    let pdfFilename = null;\n   319â†’\n   320â†’    try {\n   321â†’      // Prepare patient data for PDF\n   322â†’      const pdfPatientData = {\n   323â†’        name: patientName,\n   324â†’        dateOfBirth: dateOfBirth || 'N/A',\n   325â†’        age: age || 'N/A',\n   326â†’        gender: gender || 'Not specified',\n   327â†’        handedness: handedness || 'Not specified',\n   328â†’        patientId: patientId,\n   329â†’        clinicName: clinicName\n   330â†’      };\n   331â†’\n   332â†’      // Prepare algorithm results for PDF\n   333â†’      const pdfAlgorithmResults = {\n   334â†’        parameters: results.parameters,\n   335â†’        overallScore: results.overallScore\n   336â†’      };\n   337â†’\n   338â†’      // Debug: Log parameters being sent to PDF\n   339â†’      console.log('\\nğŸ“Š Parameters for PDF:');\n   340â†’      console.log('  - Total Parameters:', pdfAlgorithmResults.parameters.length);\n   341â†’      console.log('  - Overall Score:', pdfAlgorithmResults.overallScore);\n   342â†’      pdfAlgorithmResults.parameters.forEach((param, i) => {\n   343â†’        console.log(`  ${i + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n   344â†’      });\n   345â†’\n   346â†’      // Create output filename\n   347â†’      const timestamp = Date.now();\n   348â†’      const sanitizedName = (patientName || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n   349â†’      pdfFilename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n   350â†’      const uploadsDir = path.join(__dirname, '../uploads');\n   351â†’      const pdfOutputPath = path.join(uploadsDir, pdfFilename);\n   352â†’\n   353â†’      // Ensure uploads directory exists\n   354â†’      if (!fs.existsSync(uploadsDir)) {\n   355â†’        console.log('ğŸ“ Creating uploads directory...');\n   356â†’        fs.mkdirSync(uploadsDir, { recursive: true });\n   357â†’      }\n   358â†’\n   359â†’      console.log('ğŸ“ Generating PDF to:', pdfFilename);\n   360â†’      console.log('   Full path:', pdfOutputPath);\n   361â†’\n   362â†’      // === USE GEMINI PDF GENERATOR (with fallback) ===\n   363â†’      console.log('\\nğŸ” Checking available PDF generators...');\n   364â†’      console.log('   GeminiPdfGenerator available:', !!GeminiPdfGenerator);\n   365â†’      console.log('   EnhancedAIPdfGenerator available:', !!EnhancedAIPdfGenerator);\n   366â†’      console.log('   PDFReportGenerator available:', !!PDFReportGenerator);\n   367â†’\n   368â†’      let pdfGenerator;\n   369â†’      if (GeminiPdfGenerator) {\n   370â†’        console.log('\\nğŸ¤– === USING GEMINI AI PDF GENERATOR ===');\n   371â†’        console.log('   Engine: Google Gemini + PDFKit');\n   372â†’        console.log('   Patient:', pdfPatientData.name);\n   373â†’        console.log('   Parameters:', pdfAlgorithmResults.parameters.length);\n   374â†’        try {\n   375â†’          pdfGenerator = new GeminiPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n   376â†’          console.log('âœ… Gemini PDF Generator instantiated successfully');\n   377â†’        } catch (instantiateError) {\n   378â†’          console.error('âŒ Failed to instantiate Gemini PDF Generator:', instantiateError.message);\n   379â†’          throw instantiateError;\n   380â†’        }\n   381â†’      } else if (EnhancedAIPdfGenerator) {\n   382â†’        console.log('ğŸ¤– Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');\n   383â†’        pdfGenerator = new EnhancedAIPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n   384â†’      } else {\n   385â†’        console.log('ğŸ“„ Using Standard PDF Generator (Basic fallback)');\n   386â†’        pdfGenerator = new PDFReportGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n   387â†’      }\n   388â†’\n   389â†’      // Generate the PDF\n   390â†’      console.log('\\nğŸ“ Calling pdfGenerator.generateReport()...');\n   391â†’      console.log('   Output path:', pdfOutputPath);\n   392â†’\n   393â†’      try {\n   394â†’        await pdfGenerator.generateReport(pdfOutputPath);\n   395â†’        console.log('âœ… PDF generation completed!');\n   396â†’      } catch (genError) {\n   397â†’        console.error('âŒ PDF generation threw error:', genError.message);\n   398â†’        console.error('   Stack:', genError.stack);\n   399â†’        throw genError;\n   400â†’      }\n   401â†’\n   402â†’      // Verify file was created\n   403â†’      if (!fs.existsSync(pdfOutputPath)) {\n   404â†’        throw new Error('PDF file was not created at expected path: ' + pdfOutputPath);\n   405â†’      }\n   406â†’\n   407â†’      console.log('âœ… PDF file verified at:', pdfOutputPath);\n   408â†’      console.log('ğŸ“„ File:', pdfFilename);\n   409â†’      console.log('ğŸ“Š Size:', (fs.statSync(pdfOutputPath).size / 1024).toFixed(2), 'KB');\n   410â†’\n   411â†’      // Upload to Supabase Storage\n   412â†’      try {\n   413â†’        console.log('\\nâ˜ï¸  Uploading PDF to Supabase storage...');\n   414â†’        const uploadResult = await SupabaseStorage.uploadFile(\n   415â†’          pdfOutputPath,\n   416â†’          'neurosense_bucketreports', // bucket name\n   417â†’          `reports/${pdfFilename}` // path in bucket\n   418â†’        );\n   419â†’\n   420â†’        // Verify upload was successful and URL is valid\n   421â†’        if (uploadResult && uploadResult.url) {\n   422â†’          pdfUrl = uploadResult.url;\n   423â†’          console.log('âœ… PDF uploaded to Supabase successfully');\n   424â†’          console.log('ğŸ”— Supabase URL:', pdfUrl);\n   425â†’\n   426â†’          // Delete local file after successful Supabase upload\n   427â†’          try {\n   428â†’            fs.unlinkSync(pdfOutputPath);\n   429â†’            console.log('ğŸ—‘ï¸  Local PDF file deleted after successful upload');\n   430â†’          } catch (deleteError) {\n   431â†’            console.warn('âš ï¸  Could not delete local PDF file:', deleteError.message);\n   432â†’          }\n   433â†’        } else {\n   434â†’          throw new Error('Supabase upload returned invalid result');\n   435â†’        }\n   436â†’      } catch (supabaseError) {\n   437â†’        console.error('âš ï¸  Supabase upload failed, using local storage');\n   438â†’        console.error('   Error message:', supabaseError.message);\n   439â†’        console.error('   Error stack:', supabaseError.stack);\n   440â†’        console.error('   Full error:', JSON.stringify(supabaseError, null, 2));\n   441â†’        // Fallback to local storage\n   442â†’        pdfUrl = `/uploads/${pdfFilename}`;\n   443â†’        console.log('ğŸ“ Using local file as fallback:', pdfUrl);\n   444â†’      }\n   445â†’\n   446â†’    } catch (pdfError) {\n   447â†’      console.error('\\nâŒ === PDF GENERATION FAILED ===');\n   448â†’      console.error('Error message:', pdfError.message);\n   449â†’      console.error('Error stack:', pdfError.stack);\n   450â†’      console.error('Full error:', pdfError);\n   451â†’      console.error('=================================\\n');\n   452â†’\n   453â†’      // Set pdfUrl to null so frontend knows PDF failed\n   454â†’      pdfUrl = null;\n   455â†’\n   456â†’      // Don't fail the whole request if PDF fails - processing still succeeded\n   457â†’      console.log('âš ï¸ Continuing without PDF - processing succeeded');\n   458â†’    }\n   459â†’\n   460â†’    // Clean up uploaded files\n   461â†’    try {\n   462â†’      fs.unlinkSync(eyesOpenFile.path);\n   463â†’      fs.unlinkSync(eyesClosedFile.path);\n   464â†’      console.log('\\nğŸ—‘ï¸  Temporary files cleaned up');\n   465â†’    } catch (cleanupError) {\n   466â†’      console.error('âš ï¸  Error cleaning up files:', cleanupError.message);\n   467â†’    }\n   468â†’\n   469â†’    console.log('\\nğŸ === QEEG Processing Completed ===\\n');\n   470â†’\n   471â†’    // Final check for PDF URL\n   472â†’    if (!pdfUrl) {\n   473â†’      console.warn('âš ï¸âš ï¸âš ï¸ WARNING: No PDF URL available in response!');\n   474â†’      console.warn('   pdfFilename was:', pdfFilename || 'NOT SET');\n   475â†’      console.warn('   This means PDF generation completely failed');\n   476â†’    } else {\n   477â†’      console.log('âœ… PDF URL ready:', pdfUrl);\n   478â†’      console.log('   Type:', pdfUrl.startsWith('http') ? 'Supabase' : 'Local');\n   479â†’    }\n   480â†’\n   481â†’    // Send response\n   482â†’    res.json({\n   483â†’      success: true,\n   484â†’      data: {\n   485â†’        patientId,\n   486â†’        patientName,\n   487â†’        clinicName,\n   488â†’        processedAt: new Date().toISOString(),\n   489â†’        dataType: dataType, // Add data type (raw or zscore)\n   490â†’        results: results.parameters,\n   491â†’        overallScore: results.overallScore,\n   492â†’        maxScore: 21,\n   493â†’        pdfUrl: pdfUrl,\n   494â†’        pdfFilename: pdfFilename\n   495â†’      }\n   496â†’    });\n   497â†’\n   498â†’  } catch (error) {\n   499â†’    console.error('\\nâŒ === QEEG Processing Failed ===');\n   500â†’    console.error('Error:', error.message);\n   501â†’    console.error('Error Code:', error.code || 'UNKNOWN');\n   502â†’    console.error('Stack:', error.stack);\n   503â†’\n   504â†’    // Clean up files on error\n   505â†’    if (eyesOpenFile && fs.existsSync(eyesOpenFile.path)) {\n   506â†’      try {\n   507â†’        fs.unlinkSync(eyesOpenFile.path);\n   508â†’      } catch (e) {\n   509â†’        console.error('Error deleting Eyes Open file:', e.message);\n   510â†’      }\n   511â†’    }\n   512â†’    if (eyesClosedFile && fs.existsSync(eyesClosedFile.path)) {\n   513â†’      try {\n   514â†’        fs.unlinkSync(eyesClosedFile.path);\n   515â†’      } catch (e) {\n   516â†’        console.error('Error deleting Eyes Closed file:', e.message);\n   517â†’      }\n   518â†’    }\n   519â†’\n   520â†’    // Categorize errors for better user feedback\n   521â†’    let statusCode = 500;\n   522â†’    let userMessage = error.message;\n   523â†’\n   524â†’    switch (error.code) {\n   525â†’      case 'MISSING_API_KEY':\n   526â†’      case 'INVALID_API_KEY':\n   527â†’      case 'INVALID_API_KEY_FORMAT':\n   528â†’      case 'API_CONNECTION_FAILED':\n   529â†’        statusCode = 503; // Service Unavailable\n   530â†’        userMessage = 'System configuration error: OpenAI API key not properly configured. Please contact support.';\n   531â†’        break;\n   532â†’\n   533â†’      case 'PDF_EXTRACTION_FAILED':\n   534â†’        statusCode = 422; // Unprocessable Entity\n   535â†’        userMessage = 'Failed to extract QEEG data from PDF. Please ensure the PDF contains valid QEEG tables with absolute and relative power values.';\n   536â†’        break;\n   537â†’\n   538â†’      default:\n   539â†’        userMessage = error.message || 'Failed to process QEEG files';\n   540â†’    }\n   541â†’\n   542â†’    res.status(statusCode).json({\n   543â†’      error: true,\n   544â†’      message: userMessage,\n   545â†’      code: error.code || 'UNKNOWN_ERROR',\n   546â†’      technicalDetails: process.env.NODE_ENV === 'development' ? {\n   547â†’        originalMessage: error.message,\n   548â†’        stack: error.stack,\n   549â†’        condition: error.condition\n   550â†’      } : undefined\n   551â†’    });\n   552â†’  }\n   553â†’});\n   554â†’\n   555â†’/**\n   556â†’ * POST /api/qeeg/generate-pdf\n   557â†’ * Generate PDF report from algorithm results\n   558â†’ */\n   559â†’router.post('/generate-pdf', async (req, res) => {\n   560â†’  try {\n   561â†’    console.log('\\nğŸ“„ === PDF Report Generation Started ===\\n');\n   562â†’\n   563â†’    const { patientData, algorithmResults, qeegData } = req.body;\n   564â†’\n   565â†’    // Validate input\n   566â†’    if (!patientData || !algorithmResults || !qeegData) {\n   567â†’      return res.status(400).json({\n   568â†’        error: true,\n   569â†’        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'\n   570â†’      });\n   571â†’    }\n   572â†’\n   573â†’    console.log('ğŸ‘¤ Patient:', patientData.name);\n   574â†’    console.log('ğŸ“Š Parameters:', algorithmResults.parameters?.length);\n   575â†’\n   576â†’    // === USE GEMINI PDF GENERATOR (if available) ===\n   577â†’    let generator;\n   578â†’    if (GeminiPdfGenerator) {\n   579â†’      console.log('ğŸ¤– Using Gemini AI PDF Generator (Google Gemini + PDFKit)');\n   580â†’      generator = new GeminiPdfGenerator(patientData, algorithmResults, qeegData);\n   581â†’    } else if (EnhancedAIPdfGenerator) {\n   582â†’      console.log('ğŸ¤– Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');\n   583â†’      generator = new EnhancedAIPdfGenerator(patientData, algorithmResults, qeegData);\n   584â†’    } else {\n   585â†’      console.log('ğŸ“„ Using Standard PDF Generator (Basic fallback)');\n   586â†’      generator = new PDFReportGenerator(patientData, algorithmResults, qeegData);\n   587â†’    }\n   588â†’\n   589â†’    // Create output filename\n   590â†’    const timestamp = Date.now();\n   591â†’    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n   592â†’    const filename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n   593â†’    const outputPath = path.join(__dirname, '../uploads', filename);\n   594â†’\n   595â†’    console.log('ğŸ“ Generating AI-powered PDF to:', filename);\n   596â†’\n   597â†’    // Generate the PDF with AI insights\n   598â†’    const pdfPath = await generator.generateReport(outputPath);\n   599â†’\n   600â†’    console.log('\\nâœ… PDF Report Generated Successfully!');\n   601â†’    console.log('ğŸ“„ File:', filename);\n   602â†’    console.log('ğŸ“Š Size:', (fs.statSync(pdfPath).size / 1024).toFixed(2), 'KB');\n   603â†’\n   604â†’    // Upload to Supabase Storage - TEMPORARILY DISABLED\n   605â†’    let supabaseUrl = null;\n   606â†’    let supabasePath = null;\n   607â†’    let uploadError = null;\n   608â†’\n   609â†’    // DISABLE SUPABASE UPLOAD FOR NOW - USE LOCAL STORAGE ONLY\n   610â†’    console.log('\\nğŸ“ Using local storage (Supabase upload disabled)');\n   611â†’    uploadError = 'Supabase upload disabled - using local storage';\n   612â†’\n   613â†’    /* COMMENTED OUT - Enable when Supabase is configured properly\n   614â†’    try {\n   615â†’      console.log('\\nâ˜ï¸  Uploading PDF to Supabase storage...');\n   616â†’      const uploadResult = await SupabaseStorage.uploadFile(\n   617â†’        pdfPath,\n   618â†’        'patient-reports', // bucket name\n   619â†’        `reports/${filename}` // path in bucket\n   620â†’      );\n   621â†’\n   622â†’      // Verify upload was successful and URL is valid\n   623â†’      if (uploadResult && uploadResult.url) {\n   624â†’        supabaseUrl = uploadResult.url;\n   625â†’        supabasePath = uploadResult.path;\n   626â†’\n   627â†’        console.log('âœ… PDF uploaded to Supabase successfully');\n   628â†’        console.log('ğŸ”— Supabase URL:', supabaseUrl);\n   629â†’\n   630â†’        // Only delete local file after SUCCESSFUL Supabase upload\n   631â†’        try {\n   632â†’          fs.unlinkSync(pdfPath);\n   633â†’          console.log('ğŸ—‘ï¸  Local PDF file deleted after successful upload');\n   634â†’        } catch (deleteError) {\n   635â†’          console.warn('âš ï¸  Could not delete local PDF file:', deleteError.message);\n   636â†’        }\n   637â†’      } else {\n   638â†’        throw new Error('Supabase upload returned invalid result');\n   639â†’      }\n   640â†’\n   641â†’    } catch (error) {\n   642â†’      console.error('âš ï¸  Supabase upload failed, using local storage:', error.message);\n   643â†’      uploadError = error.message;\n   644â†’      // Keep local file as fallback - DO NOT DELETE\n   645â†’      console.log('ğŸ“ Using local file as fallback');\n   646â†’    }\n   647â†’    */\n   648â†’\n   649â†’    console.log('\\nğŸ === PDF Generation Completed ===\\n');\n   650â†’\n   651â†’    // Return PDF info - prioritize Supabase URL\n   652â†’    res.json({\n   653â†’      success: true,\n   654â†’      data: {\n   655â†’        filename: filename,\n   656â†’        path: supabasePath || `/uploads/${filename}`,\n   657â†’        url: supabaseUrl || `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n   658â†’        size: fs.existsSync(pdfPath) ? fs.statSync(pdfPath).size : 0,\n   659â†’        generatedAt: new Date().toISOString(),\n   660â†’        storage: supabaseUrl ? 'supabase' : 'local',\n   661â†’        uploadError: uploadError\n   662â†’      }\n   663â†’    });\n   664â†’\n   665â†’  } catch (error) {\n   666â†’    console.error('\\nâŒ === PDF Generation Failed ===');\n   667â†’    console.error('Error:', error.message);\n   668â†’    console.error('Stack:', error.stack);\n   669â†’\n   670â†’    res.status(500).json({\n   671â†’      error: true,\n   672â†’      message: error.message || 'Failed to generate PDF report',\n   673â†’      details: process.env.NODE_ENV === 'development' ? error.stack : undefined\n   674â†’    });\n   675â†’  }\n   676â†’});\n   677â†’\n   678â†’/**\n   679â†’ * POST /api/qeeg/generate-sample-pdf\n   680â†’ * Generate a sample PDF report for testing\n   681â†’ */\n   682â†’router.post('/generate-sample-pdf', async (req, res) => {\n   683â†’  try {\n   684â†’    console.log('\\nğŸ“„ === Sample PDF Generation Started ===\\n');\n   685â†’\n   686â†’    const pdfPath = await PDFReportGenerator.generateSampleReport();\n   687â†’\n   688â†’    console.log('âœ… Sample PDF Generated!');\n   689â†’    console.log('ğŸ“„ Path:', pdfPath);\n   690â†’\n   691â†’    const filename = path.basename(pdfPath);\n   692â†’\n   693â†’    res.json({\n   694â†’      success: true,\n   695â†’      data: {\n   696â†’        filename: filename,\n   697â†’        path: `/uploads/${filename}`,\n   698â†’        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n   699â†’        size: fs.statSync(pdfPath).size\n   700â†’      }\n   701â†’    });\n   702â†’\n   703â†’  } catch (error) {\n   704â†’    console.error('âŒ Sample PDF generation failed:', error);\n   705â†’\n   706â†’    res.status(500).json({\n   707â†’      error: true,\n   708â†’      message: error.message\n   709â†’    });\n   710â†’  }\n   711â†’});\n   712â†’\n   713â†’/**\n   714â†’ * POST /api/qeeg/generate-ai-pdf\n   715â†’ * Generate AI-powered PDF report with enhanced design and content\n   716â†’ */\n   717â†’router.post('/generate-ai-pdf', async (req, res) => {\n   718â†’  try {\n   719â†’    console.log('\\nğŸ¤– === AI PDF Report Generation Started ===\\n');\n   720â†’\n   721â†’    const { patientData, algorithmResults, qeegData } = req.body;\n   722â†’\n   723â†’    // Validate input\n   724â†’    if (!patientData || !algorithmResults || !qeegData) {\n   725â†’      return res.status(400).json({\n   726â†’        error: true,\n   727â†’        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'\n   728â†’      });\n   729â†’    }\n   730â†’\n   731â†’    console.log('ğŸ‘¤ Patient:', patientData.name);\n   732â†’    console.log('ğŸ“Š Parameters:', algorithmResults.parameters?.length);\n   733â†’    console.log('ğŸ¯ Using AI-powered generation with enhanced prompt');\n   734â†’\n   735â†’    // Generate AI PDF\n   736â†’    const generator = new AIPdfGenerator(patientData, algorithmResults, qeegData);\n   737â†’\n   738â†’    // Create output filename\n   739â†’    const timestamp = Date.now();\n   740â†’    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n   741â†’    const filename = `ai-neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n   742â†’    const outputPath = path.join(__dirname, '../uploads', filename);\n   743â†’\n   744â†’    console.log('ğŸ“ Generating AI PDF to:', filename);\n   745â†’\n   746â†’    // Generate the PDF\n   747â†’    const result = await generator.generateReport(outputPath);\n   748â†’\n   749â†’    console.log('\\nâœ… AI NeuroSense Report Generated Successfully!');\n   750â†’    console.log('ğŸ“„ Text File:', path.basename(result.textOutputPath));\n   751â†’    console.log('ğŸ“„ JSON File:', path.basename(result.outputPath));\n   752â†’    console.log('ğŸ“Š Tokens Used:', result.tokensUsed);\n   753â†’    console.log('ğŸ“ Content Length:', result.contentLength, 'characters');\n   754â†’    console.log('\\nğŸ === AI PDF Generation Completed ===\\n');\n   755â†’\n   756â†’    // Return report info\n   757â†’    res.json({\n   758â†’      success: true,\n   759â†’      data: {\n   760â†’        textFile: {\n   761â†’          filename: path.basename(result.textOutputPath),\n   762â†’          path: `/uploads/${path.basename(result.textOutputPath)}`,\n   763â†’          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.textOutputPath)}`,\n   764â†’          type: 'Plain Text Report'\n   765â†’        },\n   766â†’        jsonFile: {\n   767â†’          filename: path.basename(result.outputPath),\n   768â†’          path: `/uploads/${path.basename(result.outputPath)}`,\n   769â†’          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.outputPath)}`,\n   770â†’          type: 'Structured Data (JSON)'\n   771â†’        },\n   772â†’        contentLength: result.contentLength,\n   773â†’        tokensUsed: result.tokensUsed,\n   774â†’        generatedAt: new Date().toISOString()\n   775â†’      },\n   776â†’      message: 'AI-powered NeuroSense report generated successfully. Text file contains formatted report ready for PDF conversion.'\n   777â†’    });\n   778â†’\n   779â†’  } catch (error) {\n   780â†’    console.error('\\nâŒ === AI PDF Generation Failed ===');\n   781â†’    console.error('Error:', error.message);\n   782â†’    console.error('Stack:', error.stack);\n   783â†’\n   784â†’    res.status(500).json({\n   785â†’      error: true,\n   786â†’      message: error.message || 'Failed to generate AI PDF report',\n   787â†’      details: process.env.NODE_ENV === 'development' ? error.stack : undefined\n   788â†’    });\n   789â†’  }\n   790â†’});\n   791â†’\n   792â†’/**\n   793â†’ * POST /api/qeeg/generate-ai-sample-pdf\n   794â†’ * Generate a sample AI-powered PDF report for testing\n   795â†’ */\n   796â†’router.post('/generate-ai-sample-pdf', async (req, res) => {\n   797â†’  try {\n   798â†’    console.log('\\nğŸ¤– === Sample AI PDF Generation Started ===\\n');\n   799â†’\n   800â†’    const result = await AIPdfGenerator.generateSampleReport();\n   801â†’\n   802â†’    console.log('âœ… Sample AI PDF Generated!');\n   803â†’    console.log('ğŸ“„ Path:', result.outputPath);\n   804â†’\n   805â†’    const filename = path.basename(result.outputPath);\n   806â†’\n   807â†’    res.json({\n   808â†’      success: true,\n   809â†’      data: {\n   810â†’        filename: filename,\n   811â†’        path: `/uploads/${filename}`,\n   812â†’        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n   813â†’        contentLength: result.contentLength,\n   814â†’        tokensUsed: result.tokensUsed,\n   815â†’        type: 'AI-Generated Sample (JSON format)'\n   816â†’      }\n   817â†’    });\n   818â†’\n   819â†’  } catch (error) {\n   820â†’    console.error('âŒ Sample AI PDF generation failed:', error);\n   821â†’\n   822â†’    res.status(500).json({\n   823â†’      error: true,\n   824â†’      message: error.message\n   825â†’    });\n   826â†’  }\n   827â†’});\n   828â†’\n   829â†’/**\n   830â†’ * GET /api/qeeg/supabase-pdfs\n   831â†’ * List all PDFs from Supabase bucket\n   832â†’ */\n   833â†’router.get('/supabase-pdfs', async (req, res) => {\n   834â†’  try {\n   835â†’    console.log('ğŸ“‹ Fetching PDFs from Supabase bucket...');\n   836â†’\n   837â†’    const files = await SupabaseStorage.listFiles('neurosense_bucketreports', 'reports');\n   838â†’\n   839â†’    // Get public URLs for all files\n   840â†’    const pdfs = files.map(file => {\n   841â†’      const { createClient } = require('@supabase/supabase-js');\n   842â†’      const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);\n   843â†’      const { data: urlData } = supabase.storage\n   844â†’        .from('neurosense_bucketreports')\n   845â†’        .getPublicUrl(`reports/${file.name}`);\n   846â†’\n   847â†’      return {\n   848â†’        name: file.name,\n   849â†’        url: urlData.publicUrl,\n   850â†’        created_at: file.created_at,\n   851â†’        size: file.metadata?.size\n   852â†’      };\n   853â†’    });\n   854â†’\n   855â†’    console.log(`âœ… Found ${pdfs.length} PDFs in Supabase bucket`);\n   856â†’\n   857â†’    res.json({\n   858â†’      success: true,\n   859â†’      count: pdfs.length,\n   860â†’      pdfs: pdfs\n   861â†’    });\n   862â†’\n   863â†’  } catch (error) {\n   864â†’    console.error('âŒ Error listing Supabase PDFs:', error);\n   865â†’    res.status(500).json({\n   866â†’      success: false,\n   867â†’      error: error.message\n   868â†’    });\n   869â†’  }\n   870â†’});\n   871â†’\n   872â†’/**\n   873â†’ * GET /api/qeeg/test\n   874â†’ * Test endpoint to verify API is working\n   875â†’ */\n   876â†’router.get('/test', (req, res) => {\n   877â†’  res.json({\n   878â†’    success: true,\n   879â†’    message: 'QEEG Processing API is working',\n   880â†’    endpoints: {\n   881â†’      process: 'POST /api/qeeg/process - Upload and process QEEG files',\n   882â†’      generatePdf: 'POST /api/qeeg/generate-pdf - Generate PDF report from results (PDFKit)',\n   883â†’      generateSamplePdf: 'POST /api/qeeg/generate-sample-pdf - Generate sample PDF report (PDFKit)',\n   884â†’      generateAiPdf: 'POST /api/qeeg/generate-ai-pdf - Generate AI-powered PDF report (OpenAI)',\n   885â†’      generateAiSamplePdf: 'POST /api/qeeg/generate-ai-sample-pdf - Generate AI sample PDF report (OpenAI)',\n   886â†’      generateGeminiReport: 'POST /api/qeeg/generate-gemini-report - Generate AI report structure using Gemini',\n   887â†’      supabasePdfs: 'GET /api/qeeg/supabase-pdfs - List all PDFs from Supabase bucket'\n   888â†’    }\n   889â†’  });\n   890â†’});\n   891â†’\n   892â†’/**\n   893â†’ * POST /api/qeeg/generate-gemini-report\n   894â†’ * Generate AI-powered report structure using Google Gemini\n   895â†’ */\n   896â†’router.post('/generate-gemini-report', async (req, res) => {\n   897â†’  try {\n   898â†’    console.log('\\nğŸ¤– === Gemini AI Report Generation Started ===\\n');\n   899â†’\n   900â†’    if (!GeminiService) {\n   901â†’      return res.status(503).json({\n   902â†’        error: true,\n   903â†’        message: 'Gemini AI service is not available. Please check server configuration.'\n   904â†’      });\n   905â†’    }\n   906â†’\n   907â†’    const { algorithmResults } = req.body;\n   908â†’\n   909â†’    // Validate input\n   910â†’    if (!algorithmResults || !algorithmResults.parameters) {\n   911â†’      return res.status(400).json({\n   912â†’        error: true,\n   913â†’        message: 'Missing required data: algorithmResults with parameters array is required'\n   914â†’      });\n   915â†’    }\n   916â†’\n   917â†’    console.log('ğŸ“Š Processing', algorithmResults.parameters.length, 'brain parameters');\n   918â†’\n   919â†’    // Transform algorithm results to the format expected by Gemini\n   920â†’    const brainParameters = {\n   921â†’      Cognition: null,\n   922â†’      Stress: null,\n   923â†’      FocusAndAttention: null,\n   924â†’      BurnoutAndFatigue: null,\n   925â†’      EmotionalRegulation: null,\n   926â†’      Learning: null,\n   927â†’      Creativity: null\n   928â†’    };\n   929â†’\n   930â†’    // Map the parameters from algorithm results\n   931â†’    algorithmResults.parameters.forEach(param => {\n   932â†’      const paramName = param.name.replace(/\\s+/g, '');\n   933â†’      if (brainParameters.hasOwnProperty(paramName)) {\n   934â†’        brainParameters[paramName] = {\n   935â†’          score: param.score,\n   936â†’          bucket: param.bucket,\n   937â†’          subparameters: param.subParameters || []\n   938â†’        };\n   939â†’      }\n   940â†’    });\n   941â†’\n   942â†’    console.log('ğŸ§  Brain Parameters prepared for Gemini');\n   943â†’\n   944â†’    // Generate report using Gemini AI\n   945â†’    const result = await GeminiService.generateBrainPerformanceReport(brainParameters);\n   946â†’\n   947â†’    if (!result.success) {\n   948â†’      return res.status(500).json({\n   949â†’        error: true,\n   950â†’        message: 'Failed to generate report with Gemini AI',\n   951â†’        details: result.error\n   952â†’      });\n   953â†’    }\n   954â†’\n   955â†’    console.log('âœ… Gemini AI report generated successfully');\n   956â†’\n   957â†’    res.json({\n   958â†’      success: true,\n   959â†’      message: 'AI-powered report structure generated successfully',\n   960â†’      reportData: result.data,\n   961â†’      rawResponse: result.rawResponse\n   962â†’    });\n   963â†’\n   964â†’  } catch (error) {\n   965â†’    console.error('âŒ Error generating Gemini report:', error);\n   966â†’    res.status(500).json({\n   967â†’      error: true,\n   968â†’      message: 'Internal server error while generating Gemini report',\n   969â†’      details: error.message\n   970â†’    });\n   971â†’  }\n   972â†’});\n   973â†’\n   974â†’module.exports = router;\n   975â†’\n   976â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"15e2bab9-54c9-4a21-9121-ee56ae3bc573","timestamp":"2025-12-03T07:34:06.962Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js","content":"const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst QEEGParser = require('../services/qeegParser');\nconst AlgorithmCalculator = require('../services/algorithmCalculator');\nconst ZScoreCalculator = require('../services/zscoreCalculator');\n// OLD generators (keeping for fallback)\nconst PDFReportGenerator = require('../services/pdfGenerator');\nconst TemplateBasedPDFGenerator = require('../services/pdfGeneratorTemplate');\nconst templateManager = require('../services/pdf/templateManager');\nconst AIPdfGenerator = require('../services/aiPdfGenerator');\nconst SupabaseStorage = require('../services/supabaseStorage');\n\n// NEW: Gemini AI Service for report generation\nlet GeminiService = null;\ntry {\n  GeminiService = require('../services/geminiService');\n  console.log('âœ… Gemini AI Service loaded successfully');\n} catch (error) {\n  console.error('âŒ CRITICAL: Gemini AI Service failed to load!');\n  console.error('   Error:', error.message);\n  console.error('   Stack:', error.stack);\n}\n\n// NEW: Gemini PDF Generator - Uses Gemini AI for content generation\nlet GeminiPdfGenerator = null;\ntry {\n  GeminiPdfGenerator = require('../services/geminiPdfGenerator');\n  console.log('âœ… Gemini PDF Generator loaded successfully');\n  console.log('   Generator available:', !!GeminiPdfGenerator);\n} catch (error) {\n  console.error('âŒ CRITICAL: Gemini PDF Generator failed to load!');\n  console.error('   Error:', error.message);\n  console.error('   Stack:', error.stack);\n}\n\n// OLD: Enhanced AI PDF Generator with OpenAI (keeping as fallback)\nlet EnhancedAIPdfGenerator = null;\ntry {\n  EnhancedAIPdfGenerator = require('../services/aiPdfGeneratorEnhanced');\n  console.log('âœ… Enhanced AI PDF Generator loaded successfully');\n} catch (error) {\n  console.warn('âš ï¸  Enhanced AI PDF Generator failed to load:', error.message);\n  console.warn('   Will use fallback PDF generator');\n}\n\nconst router = express.Router();\n\n// Configure multer for file uploads\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    const uploadDir = path.join(__dirname, '../uploads');\n    // Ensure upload directory exists\n    if (!fs.existsSync(uploadDir)) {\n      fs.mkdirSync(uploadDir, { recursive: true });\n    }\n    cb(null, uploadDir);\n  },\n  filename: function (req, file, cb) {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({\n  storage: storage,\n  limits: {\n    fileSize: 10 * 1024 * 1024 // 10MB limit\n  },\n  fileFilter: function (req, file, cb) {\n    const allowedExtensions = ['.pdf', '.csv', '.xlsx', '.xls'];\n    const ext = path.extname(file.originalname).toLowerCase();\n    if (allowedExtensions.includes(ext)) {\n      cb(null, true);\n    } else {\n      cb(new Error(`Only ${allowedExtensions.join(', ')} files are allowed`));\n    }\n  }\n});\n\n/**\n * POST /api/qeeg/process\n * Process QEEG files and calculate 7 brain health parameters\n */\nrouter.post('/process', upload.fields([\n  { name: 'eyesOpen', maxCount: 1 },\n  { name: 'eyesClosed', maxCount: 1 }\n]), async (req, res) => {\n  let eyesOpenFile = null;\n  let eyesClosedFile = null;\n\n  try {\n    console.log('\\nğŸ”¬ === QEEG Processing Started ===\\n');\n\n    // Get uploaded files\n    const files = req.files;\n    if (!files || !files.eyesOpen || !files.eyesClosed) {\n      return res.status(400).json({\n        error: true,\n        message: 'Both Eyes Open and Eyes Closed files are required'\n      });\n    }\n\n    eyesOpenFile = files.eyesOpen[0];\n    eyesClosedFile = files.eyesClosed[0];\n\n    console.log('ğŸ“ Files received:');\n    console.log('  - Eyes Open:', eyesOpenFile.originalname, `(${(eyesOpenFile.size / 1024).toFixed(2)} KB)`);\n    console.log('  - Eyes Closed:', eyesClosedFile.originalname, `(${(eyesClosedFile.size / 1024).toFixed(2)} KB)`);\n\n    // Get patient info from request body\n    const {\n      patientId,\n      patientName,\n      clinicName,\n      dateOfBirth,\n      age,\n      gender,\n      handedness\n    } = req.body;\n\n    console.log('\\nğŸ‘¤ Patient Information:');\n    console.log('  - Patient ID:', patientId);\n    console.log('  - Patient Name:', patientName);\n    console.log('  - Clinic:', clinicName);\n    console.log('  - Date of Birth:', dateOfBirth);\n    console.log('  - Age:', age);\n    console.log('  - Gender:', gender);\n    console.log('  - Handedness:', handedness);\n\n    // Validate OpenAI API configuration before processing (OPTIONAL - don't fail if missing)\n    console.log('\\nğŸ” Checking OpenAI API configuration...');\n    try {\n      await QEEGParser.testAPIConnection();\n      console.log('âœ… OpenAI API configured properly');\n    } catch (apiError) {\n      console.warn('âš ï¸  OpenAI API not configured or failed test:', apiError.message);\n      console.warn('   Continuing with processing anyway...');\n      // Don't throw error - allow processing to continue without OpenAI\n    }\n\n    // Step 1: Parse QEEG files\n    console.log('\\nğŸ“Š Step 1: Parsing QEEG files...');\n    const qeegData = await QEEGParser.parse(eyesOpenFile, eyesClosedFile);\n\n    // Validate that we got real patient data\n    console.log('\\nğŸ“Š QEEG Data Validation:');\n    console.log('  - Eyes Open (EO) channels:', Object.keys(qeegData.EO?.absolute || {}).length);\n    console.log('  - Eyes Closed (EC) channels:', Object.keys(qeegData.EC?.absolute || {}).length);\n    console.log('  - Using REAL PATIENT DATA (not sample data)');\n    console.log('  - Patient:', patientName, `(ID: ${patientId})`);\n\n    // Verify non-zero values (proof of real data extraction)\n    const eoFzTheta = qeegData.EO?.absolute?.Fz?.Theta || 0;\n    const ecPzAlpha = qeegData.EC?.absolute?.Pz?.Alpha || 0;\n    console.log('  - Sample Values (proof of extraction):');\n    console.log(`    * EO Fz Theta: ${eoFzTheta}`);\n    console.log(`    * EC Pz Alpha: ${ecPzAlpha}`);\n\n    // Warn if all values are zero (indicates parsing failure)\n    if (eoFzTheta === 0 && ecPzAlpha === 0) {\n      console.warn('  âš ï¸  WARNING: Sample values are zero - possible parsing issue!');\n    }\n\n    // COMPREHENSIVE VALIDATION CHECKS\n    console.log('\\nğŸ” Comprehensive Data Validation:');\n\n    // Check 1: Verify key channels have data\n    const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4'];\n    let missingChannels = 0;\n    requiredChannels.forEach(ch => {\n      const hasEO = qeegData.EO?.absolute?.[ch]?.Theta !== undefined;\n      const hasEC = qeegData.EC?.absolute?.[ch]?.Alpha !== undefined;\n      if (!hasEO || !hasEC) {\n        console.warn(`  âš ï¸  Missing data for channel ${ch}`);\n        missingChannels++;\n      }\n    });\n    if (missingChannels === 0) {\n      console.log('  âœ… All required channels have data');\n    }\n\n    // Check 2: Verify values are in reasonable ranges (not all zeros or defaults)\n    const testValues = [\n      qeegData.EO?.absolute?.Fz?.Theta,\n      qeegData.EO?.absolute?.Fz?.Beta,\n      qeegData.EC?.absolute?.Pz?.Alpha,\n      qeegData.EC?.relative?.Pz?.Alpha,\n      qeegData.EC?.relative?.Pz?.Beta\n    ];\n    const uniqueValues = new Set(testValues.filter(v => v !== null && v !== undefined));\n    if (uniqueValues.size <= 1) {\n      console.warn('  âš ï¸  WARNING: All test values are the same - possible static data!');\n    } else {\n      console.log(`  âœ… Data shows ${uniqueValues.size} unique values (not static)`);\n    }\n\n    // Check 3: Verify relative power sums to ~100% for a sample channel\n    if (qeegData.EO?.relative?.Fz) {\n      const fzBands = qeegData.EO.relative.Fz;\n      const sum = (fzBands.Delta || 0) + (fzBands.Theta || 0) +\n                  (fzBands.Alpha || 0) + (fzBands.Beta || 0) +\n                  (fzBands.HiBeta || 0);\n      console.log(`  ğŸ“Š Relative power sum (EO Fz): ${sum.toFixed(1)}%`);\n      if (sum < 80 || sum > 120) {\n        console.warn(`  âš ï¸  WARNING: Relative power sum is ${sum.toFixed(1)}% (expected ~100%)`);\n      } else {\n        console.log('  âœ… Relative power validation passed');\n      }\n    }\n\n    // Check 4: Verify critical values for calculations exist\n    const criticalValues = {\n      'Relaxation (Pz EC Relative Alpha)': qeegData.EC?.relative?.Pz?.Alpha,\n      'Relaxation (Pz EC Relative Beta)': qeegData.EC?.relative?.Pz?.Beta,\n      'Focus (Fz EO Theta)': qeegData.EO?.absolute?.Fz?.Theta,\n      'Focus (Fz EO Beta)': qeegData.EO?.absolute?.Fz?.Beta,\n      'Alpha Peak': qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1\n    };\n\n    console.log('\\n  ğŸ¯ Critical Values Check:');\n    let missingCritical = 0;\n    Object.entries(criticalValues).forEach(([name, value]) => {\n      if (value === null || value === undefined) {\n        console.warn(`  âŒ MISSING: ${name}`);\n        missingCritical++;\n      } else {\n        console.log(`  âœ… ${name}: ${value}`);\n      }\n    });\n\n    if (missingCritical > 0) {\n      console.warn(`\\n  âš ï¸  WARNING: ${missingCritical} critical values missing - calculations may be inaccurate!`);\n    } else {\n      console.log('\\n  âœ… All critical values present - ready for calculation');\n    }\n\n    // Step 2: Calculate parameters with appropriate calculator\n    console.log('\\nğŸ§® Step 2: Calculating 7 brain health parameters...');\n\n    // Route to appropriate calculator based on data type\n    const dataType = qeegData.dataType || 'raw';\n    console.log(`ğŸ“Š Data Type: ${dataType.toUpperCase()} mode`);\n\n    let calculator;\n    if (dataType === 'zscore') {\n      console.log('   Using Z-Score Calculator');\n      calculator = new ZScoreCalculator(qeegData);\n    } else {\n      console.log('   Using Raw Power Calculator');\n      calculator = new AlgorithmCalculator(qeegData);\n    }\n\n    const results = calculator.calculate();\n\n    console.log('\\nâœ… Calculation completed successfully!');\n    console.log('ğŸ“ˆ Results Summary:');\n    results.parameters.forEach(param => {\n      console.log(`  - ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n    });\n    console.log(`  - Overall Score: ${results.overallScore}/21`);\n\n    // COMPREHENSIVE DEBUG SUMMARY\n    console.log('\\n' + '='.repeat(80));\n    console.log('ğŸ“‹ COMPREHENSIVE DEBUG SUMMARY - FULL PIPELINE');\n    console.log('='.repeat(80));\n\n    console.log('\\n1ï¸âƒ£  DATA EXTRACTION PHASE:');\n    console.log(`    Patient: ${patientName} (ID: ${patientId})`);\n    console.log(`    Data Type: ${dataType.toUpperCase()} mode`);\n    console.log(`    EO Channels: ${Object.keys(qeegData.EO?.absolute || {}).length}`);\n    console.log(`    EC Channels: ${Object.keys(qeegData.EC?.absolute || {}).length}`);\n\n    console.log('\\n2ï¸âƒ£  SAMPLE EXTRACTED DATA:');\n    console.log('    Key Values Used in Calculations:');\n    console.log(`    - Fz EO Absolute Theta: ${qeegData.EO?.absolute?.Fz?.Theta || 'N/A'}`);\n    console.log(`    - Fz EO Absolute Beta: ${qeegData.EO?.absolute?.Fz?.Beta || 'N/A'}`);\n    console.log(`    - Pz EC Relative Alpha: ${qeegData.EC?.relative?.Pz?.Alpha || 'N/A'}`);\n    console.log(`    - Pz EC Relative Beta: ${qeegData.EC?.relative?.Pz?.Beta || 'N/A'}`);\n    console.log(`    - Alpha Peak: ${qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1 || 'N/A'} Hz`);\n\n    console.log('\\n3ï¸âƒ£  CALCULATION RESULTS:');\n    results.parameters.forEach((param, idx) => {\n      console.log(`    ${idx + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n      param.metrics.forEach(metric => {\n        console.log(`       - ${metric.name}: ${metric.score} point`);\n        if (metric.description) {\n          console.log(`         ${metric.description}`);\n        }\n      });\n    });\n\n    console.log('\\n4ï¸âƒ£  EXPECTED vs ACTUAL (for Rhea\\'s Report):');\n    const expectedScores = {\n      'Cognition': { expected: 2, actual: results.parameters.find(p => p.name === 'Cognition')?.score },\n      'Stress': { expected: 0, actual: results.parameters.find(p => p.name === 'Stress')?.score },\n      'Focus & Attention': { expected: 2, actual: results.parameters.find(p => p.name === 'Focus & Attention')?.score },\n      'Burnout & Fatigue': { expected: 0, actual: results.parameters.find(p => p.name === 'Burnout & Fatigue')?.score },\n      'Emotional Regulation': { expected: 3, actual: results.parameters.find(p => p.name === 'Emotional Regulation')?.score },\n      'Learning': { expected: 2, actual: results.parameters.find(p => p.name === 'Learning')?.score },\n      'Creativity': { expected: 2, actual: results.parameters.find(p => p.name === 'Creativity')?.score }\n    };\n\n    console.log('    (Expected values are for Rhea\\'s Report only)');\n    Object.entries(expectedScores).forEach(([name, scores]) => {\n      const match = scores.expected === scores.actual ? 'âœ…' : 'âŒ';\n      console.log(`    ${match} ${name}: Expected ${scores.expected}/3, Got ${scores.actual}/3`);\n    });\n\n    console.log('\\n' + '='.repeat(80));\n    console.log('END OF DEBUG SUMMARY');\n    console.log('='.repeat(80) + '\\n');\n\n    // Step 3: Auto-generate PDF report\n    console.log('\\nğŸ“„ Step 3: Auto-generating PDF report...');\n    let pdfUrl = null;\n    let pdfFilename = null;\n\n    try {\n      // Prepare patient data for PDF\n      const pdfPatientData = {\n        name: patientName,\n        dateOfBirth: dateOfBirth || 'N/A',\n        age: age || 'N/A',\n        gender: gender || 'Not specified',\n        handedness: handedness || 'Not specified',\n        patientId: patientId,\n        clinicName: clinicName\n      };\n\n      // Prepare algorithm results for PDF\n      const pdfAlgorithmResults = {\n        parameters: results.parameters,\n        overallScore: results.overallScore\n      };\n\n      // Debug: Log parameters being sent to PDF\n      console.log('\\nğŸ“Š Parameters for PDF:');\n      console.log('  - Total Parameters:', pdfAlgorithmResults.parameters.length);\n      console.log('  - Overall Score:', pdfAlgorithmResults.overallScore);\n      pdfAlgorithmResults.parameters.forEach((param, i) => {\n        console.log(`  ${i + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);\n      });\n\n      // Create output filename\n      const timestamp = Date.now();\n      const sanitizedName = (patientName || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n      pdfFilename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n      const uploadsDir = path.join(__dirname, '../uploads');\n      const pdfOutputPath = path.join(uploadsDir, pdfFilename);\n\n      // Ensure uploads directory exists\n      if (!fs.existsSync(uploadsDir)) {\n        console.log('ğŸ“ Creating uploads directory...');\n        fs.mkdirSync(uploadsDir, { recursive: true });\n      }\n\n      console.log('ğŸ“ Generating PDF to:', pdfFilename);\n      console.log('   Full path:', pdfOutputPath);\n\n      // === USE GEMINI PDF GENERATOR (with fallback) ===\n      console.log('\\nğŸ” Checking available PDF generators...');\n      console.log('   GeminiPdfGenerator available:', !!GeminiPdfGenerator);\n      console.log('   EnhancedAIPdfGenerator available:', !!EnhancedAIPdfGenerator);\n      console.log('   PDFReportGenerator available:', !!PDFReportGenerator);\n\n      let pdfGenerator;\n      if (GeminiPdfGenerator) {\n        console.log('\\nğŸ¤– === USING GEMINI AI PDF GENERATOR ===');\n        console.log('   Engine: Google Gemini + PDFKit');\n        console.log('   Patient:', pdfPatientData.name);\n        console.log('   Parameters:', pdfAlgorithmResults.parameters.length);\n        try {\n          pdfGenerator = new GeminiPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n          console.log('âœ… Gemini PDF Generator instantiated successfully');\n        } catch (instantiateError) {\n          console.error('âŒ Failed to instantiate Gemini PDF Generator:', instantiateError.message);\n          throw instantiateError;\n        }\n      } else if (EnhancedAIPdfGenerator) {\n        console.log('ğŸ¤– Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');\n        pdfGenerator = new EnhancedAIPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n      } else {\n        console.log('ğŸ“„ Using Standard PDF Generator (Basic fallback)');\n        pdfGenerator = new PDFReportGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);\n      }\n\n      // Generate the PDF\n      console.log('\\nğŸ“ Calling pdfGenerator.generateReport()...');\n      console.log('   Output path:', pdfOutputPath);\n\n      try {\n        await pdfGenerator.generateReport(pdfOutputPath);\n        console.log('âœ… PDF generation completed!');\n      } catch (genError) {\n        console.error('âŒ PDF generation threw error:', genError.message);\n        console.error('   Stack:', genError.stack);\n        throw genError;\n      }\n\n      // Verify file was created\n      if (!fs.existsSync(pdfOutputPath)) {\n        throw new Error('PDF file was not created at expected path: ' + pdfOutputPath);\n      }\n\n      console.log('âœ… PDF file verified at:', pdfOutputPath);\n      console.log('ğŸ“„ File:', pdfFilename);\n      console.log('ğŸ“Š Size:', (fs.statSync(pdfOutputPath).size / 1024).toFixed(2), 'KB');\n\n      // Upload to Supabase Storage\n      try {\n        console.log('\\nâ˜ï¸  Uploading PDF to Supabase storage...');\n        const uploadResult = await SupabaseStorage.uploadFile(\n          pdfOutputPath,\n          'neurosense_bucketreports', // bucket name\n          `reports/${pdfFilename}` // path in bucket\n        );\n\n        // Verify upload was successful and URL is valid\n        if (uploadResult && uploadResult.url) {\n          pdfUrl = uploadResult.url;\n          console.log('âœ… PDF uploaded to Supabase successfully');\n          console.log('ğŸ”— Supabase URL:', pdfUrl);\n\n          // Delete local file after successful Supabase upload\n          try {\n            fs.unlinkSync(pdfOutputPath);\n            console.log('ğŸ—‘ï¸  Local PDF file deleted after successful upload');\n          } catch (deleteError) {\n            console.warn('âš ï¸  Could not delete local PDF file:', deleteError.message);\n          }\n        } else {\n          throw new Error('Supabase upload returned invalid result');\n        }\n      } catch (supabaseError) {\n        console.error('âš ï¸  Supabase upload failed, using local storage');\n        console.error('   Error message:', supabaseError.message);\n        console.error('   Error stack:', supabaseError.stack);\n        console.error('   Full error:', JSON.stringify(supabaseError, null, 2));\n        // Fallback to local storage\n        pdfUrl = `/uploads/${pdfFilename}`;\n        console.log('ğŸ“ Using local file as fallback:', pdfUrl);\n      }\n\n    } catch (pdfError) {\n      console.error('\\nâŒ === PDF GENERATION FAILED ===');\n      console.error('Error message:', pdfError.message);\n      console.error('Error stack:', pdfError.stack);\n      console.error('Full error:', pdfError);\n      console.error('=================================\\n');\n\n      // Set pdfUrl to null so frontend knows PDF failed\n      pdfUrl = null;\n\n      // Don't fail the whole request if PDF fails - processing still succeeded\n      console.log('âš ï¸ Continuing without PDF - processing succeeded');\n    }\n\n    // Clean up uploaded files\n    try {\n      fs.unlinkSync(eyesOpenFile.path);\n      fs.unlinkSync(eyesClosedFile.path);\n      console.log('\\nğŸ—‘ï¸  Temporary files cleaned up');\n    } catch (cleanupError) {\n      console.error('âš ï¸  Error cleaning up files:', cleanupError.message);\n    }\n\n    console.log('\\nğŸ === QEEG Processing Completed ===\\n');\n\n    // Final check for PDF URL\n    if (!pdfUrl) {\n      console.warn('âš ï¸âš ï¸âš ï¸ WARNING: No PDF URL available in response!');\n      console.warn('   pdfFilename was:', pdfFilename || 'NOT SET');\n      console.warn('   This means PDF generation completely failed');\n    } else {\n      console.log('âœ… PDF URL ready:', pdfUrl);\n      console.log('   Type:', pdfUrl.startsWith('http') ? 'Supabase' : 'Local');\n    }\n\n    // Send response\n    res.json({\n      success: true,\n      data: {\n        patientId,\n        patientName,\n        clinicName,\n        processedAt: new Date().toISOString(),\n        dataType: dataType, // Add data type (raw or zscore)\n        results: results.parameters,\n        overallScore: results.overallScore,\n        maxScore: 21,\n        pdfUrl: pdfUrl,\n        pdfFilename: pdfFilename\n      }\n    });\n\n  } catch (error) {\n    console.error('\\nâŒ === QEEG Processing Failed ===');\n    console.error('Error:', error.message);\n    console.error('Error Code:', error.code || 'UNKNOWN');\n    console.error('Stack:', error.stack);\n\n    // Clean up files on error\n    if (eyesOpenFile && fs.existsSync(eyesOpenFile.path)) {\n      try {\n        fs.unlinkSync(eyesOpenFile.path);\n      } catch (e) {\n        console.error('Error deleting Eyes Open file:', e.message);\n      }\n    }\n    if (eyesClosedFile && fs.existsSync(eyesClosedFile.path)) {\n      try {\n        fs.unlinkSync(eyesClosedFile.path);\n      } catch (e) {\n        console.error('Error deleting Eyes Closed file:', e.message);\n      }\n    }\n\n    // Categorize errors for better user feedback\n    let statusCode = 500;\n    let userMessage = error.message;\n\n    switch (error.code) {\n      case 'MISSING_API_KEY':\n      case 'INVALID_API_KEY':\n      case 'INVALID_API_KEY_FORMAT':\n      case 'API_CONNECTION_FAILED':\n        statusCode = 503; // Service Unavailable\n        userMessage = 'System configuration error: OpenAI API key not properly configured. Please contact support.';\n        break;\n\n      case 'PDF_EXTRACTION_FAILED':\n        statusCode = 422; // Unprocessable Entity\n        userMessage = 'Failed to extract QEEG data from PDF. Please ensure the PDF contains valid QEEG tables with absolute and relative power values.';\n        break;\n\n      default:\n        userMessage = error.message || 'Failed to process QEEG files';\n    }\n\n    res.status(statusCode).json({\n      error: true,\n      message: userMessage,\n      code: error.code || 'UNKNOWN_ERROR',\n      technicalDetails: process.env.NODE_ENV === 'development' ? {\n        originalMessage: error.message,\n        stack: error.stack,\n        condition: error.condition\n      } : undefined\n    });\n  }\n});\n\n/**\n * POST /api/qeeg/generate-pdf\n * Generate PDF report from algorithm results\n */\nrouter.post('/generate-pdf', async (req, res) => {\n  try {\n    console.log('\\nğŸ“„ === PDF Report Generation Started ===\\n');\n\n    const { patientData, algorithmResults, qeegData } = req.body;\n\n    // Validate input\n    if (!patientData || !algorithmResults || !qeegData) {\n      return res.status(400).json({\n        error: true,\n        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'\n      });\n    }\n\n    console.log('ğŸ‘¤ Patient:', patientData.name);\n    console.log('ğŸ“Š Parameters:', algorithmResults.parameters?.length);\n\n    // === USE GEMINI PDF GENERATOR (if available) ===\n    let generator;\n    if (GeminiPdfGenerator) {\n      console.log('ğŸ¤– Using Gemini AI PDF Generator (Google Gemini + PDFKit)');\n      generator = new GeminiPdfGenerator(patientData, algorithmResults, qeegData);\n    } else if (EnhancedAIPdfGenerator) {\n      console.log('ğŸ¤– Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');\n      generator = new EnhancedAIPdfGenerator(patientData, algorithmResults, qeegData);\n    } else {\n      console.log('ğŸ“„ Using Standard PDF Generator (Basic fallback)');\n      generator = new PDFReportGenerator(patientData, algorithmResults, qeegData);\n    }\n\n    // Create output filename\n    const timestamp = Date.now();\n    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n    const filename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n    const outputPath = path.join(__dirname, '../uploads', filename);\n\n    console.log('ğŸ“ Generating AI-powered PDF to:', filename);\n\n    // Generate the PDF with AI insights\n    const pdfPath = await generator.generateReport(outputPath);\n\n    console.log('\\nâœ… PDF Report Generated Successfully!');\n    console.log('ğŸ“„ File:', filename);\n    console.log('ğŸ“Š Size:', (fs.statSync(pdfPath).size / 1024).toFixed(2), 'KB');\n\n    // Upload to Supabase Storage - TEMPORARILY DISABLED\n    let supabaseUrl = null;\n    let supabasePath = null;\n    let uploadError = null;\n\n    // DISABLE SUPABASE UPLOAD FOR NOW - USE LOCAL STORAGE ONLY\n    console.log('\\nğŸ“ Using local storage (Supabase upload disabled)');\n    uploadError = 'Supabase upload disabled - using local storage';\n\n    /* COMMENTED OUT - Enable when Supabase is configured properly\n    try {\n      console.log('\\nâ˜ï¸  Uploading PDF to Supabase storage...');\n      const uploadResult = await SupabaseStorage.uploadFile(\n        pdfPath,\n        'patient-reports', // bucket name\n        `reports/${filename}` // path in bucket\n      );\n\n      // Verify upload was successful and URL is valid\n      if (uploadResult && uploadResult.url) {\n        supabaseUrl = uploadResult.url;\n        supabasePath = uploadResult.path;\n\n        console.log('âœ… PDF uploaded to Supabase successfully');\n        console.log('ğŸ”— Supabase URL:', supabaseUrl);\n\n        // Only delete local file after SUCCESSFUL Supabase upload\n        try {\n          fs.unlinkSync(pdfPath);\n          console.log('ğŸ—‘ï¸  Local PDF file deleted after successful upload');\n        } catch (deleteError) {\n          console.warn('âš ï¸  Could not delete local PDF file:', deleteError.message);\n        }\n      } else {\n        throw new Error('Supabase upload returned invalid result');\n      }\n\n    } catch (error) {\n      console.error('âš ï¸  Supabase upload failed, using local storage:', error.message);\n      uploadError = error.message;\n      // Keep local file as fallback - DO NOT DELETE\n      console.log('ğŸ“ Using local file as fallback');\n    }\n    */\n\n    console.log('\\nğŸ === PDF Generation Completed ===\\n');\n\n    // Return PDF info - prioritize Supabase URL\n    res.json({\n      success: true,\n      data: {\n        filename: filename,\n        path: supabasePath || `/uploads/${filename}`,\n        url: supabaseUrl || `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n        size: fs.existsSync(pdfPath) ? fs.statSync(pdfPath).size : 0,\n        generatedAt: new Date().toISOString(),\n        storage: supabaseUrl ? 'supabase' : 'local',\n        uploadError: uploadError\n      }\n    });\n\n  } catch (error) {\n    console.error('\\nâŒ === PDF Generation Failed ===');\n    console.error('Error:', error.message);\n    console.error('Stack:', error.stack);\n\n    res.status(500).json({\n      error: true,\n      message: error.message || 'Failed to generate PDF report',\n      details: process.env.NODE_ENV === 'development' ? error.stack : undefined\n    });\n  }\n});\n\n/**\n * POST /api/qeeg/generate-sample-pdf\n * Generate a sample PDF report for testing\n */\nrouter.post('/generate-sample-pdf', async (req, res) => {\n  try {\n    console.log('\\nğŸ“„ === Sample PDF Generation Started ===\\n');\n\n    const pdfPath = await PDFReportGenerator.generateSampleReport();\n\n    console.log('âœ… Sample PDF Generated!');\n    console.log('ğŸ“„ Path:', pdfPath);\n\n    const filename = path.basename(pdfPath);\n\n    res.json({\n      success: true,\n      data: {\n        filename: filename,\n        path: `/uploads/${filename}`,\n        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n        size: fs.statSync(pdfPath).size\n      }\n    });\n\n  } catch (error) {\n    console.error('âŒ Sample PDF generation failed:', error);\n\n    res.status(500).json({\n      error: true,\n      message: error.message\n    });\n  }\n});\n\n/**\n * POST /api/qeeg/generate-ai-pdf\n * Generate AI-powered PDF report with enhanced design and content\n */\nrouter.post('/generate-ai-pdf', async (req, res) => {\n  try {\n    console.log('\\nğŸ¤– === AI PDF Report Generation Started ===\\n');\n\n    const { patientData, algorithmResults, qeegData } = req.body;\n\n    // Validate input\n    if (!patientData || !algorithmResults || !qeegData) {\n      return res.status(400).json({\n        error: true,\n        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'\n      });\n    }\n\n    console.log('ğŸ‘¤ Patient:', patientData.name);\n    console.log('ğŸ“Š Parameters:', algorithmResults.parameters?.length);\n    console.log('ğŸ¯ Using AI-powered generation with enhanced prompt');\n\n    // Generate AI PDF\n    const generator = new AIPdfGenerator(patientData, algorithmResults, qeegData);\n\n    // Create output filename\n    const timestamp = Date.now();\n    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n    const filename = `ai-neurosense-report-${sanitizedName}-${timestamp}.pdf`;\n    const outputPath = path.join(__dirname, '../uploads', filename);\n\n    console.log('ğŸ“ Generating AI PDF to:', filename);\n\n    // Generate the PDF\n    const result = await generator.generateReport(outputPath);\n\n    console.log('\\nâœ… AI NeuroSense Report Generated Successfully!');\n    console.log('ğŸ“„ Text File:', path.basename(result.textOutputPath));\n    console.log('ğŸ“„ JSON File:', path.basename(result.outputPath));\n    console.log('ğŸ“Š Tokens Used:', result.tokensUsed);\n    console.log('ğŸ“ Content Length:', result.contentLength, 'characters');\n    console.log('\\nğŸ === AI PDF Generation Completed ===\\n');\n\n    // Return report info\n    res.json({\n      success: true,\n      data: {\n        textFile: {\n          filename: path.basename(result.textOutputPath),\n          path: `/uploads/${path.basename(result.textOutputPath)}`,\n          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.textOutputPath)}`,\n          type: 'Plain Text Report'\n        },\n        jsonFile: {\n          filename: path.basename(result.outputPath),\n          path: `/uploads/${path.basename(result.outputPath)}`,\n          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.outputPath)}`,\n          type: 'Structured Data (JSON)'\n        },\n        contentLength: result.contentLength,\n        tokensUsed: result.tokensUsed,\n        generatedAt: new Date().toISOString()\n      },\n      message: 'AI-powered NeuroSense report generated successfully. Text file contains formatted report ready for PDF conversion.'\n    });\n\n  } catch (error) {\n    console.error('\\nâŒ === AI PDF Generation Failed ===');\n    console.error('Error:', error.message);\n    console.error('Stack:', error.stack);\n\n    res.status(500).json({\n      error: true,\n      message: error.message || 'Failed to generate AI PDF report',\n      details: process.env.NODE_ENV === 'development' ? error.stack : undefined\n    });\n  }\n});\n\n/**\n * POST /api/qeeg/generate-ai-sample-pdf\n * Generate a sample AI-powered PDF report for testing\n */\nrouter.post('/generate-ai-sample-pdf', async (req, res) => {\n  try {\n    console.log('\\nğŸ¤– === Sample AI PDF Generation Started ===\\n');\n\n    const result = await AIPdfGenerator.generateSampleReport();\n\n    console.log('âœ… Sample AI PDF Generated!');\n    console.log('ğŸ“„ Path:', result.outputPath);\n\n    const filename = path.basename(result.outputPath);\n\n    res.json({\n      success: true,\n      data: {\n        filename: filename,\n        path: `/uploads/${filename}`,\n        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,\n        contentLength: result.contentLength,\n        tokensUsed: result.tokensUsed,\n        type: 'AI-Generated Sample (JSON format)'\n      }\n    });\n\n  } catch (error) {\n    console.error('âŒ Sample AI PDF generation failed:', error);\n\n    res.status(500).json({\n      error: true,\n      message: error.message\n    });\n  }\n});\n\n/**\n * GET /api/qeeg/supabase-pdfs\n * List all PDFs from Supabase bucket\n */\nrouter.get('/supabase-pdfs', async (req, res) => {\n  try {\n    console.log('ğŸ“‹ Fetching PDFs from Supabase bucket...');\n\n    const files = await SupabaseStorage.listFiles('neurosense_bucketreports', 'reports');\n\n    // Get public URLs for all files\n    const pdfs = files.map(file => {\n      const { createClient } = require('@supabase/supabase-js');\n      const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);\n      const { data: urlData } = supabase.storage\n        .from('neurosense_bucketreports')\n        .getPublicUrl(`reports/${file.name}`);\n\n      return {\n        name: file.name,\n        url: urlData.publicUrl,\n        created_at: file.created_at,\n        size: file.metadata?.size\n      };\n    });\n\n    console.log(`âœ… Found ${pdfs.length} PDFs in Supabase bucket`);\n\n    res.json({\n      success: true,\n      count: pdfs.length,\n      pdfs: pdfs\n    });\n\n  } catch (error) {\n    console.error('âŒ Error listing Supabase PDFs:', error);\n    res.status(500).json({\n      success: false,\n      error: error.message\n    });\n  }\n});\n\n/**\n * GET /api/qeeg/test\n * Test endpoint to verify API is working\n */\nrouter.get('/test', (req, res) => {\n  res.json({\n    success: true,\n    message: 'QEEG Processing API is working',\n    endpoints: {\n      process: 'POST /api/qeeg/process - Upload and process QEEG files',\n      generatePdf: 'POST /api/qeeg/generate-pdf - Generate PDF report from results (PDFKit)',\n      generateSamplePdf: 'POST /api/qeeg/generate-sample-pdf - Generate sample PDF report (PDFKit)',\n      generateAiPdf: 'POST /api/qeeg/generate-ai-pdf - Generate AI-powered PDF report (OpenAI)',\n      generateAiSamplePdf: 'POST /api/qeeg/generate-ai-sample-pdf - Generate AI sample PDF report (OpenAI)',\n      generateGeminiReport: 'POST /api/qeeg/generate-gemini-report - Generate AI report structure using Gemini',\n      supabasePdfs: 'GET /api/qeeg/supabase-pdfs - List all PDFs from Supabase bucket'\n    }\n  });\n});\n\n/**\n * POST /api/qeeg/generate-gemini-report\n * Generate AI-powered report structure using Google Gemini\n */\nrouter.post('/generate-gemini-report', async (req, res) => {\n  try {\n    console.log('\\nğŸ¤– === Gemini AI Report Generation Started ===\\n');\n\n    if (!GeminiService) {\n      return res.status(503).json({\n        error: true,\n        message: 'Gemini AI service is not available. Please check server configuration.'\n      });\n    }\n\n    const { algorithmResults } = req.body;\n\n    // Validate input\n    if (!algorithmResults || !algorithmResults.parameters) {\n      return res.status(400).json({\n        error: true,\n        message: 'Missing required data: algorithmResults with parameters array is required'\n      });\n    }\n\n    console.log('ğŸ“Š Processing', algorithmResults.parameters.length, 'brain parameters');\n\n    // Transform algorithm results to the format expected by Gemini\n    const brainParameters = {\n      Cognition: null,\n      Stress: null,\n      FocusAndAttention: null,\n      BurnoutAndFatigue: null,\n      EmotionalRegulation: null,\n      Learning: null,\n      Creativity: null\n    };\n\n    // Map the parameters from algorithm results\n    algorithmResults.parameters.forEach(param => {\n      const paramName = param.name.replace(/\\s+/g, '');\n      if (brainParameters.hasOwnProperty(paramName)) {\n        brainParameters[paramName] = {\n          score: param.score,\n          bucket: param.bucket,\n          subparameters: param.subParameters || []\n        };\n      }\n    });\n\n    console.log('ğŸ§  Brain Parameters prepared for Gemini');\n\n    // Generate report using Gemini AI\n    const result = await GeminiService.generateBrainPerformanceReport(brainParameters);\n\n    if (!result.success) {\n      return res.status(500).json({\n        error: true,\n        message: 'Failed to generate report with Gemini AI',\n        details: result.error\n      });\n    }\n\n    console.log('âœ… Gemini AI report generated successfully');\n\n    res.json({\n      success: true,\n      message: 'AI-powered report structure generated successfully',\n      reportData: result.data,\n      rawResponse: result.rawResponse\n    });\n\n  } catch (error) {\n    console.error('âŒ Error generating Gemini report:', error);\n    res.status(500).json({\n      error: true,\n      message: 'Internal server error while generating Gemini report',\n      details: error.message\n    });\n  }\n});\n\nmodule.exports = router;\n\n","numLines":976,"startLine":1,"totalLines":976}}}
{"parentUuid":"15e2bab9-54c9-4a21-9121-ee56ae3bc573","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_018wRgz4sCUfJC5uTLYrXKLx","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the Z-score calculator and look for any other potential sources of non-determinism:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5429,"cache_creation_input_tokens":37399,"cache_read_input_tokens":9352,"cache_creation":{"ephemeral_5m_input_tokens":37399,"ephemeral_1h_input_tokens":0},"output_tokens":190,"service_tier":"standard"}},"requestId":"req_011CVjNEpyAbuL8zEoY6BRmK","type":"assistant","uuid":"9691e097-a718-44fe-92ae-314547234ef1","timestamp":"2025-12-03T07:34:23.227Z"}
{"parentUuid":"9691e097-a718-44fe-92ae-314547234ef1","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_018wRgz4sCUfJC5uTLYrXKLx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TqCSmAnPX1FqzrsPhTsN7c","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\services\\zscoreCalculator.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5429,"cache_creation_input_tokens":37399,"cache_read_input_tokens":9352,"cache_creation":{"ephemeral_5m_input_tokens":37399,"ephemeral_1h_input_tokens":0},"output_tokens":190,"service_tier":"standard"}},"requestId":"req_011CVjNEpyAbuL8zEoY6BRmK","type":"assistant","uuid":"2d3bda57-2f60-45d7-9869-a39241f8cd0f","timestamp":"2025-12-03T07:34:24.287Z"}
{"parentUuid":"2d3bda57-2f60-45d7-9869-a39241f8cd0f","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_018wRgz4sCUfJC5uTLYrXKLx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LnWNX7dd9poUqSvY97xeTQ","name":"Grep","input":{"pattern":"Math\\.random|Date\\.now|new Date\\(\\)","path":"D:\\Todays\\Neuro360\\server","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5429,"cache_creation_input_tokens":37399,"cache_read_input_tokens":9352,"cache_creation":{"ephemeral_5m_input_tokens":37399,"ephemeral_1h_input_tokens":0},"output_tokens":190,"service_tier":"standard"}},"requestId":"req_011CVjNEpyAbuL8zEoY6BRmK","type":"assistant","uuid":"7a642cdf-bf6f-414c-96a4-eecbc5064721","timestamp":"2025-12-03T07:34:25.399Z"}
{"parentUuid":"7a642cdf-bf6f-414c-96a4-eecbc5064721","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LnWNX7dd9poUqSvY97xeTQ","type":"tool_result","content":"D:\\Todays\\Neuro360\\server\\index.js:65:    timestamp: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:61:    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:347:      const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:488:        processedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:590:    const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:659:        generatedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:739:    const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:774:        generatedAt: new Date().toISOString()\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:259:          generatedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:304:      dateOfRecording: new Date().toISOString().split('T')[0],\r\nD:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js:241:       .text(new Date().toLocaleDateString(), 450, 30);\r\nD:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js:272:    doc.text(`Report Date: ${new Date().toLocaleDateString()}`, 300, y + 35);\r\nD:\\Todays\\Neuro360\\server\\services\\pdfGenerator.js:110:      dateOfRecording: new Date().toISOString().split('T')[0],\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"4bdbd9e0-0ed6-4ff7-a75c-fab5dfd32e05","timestamp":"2025-12-03T07:34:29.093Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"D:\\Todays\\Neuro360\\server\\index.js:65:    timestamp: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:61:    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:347:      const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:488:        processedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:590:    const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:659:        generatedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:739:    const timestamp = Date.now();\r\nD:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js:774:        generatedAt: new Date().toISOString()\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:259:          generatedAt: new Date().toISOString(),\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:304:      dateOfRecording: new Date().toISOString().split('T')[0],\r\nD:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js:241:       .text(new Date().toLocaleDateString(), 450, 30);\r\nD:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js:272:    doc.text(`Report Date: ${new Date().toLocaleDateString()}`, 300, y + 35);\r\nD:\\Todays\\Neuro360\\server\\services\\pdfGenerator.js:110:      dateOfRecording: new Date().toISOString().split('T')[0],","numLines":13,"appliedLimit":20}}
{"parentUuid":"4bdbd9e0-0ed6-4ff7-a75c-fab5dfd32e05","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TqCSmAnPX1FqzrsPhTsN7c","type":"tool_result","content":"     1â†’/**\n     2â†’ * QEEG Z-Score Algorithm Calculator\n     3â†’ * Calculates 7 brain health parameters using Z-score data instead of raw power values\n     4â†’ * Z-scores represent standard deviations from age-matched norms\n     5â†’ * Each parameter has 3 sub-metrics, scored 0-3, classified as Low/Medium/High\n     6â†’ */\n     7â†’\n     8â†’const THRESHOLDS = require('./zscoreThresholds');\n     9â†’\n    10â†’class ZScoreCalculator {\n    11â†’  constructor(qeegData) {\n    12â†’    this.data = qeegData;\n    13â†’    this.results = {\n    14â†’      parameters: [],\n    15â†’      rawCalculations: {},\n    16â†’      overallScore: 0\n    17â†’    };\n    18â†’  }\n    19â†’\n    20â†’  /**\n    21â†’   * Main calculation method - calculates all 7 parameters\n    22â†’   */\n    23â†’  calculate() {\n    24â†’    const parameters = [\n    25â†’      this.calculateCognition(),\n    26â†’      this.calculateStress(),\n    27â†’      this.calculateFocusAttention(),\n    28â†’      this.calculateBurnoutFatigue(),\n    29â†’      this.calculateEmotionalRegulation(),\n    30â†’      this.calculateLearning(),\n    31â†’      this.calculateCreativity()\n    32â†’    ];\n    33â†’\n    34â†’    this.results.parameters = parameters;\n    35â†’    this.results.overallScore = parameters.reduce((sum, p) => sum + p.score, 0);\n    36â†’\n    37â†’    return this.results;\n    38â†’  }\n    39â†’\n    40â†’  // ==================== HELPER METHODS ====================\n    41â†’\n    42â†’  /**\n    43â†’   * Get Z-score value from QEEG data\n    44â†’   * @param {string} condition - 'EC' (Eyes Closed) or 'EO' (Eyes Open)\n    45â†’   * @param {string} powerType - 'absolute' or 'relative'\n    46â†’   * @param {string} channel - e.g., 'Fz', 'Cz', 'Pz'\n    47â†’   * @param {string} band - e.g., 'Theta', 'Alpha', 'Beta', 'HiBeta', 'Delta'\n    48â†’   */\n    49â†’  getZScore(condition, powerType, channel, band) {\n    50â†’    try {\n    51â†’      // Z-scores are stored in data[condition].zscores[powerType][channel][band]\n    52â†’      return this.data[condition].zscores[powerType][channel][band];\n    53â†’    } catch (error) {\n    54â†’      console.error(`Error getting Z-score: ${condition}.zscores.${powerType}.${channel}.${band}`);\n    55â†’      return null;\n    56â†’    }\n    57â†’  }\n    58â†’\n    59â†’  /**\n    60â†’   * Check if Z-score is within normal range\n    61â†’   * @param {number} zscore - The Z-score value\n    62â†’   * @param {number} threshold - Threshold value (typically 1.0 or 2.0)\n    63â†’   * @param {string} comparison - 'within', 'above', 'below'\n    64â†’   * @returns {number} 1 if passes, 0 if fails\n    65â†’   */\n    66â†’  scoreZMetric(zscore, threshold, comparison = 'within') {\n    67â†’    if (zscore === null || zscore === undefined) return 0;\n    68â†’\n    69â†’    if (comparison === 'within') {\n    70â†’      // Check if Z-score is within Â±threshold (normal range)\n    71â†’      return Math.abs(zscore) <= threshold ? 1 : 0;\n    72â†’    } else if (comparison === 'below') {\n    73â†’      // Check if Z-score is below threshold (not elevated)\n    74â†’      return zscore < threshold ? 1 : 0;\n    75â†’    } else if (comparison === 'above') {\n    76â†’      // Check if Z-score is above threshold (not reduced)\n    77â†’      return zscore > threshold ? 1 : 0;\n    78â†’    }\n    79â†’    return 0;\n    80â†’  }\n    81â†’\n    82â†’  /**\n    83â†’   * Classify score to bucket (Low/Medium/High)\n    84â†’   */\n    85â†’  classifyScore(score) {\n    86â†’    if (score <= 1) return 'Low';\n    87â†’    if (score === 2) return 'Medium';\n    88â†’    return 'High';\n    89â†’  }\n    90â†’\n    91â†’  // ==================== INDIVIDUAL METRICS ====================\n    92â†’\n    93â†’  /**\n    94â†’   * COGNITION METRICS\n    95â†’   */\n    96â†’\n    97â†’  /**\n    98â†’   * Metric 1: Focus Score (Theta & Beta Z-scores)\n    99â†’   * Eyes Open, Check Fz & Cz Theta and Beta Z-scores\n   100â†’   * Pass if Theta Z-score < 1.0 AND Beta Z-score > -1.0\n   101â†’   */\n   102â†’  calculateFocusScore() {\n   103â†’    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n   104â†’    const fzBeta = this.getZScore('EO', 'absolute', 'Fz', 'Beta');\n   105â†’    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n   106â†’    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n   107â†’\n   108â†’    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null) {\n   109â†’      return {\n   110â†’        name: 'Focus Score',\n   111â†’        value: null,\n   112â†’        score: 0,\n   113â†’        interpretation: 'Insufficient data',\n   114â†’        details: 'Missing Z-score data for frontal regions'\n   115â†’      };\n   116â†’    }\n   117â†’\n   118â†’    // Pass if all conditions met\n   119â†’    const fzPass = fzTheta < THRESHOLDS.COGNITION.FOCUS_SCORE.THETA_ELEVATED &&\n   120â†’                   fzBeta > THRESHOLDS.COGNITION.FOCUS_SCORE.BETA_REDUCED;\n   121â†’    const czPass = czTheta < THRESHOLDS.COGNITION.FOCUS_SCORE.THETA_ELEVATED &&\n   122â†’                   czBeta > THRESHOLDS.COGNITION.FOCUS_SCORE.BETA_REDUCED;\n   123â†’\n   124â†’    const score = (fzPass && czPass) ? 1 : 0;\n   125â†’\n   126â†’    return {\n   127â†’      name: 'Focus Score',\n   128â†’      value: { fzTheta, fzBeta, czTheta, czBeta },\n   129â†’      score,\n   130â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   131â†’      details: `Fz: Theta Z=${fzTheta.toFixed(2)}, Beta Z=${fzBeta.toFixed(2)} | Cz: Theta Z=${czTheta.toFixed(2)}, Beta Z=${czBeta.toFixed(2)}`\n   132â†’    };\n   133â†’  }\n   134â†’\n   135â†’  /**\n   136â†’   * Metric 2: Alpha Peak\n   137â†’   * Eyes Closed, Alpha Peak Frequency Z-score\n   138â†’   * Pass if Z-score within Â±1.0\n   139â†’   */\n   140â†’  calculateAlphaPeak() {\n   141â†’    const alphaPeakZscore = this.data.EC?.special?.alphaPeakZscore || 0.0;\n   142â†’\n   143â†’    const score = this.scoreZMetric(alphaPeakZscore, THRESHOLDS.COGNITION.ALPHA_PEAK.NORMAL_RANGE, 'within');\n   144â†’\n   145â†’    return {\n   146â†’      name: 'Alpha Peak',\n   147â†’      value: alphaPeakZscore,\n   148â†’      score,\n   149â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   150â†’      details: `Alpha Peak Z-score: ${alphaPeakZscore.toFixed(2)} (within Â±1.0 is normal)`\n   151â†’    };\n   152â†’  }\n   153â†’\n   154â†’  /**\n   155â†’   * Metric 3: Alpha/Theta Balance\n   156â†’   * Eyes Closed, Check if Alpha Z-score > -1.0 and Theta Z-score < 1.0 across regions\n   157â†’   * Pass if all regions meet criteria\n   158â†’   */\n   159â†’  calculateAlphaThetaBalance() {\n   160â†’    const fzAlpha = this.getZScore('EC', 'absolute', 'Fz', 'Alpha');\n   161â†’    const fzTheta = this.getZScore('EC', 'absolute', 'Fz', 'Theta');\n   162â†’    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n   163â†’    const czTheta = this.getZScore('EC', 'absolute', 'Cz', 'Theta');\n   164â†’    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n   165â†’    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n   166â†’\n   167â†’    if (fzAlpha == null || fzTheta == null || czAlpha == null || czTheta == null || pzAlpha == null || pzTheta == null) {\n   168â†’      return {\n   169â†’        name: 'Alpha/Theta Balance',\n   170â†’        value: null,\n   171â†’        score: 0,\n   172â†’        interpretation: 'Insufficient data',\n   173â†’        details: 'Missing Z-score data'\n   174â†’      };\n   175â†’    }\n   176â†’\n   177â†’    // Check if all regions pass\n   178â†’    const allRegionsPass =\n   179â†’      fzAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n   180â†’      fzTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH &&\n   181â†’      czAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n   182â†’      czTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH &&\n   183â†’      pzAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n   184â†’      pzTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH;\n   185â†’\n   186â†’    const score = allRegionsPass ? 1 : 0;\n   187â†’\n   188â†’    return {\n   189â†’      name: 'Alpha/Theta Balance',\n   190â†’      value: { fzAlpha, fzTheta, czAlpha, czTheta, pzAlpha, pzTheta },\n   191â†’      score,\n   192â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   193â†’      details: `Alpha Z-scores: Fz=${fzAlpha.toFixed(2)}, Cz=${czAlpha.toFixed(2)}, Pz=${pzAlpha.toFixed(2)} | Theta Z-scores: Fz=${fzTheta.toFixed(2)}, Cz=${czTheta.toFixed(2)}, Pz=${pzTheta.toFixed(2)}`\n   194â†’    };\n   195â†’  }\n   196â†’\n   197â†’  /**\n   198â†’   * STRESS METRICS\n   199â†’   */\n   200â†’\n   201â†’  /**\n   202â†’   * Metric 1: Arousal Score (HiBeta Z-scores)\n   203â†’   * Eyes Open, HiBeta Z-scores across Fz, Cz, Pz\n   204â†’   * Pass if all < 1.0 (not elevated)\n   205â†’   */\n   206â†’  calculateArousalScore() {\n   207â†’    const fzHiBeta = this.getZScore('EO', 'absolute', 'Fz', 'HiBeta');\n   208â†’    const czHiBeta = this.getZScore('EO', 'absolute', 'Cz', 'HiBeta');\n   209â†’    const pzHiBeta = this.getZScore('EO', 'absolute', 'Pz', 'HiBeta');\n   210â†’\n   211â†’    if (fzHiBeta == null || czHiBeta == null || pzHiBeta == null) {\n   212â†’      return {\n   213â†’        name: 'Arousal Score',\n   214â†’        value: null,\n   215â†’        score: 0,\n   216â†’        interpretation: 'Insufficient data',\n   217â†’        details: 'Missing HiBeta Z-score data'\n   218â†’      };\n   219â†’    }\n   220â†’\n   221â†’    const allWithinRange =\n   222â†’      fzHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED &&\n   223â†’      czHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED &&\n   224â†’      pzHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED;\n   225â†’\n   226â†’    const score = allWithinRange ? 1 : 0;\n   227â†’\n   228â†’    return {\n   229â†’      name: 'Arousal Score',\n   230â†’      value: { fzHiBeta, czHiBeta, pzHiBeta },\n   231â†’      score,\n   232â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   233â†’      details: `HiBeta Z-scores: Fz=${fzHiBeta.toFixed(2)}, Cz=${czHiBeta.toFixed(2)}, Pz=${pzHiBeta.toFixed(2)} (< 1.0 is normal)`\n   234â†’    };\n   235â†’  }\n   236â†’\n   237â†’  /**\n   238â†’   * Metric 2: Relaxation Score (Posterior Theta)\n   239â†’   * Eyes Closed, Pz Theta Z-score\n   240â†’   * Pass if > -1.0 (not reduced)\n   241â†’   */\n   242â†’  calculateRelaxationScore() {\n   243â†’    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n   244â†’\n   245â†’    if (pzTheta == null) {\n   246â†’      return {\n   247â†’        name: 'Relaxation Score',\n   248â†’        value: null,\n   249â†’        score: 0,\n   250â†’        interpretation: 'Insufficient data',\n   251â†’        details: 'Missing Pz Theta Z-score'\n   252â†’      };\n   253â†’    }\n   254â†’\n   255â†’    const score = this.scoreZMetric(pzTheta, THRESHOLDS.STRESS.RELAXATION_SCORE.THETA_LOW, 'above');\n   256â†’\n   257â†’    return {\n   258â†’      name: 'Relaxation Score',\n   259â†’      value: pzTheta,\n   260â†’      score,\n   261â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   262â†’      details: `Pz Theta Z-score: ${pzTheta.toFixed(2)} (> -1.0 is normal)`\n   263â†’    };\n   264â†’  }\n   265â†’\n   266â†’  /**\n   267â†’   * Metric 3: Regeneration (Posterior Alpha)\n   268â†’   * Eyes Closed, Pz Alpha Z-score\n   269â†’   * Pass if > -1.0 (not reduced)\n   270â†’   */\n   271â†’  calculateRegeneration() {\n   272â†’    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n   273â†’\n   274â†’    if (pzAlpha == null) {\n   275â†’      return {\n   276â†’        name: 'Regeneration',\n   277â†’        value: null,\n   278â†’        score: 0,\n   279â†’        interpretation: 'Insufficient data',\n   280â†’        details: 'Missing Pz Alpha Z-score'\n   281â†’      };\n   282â†’    }\n   283â†’\n   284â†’    const score = this.scoreZMetric(pzAlpha, THRESHOLDS.STRESS.REGENERATION.ALPHA_LOW, 'above');\n   285â†’\n   286â†’    return {\n   287â†’      name: 'Regeneration',\n   288â†’      value: pzAlpha,\n   289â†’      score,\n   290â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   291â†’      details: `Pz Alpha Z-score: ${pzAlpha.toFixed(2)} (> -1.0 is normal)`\n   292â†’    };\n   293â†’  }\n   294â†’\n   295â†’  /**\n   296â†’   * FOCUS AND ATTENTION METRICS\n   297â†’   */\n   298â†’\n   299â†’  /**\n   300â†’   * Metric 1: Focus Theta (Frontal Theta)\n   301â†’   * Eyes Open, Fz Theta Z-score\n   302â†’   * Pass if < 1.0 (not elevated)\n   303â†’   */\n   304â†’  calculateFocusTheta() {\n   305â†’    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n   306â†’\n   307â†’    if (fzTheta == null) {\n   308â†’      return {\n   309â†’        name: 'Focus Theta',\n   310â†’        value: null,\n   311â†’        score: 0,\n   312â†’        interpretation: 'Insufficient data',\n   313â†’        details: 'Missing Fz Theta Z-score'\n   314â†’      };\n   315â†’    }\n   316â†’\n   317â†’    const score = this.scoreZMetric(fzTheta, THRESHOLDS.FOCUS_AND_ATTENTION.FOCUS_THETA.THETA_ELEVATED, 'below');\n   318â†’\n   319â†’    return {\n   320â†’      name: 'Focus Theta',\n   321â†’      value: fzTheta,\n   322â†’      score,\n   323â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   324â†’      details: `Fz Theta Z-score: ${fzTheta.toFixed(2)} (< 1.0 is normal)`\n   325â†’    };\n   326â†’  }\n   327â†’\n   328â†’  /**\n   329â†’   * Metric 2: Beta Coherence (C3-C4 Beta asymmetry)\n   330â†’   * Eyes Open, Check C3 and C4 Beta Z-score difference\n   331â†’   * Pass if |difference| < 1.0\n   332â†’   */\n   333â†’  calculateBetaCoherence() {\n   334â†’    const c3Beta = this.getZScore('EO', 'absolute', 'C3', 'Beta');\n   335â†’    const c4Beta = this.getZScore('EO', 'absolute', 'C4', 'Beta');\n   336â†’\n   337â†’    if (c3Beta == null || c4Beta == null) {\n   338â†’      return {\n   339â†’        name: 'Beta Coherence',\n   340â†’        value: null,\n   341â†’        score: 0,\n   342â†’        interpretation: 'Insufficient data',\n   343â†’        details: 'Missing C3/C4 Beta Z-scores'\n   344â†’      };\n   345â†’    }\n   346â†’\n   347â†’    const asymmetry = Math.abs(c3Beta - c4Beta);\n   348â†’    const score = asymmetry < THRESHOLDS.FOCUS_AND_ATTENTION.BETA_COHERENCE.ASYMMETRY_THRESHOLD ? 1 : 0;\n   349â†’\n   350â†’    return {\n   351â†’      name: 'Beta Coherence',\n   352â†’      value: { c3Beta, c4Beta, asymmetry },\n   353â†’      score,\n   354â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   355â†’      details: `C3 Beta Z=${c3Beta.toFixed(2)}, C4 Beta Z=${c4Beta.toFixed(2)}, Asymmetry=${asymmetry.toFixed(2)} (< 1.0 is normal)`\n   356â†’    };\n   357â†’  }\n   358â†’\n   359â†’  /**\n   360â†’   * Metric 3: Theta/Beta Ratio\n   361â†’   * Eyes Open, Cz Theta and Beta Z-scores\n   362â†’   * Pass if Theta < 1.0 and Beta > -1.0\n   363â†’   */\n   364â†’  calculateThetaBetaRatio() {\n   365â†’    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n   366â†’    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n   367â†’\n   368â†’    if (czTheta == null || czBeta == null) {\n   369â†’      return {\n   370â†’        name: 'Theta/Beta Ratio',\n   371â†’        value: null,\n   372â†’        score: 0,\n   373â†’        interpretation: 'Insufficient data',\n   374â†’        details: 'Missing Cz Theta/Beta Z-scores'\n   375â†’      };\n   376â†’    }\n   377â†’\n   378â†’    const score = (czTheta < THRESHOLDS.FOCUS_AND_ATTENTION.THETA_BETA_RATIO.THETA_HIGH &&\n   379â†’                   czBeta > THRESHOLDS.FOCUS_AND_ATTENTION.THETA_BETA_RATIO.BETA_LOW) ? 1 : 0;\n   380â†’\n   381â†’    return {\n   382â†’      name: 'Theta/Beta Ratio',\n   383â†’      value: { czTheta, czBeta },\n   384â†’      score,\n   385â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   386â†’      details: `Cz Theta Z=${czTheta.toFixed(2)} (< 1.0), Beta Z=${czBeta.toFixed(2)} (> -1.0)`\n   387â†’    };\n   388â†’  }\n   389â†’\n   390â†’  /**\n   391â†’   * BURNOUT AND FATIGUE METRICS\n   392â†’   */\n   393â†’\n   394â†’  /**\n   395â†’   * Metric 1: Delta Activity (Frontal Delta)\n   396â†’   * Eyes Open, Fz Delta Z-score\n   397â†’   * Pass if < 1.0 (not elevated)\n   398â†’   */\n   399â†’  calculateDeltaActivity() {\n   400â†’    const fzDelta = this.getZScore('EO', 'absolute', 'Fz', 'Delta');\n   401â†’\n   402â†’    if (fzDelta == null) {\n   403â†’      return {\n   404â†’        name: 'Delta Activity',\n   405â†’        value: null,\n   406â†’        score: 0,\n   407â†’        interpretation: 'Insufficient data',\n   408â†’        details: 'Missing Fz Delta Z-score'\n   409â†’      };\n   410â†’    }\n   411â†’\n   412â†’    const score = this.scoreZMetric(fzDelta, THRESHOLDS.BURNOUT_AND_FATIGUE.DELTA_ACTIVITY.DELTA_ELEVATED, 'below');\n   413â†’\n   414â†’    return {\n   415â†’      name: 'Delta Activity',\n   416â†’      value: fzDelta,\n   417â†’      score,\n   418â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   419â†’      details: `Fz Delta Z-score: ${fzDelta.toFixed(2)} (< 1.0 is normal)`\n   420â†’    };\n   421â†’  }\n   422â†’\n   423â†’  /**\n   424â†’   * Metric 2: Theta Dominance\n   425â†’   * Eyes Open, Average Theta Z-score across regions\n   426â†’   * Pass if average < 1.0\n   427â†’   */\n   428â†’  calculateThetaDominance() {\n   429â†’    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n   430â†’    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n   431â†’    const pzTheta = this.getZScore('EO', 'absolute', 'Pz', 'Theta');\n   432â†’\n   433â†’    if (fzTheta == null || czTheta == null || pzTheta == null) {\n   434â†’      return {\n   435â†’        name: 'Theta Dominance',\n   436â†’        value: null,\n   437â†’        score: 0,\n   438â†’        interpretation: 'Insufficient data',\n   439â†’        details: 'Missing Theta Z-scores'\n   440â†’      };\n   441â†’    }\n   442â†’\n   443â†’    const avgTheta = (fzTheta + czTheta + pzTheta) / 3;\n   444â†’    const score = avgTheta < THRESHOLDS.BURNOUT_AND_FATIGUE.THETA_DOMINANCE.THETA_EXCESSIVE ? 1 : 0;\n   445â†’\n   446â†’    return {\n   447â†’      name: 'Theta Dominance',\n   448â†’      value: avgTheta,\n   449â†’      score,\n   450â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   451â†’      details: `Average Theta Z-score: ${avgTheta.toFixed(2)} (< 1.0 is normal)`\n   452â†’    };\n   453â†’  }\n   454â†’\n   455â†’  /**\n   456â†’   * Metric 3: Alpha Suppression\n   457â†’   * Eyes Closed, Average Alpha Z-score\n   458â†’   * Pass if > -1.0 (not suppressed)\n   459â†’   */\n   460â†’  calculateAlphaSuppression() {\n   461â†’    const fzAlpha = this.getZScore('EC', 'absolute', 'Fz', 'Alpha');\n   462â†’    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n   463â†’    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n   464â†’\n   465â†’    if (fzAlpha == null || czAlpha == null || pzAlpha == null) {\n   466â†’      return {\n   467â†’        name: 'Alpha Suppression',\n   468â†’        value: null,\n   469â†’        score: 0,\n   470â†’        interpretation: 'Insufficient data',\n   471â†’        details: 'Missing Alpha Z-scores'\n   472â†’      };\n   473â†’    }\n   474â†’\n   475â†’    const avgAlpha = (fzAlpha + czAlpha + pzAlpha) / 3;\n   476â†’    const score = avgAlpha > THRESHOLDS.BURNOUT_AND_FATIGUE.ALPHA_SUPPRESSION.ALPHA_LOW ? 1 : 0;\n   477â†’\n   478â†’    return {\n   479â†’      name: 'Alpha Suppression',\n   480â†’      value: avgAlpha,\n   481â†’      score,\n   482â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   483â†’      details: `Average Alpha Z-score: ${avgAlpha.toFixed(2)} (> -1.0 is normal)`\n   484â†’    };\n   485â†’  }\n   486â†’\n   487â†’  /**\n   488â†’   * EMOTIONAL REGULATION METRICS\n   489â†’   */\n   490â†’\n   491â†’  /**\n   492â†’   * Metric 1: Right Frontal Alpha\n   493â†’   * Eyes Closed, F4 Alpha Z-score\n   494â†’   * Pass if > -1.0 (not reduced)\n   495â†’   */\n   496â†’  calculateRightFrontalAlpha() {\n   497â†’    const f4Alpha = this.getZScore('EC', 'absolute', 'F4', 'Alpha');\n   498â†’\n   499â†’    if (f4Alpha == null) {\n   500â†’      return {\n   501â†’        name: 'Right Frontal Alpha',\n   502â†’        value: null,\n   503â†’        score: 0,\n   504â†’        interpretation: 'Insufficient data',\n   505â†’        details: 'Missing F4 Alpha Z-score'\n   506â†’      };\n   507â†’    }\n   508â†’\n   509â†’    const score = this.scoreZMetric(f4Alpha, THRESHOLDS.EMOTIONAL_REGULATION.RIGHT_FRONTAL_ALPHA.ALPHA_LOW, 'above');\n   510â†’\n   511â†’    return {\n   512â†’      name: 'Right Frontal Alpha',\n   513â†’      value: f4Alpha,\n   514â†’      score,\n   515â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   516â†’      details: `F4 Alpha Z-score: ${f4Alpha.toFixed(2)} (> -1.0 is normal)`\n   517â†’    };\n   518â†’  }\n   519â†’\n   520â†’  /**\n   521â†’   * Metric 2: Alpha Asymmetry (F3-F4)\n   522â†’   * Eyes Closed, F3 and F4 Alpha Z-score difference\n   523â†’   * Pass if |difference| < 1.0\n   524â†’   */\n   525â†’  calculateAlphaAsymmetry() {\n   526â†’    const f3Alpha = this.getZScore('EC', 'absolute', 'F3', 'Alpha');\n   527â†’    const f4Alpha = this.getZScore('EC', 'absolute', 'F4', 'Alpha');\n   528â†’\n   529â†’    if (f3Alpha == null || f4Alpha == null) {\n   530â†’      return {\n   531â†’        name: 'Alpha Asymmetry',\n   532â†’        value: null,\n   533â†’        score: 0,\n   534â†’        interpretation: 'Insufficient data',\n   535â†’        details: 'Missing F3/F4 Alpha Z-scores'\n   536â†’      };\n   537â†’    }\n   538â†’\n   539â†’    const asymmetry = Math.abs(f3Alpha - f4Alpha);\n   540â†’    const score = asymmetry < THRESHOLDS.EMOTIONAL_REGULATION.ALPHA_ASYMMETRY.ASYMMETRY_THRESHOLD ? 1 : 0;\n   541â†’\n   542â†’    return {\n   543â†’      name: 'Alpha Asymmetry',\n   544â†’      value: { f3Alpha, f4Alpha, asymmetry },\n   545â†’      score,\n   546â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   547â†’      details: `F3 Alpha Z=${f3Alpha.toFixed(2)}, F4 Alpha Z=${f4Alpha.toFixed(2)}, Asymmetry=${asymmetry.toFixed(2)} (< 1.0 is normal)`\n   548â†’    };\n   549â†’  }\n   550â†’\n   551â†’  /**\n   552â†’   * Metric 3: Beta Stress Response\n   553â†’   * Eyes Open, Frontal Beta Z-scores\n   554â†’   * Pass if both F3 and F4 < 1.0\n   555â†’   */\n   556â†’  calculateBetaStress() {\n   557â†’    const f3Beta = this.getZScore('EO', 'absolute', 'F3', 'Beta');\n   558â†’    const f4Beta = this.getZScore('EO', 'absolute', 'F4', 'Beta');\n   559â†’\n   560â†’    if (f3Beta == null || f4Beta == null) {\n   561â†’      return {\n   562â†’        name: 'Beta Stress Response',\n   563â†’        value: null,\n   564â†’        score: 0,\n   565â†’        interpretation: 'Insufficient data',\n   566â†’        details: 'Missing F3/F4 Beta Z-scores'\n   567â†’      };\n   568â†’    }\n   569â†’\n   570â†’    const score = (f3Beta < THRESHOLDS.EMOTIONAL_REGULATION.BETA_STRESS.BETA_ELEVATED &&\n   571â†’                   f4Beta < THRESHOLDS.EMOTIONAL_REGULATION.BETA_STRESS.BETA_ELEVATED) ? 1 : 0;\n   572â†’\n   573â†’    return {\n   574â†’      name: 'Beta Stress Response',\n   575â†’      value: { f3Beta, f4Beta },\n   576â†’      score,\n   577â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   578â†’      details: `F3 Beta Z=${f3Beta.toFixed(2)}, F4 Beta Z=${f4Beta.toFixed(2)} (< 1.0 is normal)`\n   579â†’    };\n   580â†’  }\n   581â†’\n   582â†’  /**\n   583â†’   * LEARNING METRICS\n   584â†’   */\n   585â†’\n   586â†’  /**\n   587â†’   * Metric 1: Central Theta\n   588â†’   * Eyes Closed, Cz Theta Z-score\n   589â†’   * Pass if within Â±1.0\n   590â†’   */\n   591â†’  calculateCentralTheta() {\n   592â†’    const czTheta = this.getZScore('EC', 'absolute', 'Cz', 'Theta');\n   593â†’\n   594â†’    if (czTheta == null) {\n   595â†’      return {\n   596â†’        name: 'Central Theta',\n   597â†’        value: null,\n   598â†’        score: 0,\n   599â†’        interpretation: 'Insufficient data',\n   600â†’        details: 'Missing Cz Theta Z-score'\n   601â†’      };\n   602â†’    }\n   603â†’\n   604â†’    const score = this.scoreZMetric(czTheta, THRESHOLDS.LEARNING.CENTRAL_THETA.NORMAL_RANGE, 'within');\n   605â†’\n   606â†’    return {\n   607â†’      name: 'Central Theta',\n   608â†’      value: czTheta,\n   609â†’      score,\n   610â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   611â†’      details: `Cz Theta Z-score: ${czTheta.toFixed(2)} (within Â±1.0 is normal)`\n   612â†’    };\n   613â†’  }\n   614â†’\n   615â†’  /**\n   616â†’   * Metric 2: Alpha Modulation\n   617â†’   * Eyes Closed, Cz Alpha Z-score\n   618â†’   * Pass if within Â±1.0\n   619â†’   */\n   620â†’  calculateAlphaModulation() {\n   621â†’    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n   622â†’\n   623â†’    if (czAlpha == null) {\n   624â†’      return {\n   625â†’        name: 'Alpha Modulation',\n   626â†’        value: null,\n   627â†’        score: 0,\n   628â†’        interpretation: 'Insufficient data',\n   629â†’        details: 'Missing Cz Alpha Z-score'\n   630â†’      };\n   631â†’    }\n   632â†’\n   633â†’    const score = this.scoreZMetric(czAlpha, THRESHOLDS.LEARNING.ALPHA_MODULATION.NORMAL_RANGE, 'within');\n   634â†’\n   635â†’    return {\n   636â†’      name: 'Alpha Modulation',\n   637â†’      value: czAlpha,\n   638â†’      score,\n   639â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   640â†’      details: `Cz Alpha Z-score: ${czAlpha.toFixed(2)} (within Â±1.0 is normal)`\n   641â†’    };\n   642â†’  }\n   643â†’\n   644â†’  /**\n   645â†’   * Metric 3: Beta Engagement\n   646â†’   * Eyes Open, Cz Beta Z-score\n   647â†’   * Pass if within Â±1.0\n   648â†’   */\n   649â†’  calculateBetaEngagement() {\n   650â†’    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n   651â†’\n   652â†’    if (czBeta == null) {\n   653â†’      return {\n   654â†’        name: 'Beta Engagement',\n   655â†’        value: null,\n   656â†’        score: 0,\n   657â†’        interpretation: 'Insufficient data',\n   658â†’        details: 'Missing Cz Beta Z-score'\n   659â†’      };\n   660â†’    }\n   661â†’\n   662â†’    const score = this.scoreZMetric(czBeta, THRESHOLDS.LEARNING.BETA_ENGAGEMENT.NORMAL_RANGE, 'within');\n   663â†’\n   664â†’    return {\n   665â†’      name: 'Beta Engagement',\n   666â†’      value: czBeta,\n   667â†’      score,\n   668â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   669â†’      details: `Cz Beta Z-score: ${czBeta.toFixed(2)} (within Â±1.0 is normal)`\n   670â†’    };\n   671â†’  }\n   672â†’\n   673â†’  /**\n   674â†’   * CREATIVITY METRICS\n   675â†’   */\n   676â†’\n   677â†’  /**\n   678â†’   * Metric 1: Alpha Power\n   679â†’   * Eyes Closed, Parietal Alpha Z-scores (P3, P4, Pz)\n   680â†’   * Pass if average > -1.0\n   681â†’   */\n   682â†’  calculateAlphaPower() {\n   683â†’    const p3Alpha = this.getZScore('EC', 'absolute', 'P3', 'Alpha');\n   684â†’    const p4Alpha = this.getZScore('EC', 'absolute', 'P4', 'Alpha');\n   685â†’    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n   686â†’\n   687â†’    if (p3Alpha == null || p4Alpha == null || pzAlpha == null) {\n   688â†’      return {\n   689â†’        name: 'Alpha Power',\n   690â†’        value: null,\n   691â†’        score: 0,\n   692â†’        interpretation: 'Insufficient data',\n   693â†’        details: 'Missing parietal Alpha Z-scores'\n   694â†’      };\n   695â†’    }\n   696â†’\n   697â†’    const avgAlpha = (p3Alpha + p4Alpha + pzAlpha) / 3;\n   698â†’    const score = avgAlpha > THRESHOLDS.CREATIVITY.ALPHA_POWER.ALPHA_LOW ? 1 : 0;\n   699â†’\n   700â†’    return {\n   701â†’      name: 'Alpha Power',\n   702â†’      value: avgAlpha,\n   703â†’      score,\n   704â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   705â†’      details: `Average parietal Alpha Z-score: ${avgAlpha.toFixed(2)} (> -1.0 is normal)`\n   706â†’    };\n   707â†’  }\n   708â†’\n   709â†’  /**\n   710â†’   * Metric 2: Theta Enhancement\n   711â†’   * Eyes Closed, Parietal Theta Z-scores\n   712â†’   * Pass if average within Â±1.0\n   713â†’   */\n   714â†’  calculateThetaEnhancement() {\n   715â†’    const p3Theta = this.getZScore('EC', 'absolute', 'P3', 'Theta');\n   716â†’    const p4Theta = this.getZScore('EC', 'absolute', 'P4', 'Theta');\n   717â†’    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n   718â†’\n   719â†’    if (p3Theta == null || p4Theta == null || pzTheta == null) {\n   720â†’      return {\n   721â†’        name: 'Theta Enhancement',\n   722â†’        value: null,\n   723â†’        score: 0,\n   724â†’        interpretation: 'Insufficient data',\n   725â†’        details: 'Missing parietal Theta Z-scores'\n   726â†’      };\n   727â†’    }\n   728â†’\n   729â†’    const avgTheta = (p3Theta + p4Theta + pzTheta) / 3;\n   730â†’    const score = this.scoreZMetric(avgTheta, THRESHOLDS.CREATIVITY.THETA_ENHANCEMENT.NORMAL_RANGE, 'within');\n   731â†’\n   732â†’    return {\n   733â†’      name: 'Theta Enhancement',\n   734â†’      value: avgTheta,\n   735â†’      score,\n   736â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   737â†’      details: `Average parietal Theta Z-score: ${avgTheta.toFixed(2)} (within Â±1.0 is normal)`\n   738â†’    };\n   739â†’  }\n   740â†’\n   741â†’  /**\n   742â†’   * Metric 3: Low Beta Activity\n   743â†’   * Eyes Closed, Parietal Beta Z-scores\n   744â†’   * Pass if average < 1.0\n   745â†’   */\n   746â†’  calculateLowBeta() {\n   747â†’    const p3Beta = this.getZScore('EC', 'absolute', 'P3', 'Beta');\n   748â†’    const p4Beta = this.getZScore('EC', 'absolute', 'P4', 'Beta');\n   749â†’    const pzBeta = this.getZScore('EC', 'absolute', 'Pz', 'Beta');\n   750â†’\n   751â†’    if (p3Beta == null || p4Beta == null || pzBeta == null) {\n   752â†’      return {\n   753â†’        name: 'Low Beta Activity',\n   754â†’        value: null,\n   755â†’        score: 0,\n   756â†’        interpretation: 'Insufficient data',\n   757â†’        details: 'Missing parietal Beta Z-scores'\n   758â†’      };\n   759â†’    }\n   760â†’\n   761â†’    const avgBeta = (p3Beta + p4Beta + pzBeta) / 3;\n   762â†’    const score = avgBeta < THRESHOLDS.CREATIVITY.LOW_BETA.BETA_HIGH ? 1 : 0;\n   763â†’\n   764â†’    return {\n   765â†’      name: 'Low Beta Activity',\n   766â†’      value: avgBeta,\n   767â†’      score,\n   768â†’      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   769â†’      details: `Average parietal Beta Z-score: ${avgBeta.toFixed(2)} (< 1.0 is normal)`\n   770â†’    };\n   771â†’  }\n   772â†’\n   773â†’  // ==================== PARAMETER AGGREGATIONS ====================\n   774â†’\n   775â†’  /**\n   776â†’   * Parameter 1: COGNITION (Score 0-3)\n   777â†’   */\n   778â†’  calculateCognition() {\n   779â†’    const metric1 = this.calculateFocusScore();\n   780â†’    const metric2 = this.calculateAlphaPeak();\n   781â†’    const metric3 = this.calculateAlphaThetaBalance();\n   782â†’\n   783â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   784â†’\n   785â†’    return {\n   786â†’      name: 'Cognition',\n   787â†’      score: totalScore,\n   788â†’      maxScore: 3,\n   789â†’      classification: this.classifyScore(totalScore),\n   790â†’      metrics: [metric1, metric2, metric3]\n   791â†’    };\n   792â†’  }\n   793â†’\n   794â†’  /**\n   795â†’   * Parameter 2: STRESS (Score 0-3)\n   796â†’   */\n   797â†’  calculateStress() {\n   798â†’    const metric1 = this.calculateArousalScore();\n   799â†’    const metric2 = this.calculateRelaxationScore();\n   800â†’    const metric3 = this.calculateRegeneration();\n   801â†’\n   802â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   803â†’\n   804â†’    return {\n   805â†’      name: 'Stress',\n   806â†’      score: totalScore,\n   807â†’      maxScore: 3,\n   808â†’      classification: this.classifyScore(totalScore),\n   809â†’      metrics: [metric1, metric2, metric3]\n   810â†’    };\n   811â†’  }\n   812â†’\n   813â†’  /**\n   814â†’   * Parameter 3: FOCUS AND ATTENTION (Score 0-3)\n   815â†’   */\n   816â†’  calculateFocusAttention() {\n   817â†’    const metric1 = this.calculateFocusTheta();\n   818â†’    const metric2 = this.calculateBetaCoherence();\n   819â†’    const metric3 = this.calculateThetaBetaRatio();\n   820â†’\n   821â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   822â†’\n   823â†’    return {\n   824â†’      name: 'Focus and Attention',\n   825â†’      score: totalScore,\n   826â†’      maxScore: 3,\n   827â†’      classification: this.classifyScore(totalScore),\n   828â†’      metrics: [metric1, metric2, metric3]\n   829â†’    };\n   830â†’  }\n   831â†’\n   832â†’  /**\n   833â†’   * Parameter 4: BURNOUT AND FATIGUE (Score 0-3)\n   834â†’   */\n   835â†’  calculateBurnoutFatigue() {\n   836â†’    const metric1 = this.calculateDeltaActivity();\n   837â†’    const metric2 = this.calculateThetaDominance();\n   838â†’    const metric3 = this.calculateAlphaSuppression();\n   839â†’\n   840â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   841â†’\n   842â†’    return {\n   843â†’      name: 'Burnout and Fatigue',\n   844â†’      score: totalScore,\n   845â†’      maxScore: 3,\n   846â†’      classification: this.classifyScore(totalScore),\n   847â†’      metrics: [metric1, metric2, metric3]\n   848â†’    };\n   849â†’  }\n   850â†’\n   851â†’  /**\n   852â†’   * Parameter 5: EMOTIONAL REGULATION (Score 0-3)\n   853â†’   */\n   854â†’  calculateEmotionalRegulation() {\n   855â†’    const metric1 = this.calculateRightFrontalAlpha();\n   856â†’    const metric2 = this.calculateAlphaAsymmetry();\n   857â†’    const metric3 = this.calculateBetaStress();\n   858â†’\n   859â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   860â†’\n   861â†’    return {\n   862â†’      name: 'Emotional Regulation',\n   863â†’      score: totalScore,\n   864â†’      maxScore: 3,\n   865â†’      classification: this.classifyScore(totalScore),\n   866â†’      metrics: [metric1, metric2, metric3]\n   867â†’    };\n   868â†’  }\n   869â†’\n   870â†’  /**\n   871â†’   * Parameter 6: LEARNING (Score 0-3)\n   872â†’   */\n   873â†’  calculateLearning() {\n   874â†’    const metric1 = this.calculateCentralTheta();\n   875â†’    const metric2 = this.calculateAlphaModulation();\n   876â†’    const metric3 = this.calculateBetaEngagement();\n   877â†’\n   878â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   879â†’\n   880â†’    return {\n   881â†’      name: 'Learning',\n   882â†’      score: totalScore,\n   883â†’      maxScore: 3,\n   884â†’      classification: this.classifyScore(totalScore),\n   885â†’      metrics: [metric1, metric2, metric3]\n   886â†’    };\n   887â†’  }\n   888â†’\n   889â†’  /**\n   890â†’   * Parameter 7: CREATIVITY (Score 0-3)\n   891â†’   */\n   892â†’  calculateCreativity() {\n   893â†’    const metric1 = this.calculateAlphaPower();\n   894â†’    const metric2 = this.calculateThetaEnhancement();\n   895â†’    const metric3 = this.calculateLowBeta();\n   896â†’\n   897â†’    const totalScore = metric1.score + metric2.score + metric3.score;\n   898â†’\n   899â†’    return {\n   900â†’      name: 'Creativity',\n   901â†’      score: totalScore,\n   902â†’      maxScore: 3,\n   903â†’      classification: this.classifyScore(totalScore),\n   904â†’      metrics: [metric1, metric2, metric3]\n   905â†’    };\n   906â†’  }\n   907â†’}\n   908â†’\n   909â†’module.exports = ZScoreCalculator;\n   910â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f9087124-2515-4e64-8d4d-08a138cbd90d","timestamp":"2025-12-03T07:34:31.538Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\services\\zscoreCalculator.js","content":"/**\n * QEEG Z-Score Algorithm Calculator\n * Calculates 7 brain health parameters using Z-score data instead of raw power values\n * Z-scores represent standard deviations from age-matched norms\n * Each parameter has 3 sub-metrics, scored 0-3, classified as Low/Medium/High\n */\n\nconst THRESHOLDS = require('./zscoreThresholds');\n\nclass ZScoreCalculator {\n  constructor(qeegData) {\n    this.data = qeegData;\n    this.results = {\n      parameters: [],\n      rawCalculations: {},\n      overallScore: 0\n    };\n  }\n\n  /**\n   * Main calculation method - calculates all 7 parameters\n   */\n  calculate() {\n    const parameters = [\n      this.calculateCognition(),\n      this.calculateStress(),\n      this.calculateFocusAttention(),\n      this.calculateBurnoutFatigue(),\n      this.calculateEmotionalRegulation(),\n      this.calculateLearning(),\n      this.calculateCreativity()\n    ];\n\n    this.results.parameters = parameters;\n    this.results.overallScore = parameters.reduce((sum, p) => sum + p.score, 0);\n\n    return this.results;\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Get Z-score value from QEEG data\n   * @param {string} condition - 'EC' (Eyes Closed) or 'EO' (Eyes Open)\n   * @param {string} powerType - 'absolute' or 'relative'\n   * @param {string} channel - e.g., 'Fz', 'Cz', 'Pz'\n   * @param {string} band - e.g., 'Theta', 'Alpha', 'Beta', 'HiBeta', 'Delta'\n   */\n  getZScore(condition, powerType, channel, band) {\n    try {\n      // Z-scores are stored in data[condition].zscores[powerType][channel][band]\n      return this.data[condition].zscores[powerType][channel][band];\n    } catch (error) {\n      console.error(`Error getting Z-score: ${condition}.zscores.${powerType}.${channel}.${band}`);\n      return null;\n    }\n  }\n\n  /**\n   * Check if Z-score is within normal range\n   * @param {number} zscore - The Z-score value\n   * @param {number} threshold - Threshold value (typically 1.0 or 2.0)\n   * @param {string} comparison - 'within', 'above', 'below'\n   * @returns {number} 1 if passes, 0 if fails\n   */\n  scoreZMetric(zscore, threshold, comparison = 'within') {\n    if (zscore === null || zscore === undefined) return 0;\n\n    if (comparison === 'within') {\n      // Check if Z-score is within Â±threshold (normal range)\n      return Math.abs(zscore) <= threshold ? 1 : 0;\n    } else if (comparison === 'below') {\n      // Check if Z-score is below threshold (not elevated)\n      return zscore < threshold ? 1 : 0;\n    } else if (comparison === 'above') {\n      // Check if Z-score is above threshold (not reduced)\n      return zscore > threshold ? 1 : 0;\n    }\n    return 0;\n  }\n\n  /**\n   * Classify score to bucket (Low/Medium/High)\n   */\n  classifyScore(score) {\n    if (score <= 1) return 'Low';\n    if (score === 2) return 'Medium';\n    return 'High';\n  }\n\n  // ==================== INDIVIDUAL METRICS ====================\n\n  /**\n   * COGNITION METRICS\n   */\n\n  /**\n   * Metric 1: Focus Score (Theta & Beta Z-scores)\n   * Eyes Open, Check Fz & Cz Theta and Beta Z-scores\n   * Pass if Theta Z-score < 1.0 AND Beta Z-score > -1.0\n   */\n  calculateFocusScore() {\n    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n    const fzBeta = this.getZScore('EO', 'absolute', 'Fz', 'Beta');\n    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n\n    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null) {\n      return {\n        name: 'Focus Score',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Z-score data for frontal regions'\n      };\n    }\n\n    // Pass if all conditions met\n    const fzPass = fzTheta < THRESHOLDS.COGNITION.FOCUS_SCORE.THETA_ELEVATED &&\n                   fzBeta > THRESHOLDS.COGNITION.FOCUS_SCORE.BETA_REDUCED;\n    const czPass = czTheta < THRESHOLDS.COGNITION.FOCUS_SCORE.THETA_ELEVATED &&\n                   czBeta > THRESHOLDS.COGNITION.FOCUS_SCORE.BETA_REDUCED;\n\n    const score = (fzPass && czPass) ? 1 : 0;\n\n    return {\n      name: 'Focus Score',\n      value: { fzTheta, fzBeta, czTheta, czBeta },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Fz: Theta Z=${fzTheta.toFixed(2)}, Beta Z=${fzBeta.toFixed(2)} | Cz: Theta Z=${czTheta.toFixed(2)}, Beta Z=${czBeta.toFixed(2)}`\n    };\n  }\n\n  /**\n   * Metric 2: Alpha Peak\n   * Eyes Closed, Alpha Peak Frequency Z-score\n   * Pass if Z-score within Â±1.0\n   */\n  calculateAlphaPeak() {\n    const alphaPeakZscore = this.data.EC?.special?.alphaPeakZscore || 0.0;\n\n    const score = this.scoreZMetric(alphaPeakZscore, THRESHOLDS.COGNITION.ALPHA_PEAK.NORMAL_RANGE, 'within');\n\n    return {\n      name: 'Alpha Peak',\n      value: alphaPeakZscore,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Alpha Peak Z-score: ${alphaPeakZscore.toFixed(2)} (within Â±1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Alpha/Theta Balance\n   * Eyes Closed, Check if Alpha Z-score > -1.0 and Theta Z-score < 1.0 across regions\n   * Pass if all regions meet criteria\n   */\n  calculateAlphaThetaBalance() {\n    const fzAlpha = this.getZScore('EC', 'absolute', 'Fz', 'Alpha');\n    const fzTheta = this.getZScore('EC', 'absolute', 'Fz', 'Theta');\n    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n    const czTheta = this.getZScore('EC', 'absolute', 'Cz', 'Theta');\n    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n\n    if (fzAlpha == null || fzTheta == null || czAlpha == null || czTheta == null || pzAlpha == null || pzTheta == null) {\n      return {\n        name: 'Alpha/Theta Balance',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Z-score data'\n      };\n    }\n\n    // Check if all regions pass\n    const allRegionsPass =\n      fzAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n      fzTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH &&\n      czAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n      czTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH &&\n      pzAlpha > THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.ALPHA_LOW &&\n      pzTheta < THRESHOLDS.COGNITION.ALPHA_THETA_BALANCE.THETA_HIGH;\n\n    const score = allRegionsPass ? 1 : 0;\n\n    return {\n      name: 'Alpha/Theta Balance',\n      value: { fzAlpha, fzTheta, czAlpha, czTheta, pzAlpha, pzTheta },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Alpha Z-scores: Fz=${fzAlpha.toFixed(2)}, Cz=${czAlpha.toFixed(2)}, Pz=${pzAlpha.toFixed(2)} | Theta Z-scores: Fz=${fzTheta.toFixed(2)}, Cz=${czTheta.toFixed(2)}, Pz=${pzTheta.toFixed(2)}`\n    };\n  }\n\n  /**\n   * STRESS METRICS\n   */\n\n  /**\n   * Metric 1: Arousal Score (HiBeta Z-scores)\n   * Eyes Open, HiBeta Z-scores across Fz, Cz, Pz\n   * Pass if all < 1.0 (not elevated)\n   */\n  calculateArousalScore() {\n    const fzHiBeta = this.getZScore('EO', 'absolute', 'Fz', 'HiBeta');\n    const czHiBeta = this.getZScore('EO', 'absolute', 'Cz', 'HiBeta');\n    const pzHiBeta = this.getZScore('EO', 'absolute', 'Pz', 'HiBeta');\n\n    if (fzHiBeta == null || czHiBeta == null || pzHiBeta == null) {\n      return {\n        name: 'Arousal Score',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing HiBeta Z-score data'\n      };\n    }\n\n    const allWithinRange =\n      fzHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED &&\n      czHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED &&\n      pzHiBeta < THRESHOLDS.STRESS.AROUSAL_SCORE.HIBETA_ELEVATED;\n\n    const score = allWithinRange ? 1 : 0;\n\n    return {\n      name: 'Arousal Score',\n      value: { fzHiBeta, czHiBeta, pzHiBeta },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `HiBeta Z-scores: Fz=${fzHiBeta.toFixed(2)}, Cz=${czHiBeta.toFixed(2)}, Pz=${pzHiBeta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Relaxation Score (Posterior Theta)\n   * Eyes Closed, Pz Theta Z-score\n   * Pass if > -1.0 (not reduced)\n   */\n  calculateRelaxationScore() {\n    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n\n    if (pzTheta == null) {\n      return {\n        name: 'Relaxation Score',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Pz Theta Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(pzTheta, THRESHOLDS.STRESS.RELAXATION_SCORE.THETA_LOW, 'above');\n\n    return {\n      name: 'Relaxation Score',\n      value: pzTheta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Pz Theta Z-score: ${pzTheta.toFixed(2)} (> -1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Regeneration (Posterior Alpha)\n   * Eyes Closed, Pz Alpha Z-score\n   * Pass if > -1.0 (not reduced)\n   */\n  calculateRegeneration() {\n    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n\n    if (pzAlpha == null) {\n      return {\n        name: 'Regeneration',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Pz Alpha Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(pzAlpha, THRESHOLDS.STRESS.REGENERATION.ALPHA_LOW, 'above');\n\n    return {\n      name: 'Regeneration',\n      value: pzAlpha,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Pz Alpha Z-score: ${pzAlpha.toFixed(2)} (> -1.0 is normal)`\n    };\n  }\n\n  /**\n   * FOCUS AND ATTENTION METRICS\n   */\n\n  /**\n   * Metric 1: Focus Theta (Frontal Theta)\n   * Eyes Open, Fz Theta Z-score\n   * Pass if < 1.0 (not elevated)\n   */\n  calculateFocusTheta() {\n    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n\n    if (fzTheta == null) {\n      return {\n        name: 'Focus Theta',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Fz Theta Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(fzTheta, THRESHOLDS.FOCUS_AND_ATTENTION.FOCUS_THETA.THETA_ELEVATED, 'below');\n\n    return {\n      name: 'Focus Theta',\n      value: fzTheta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Fz Theta Z-score: ${fzTheta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Beta Coherence (C3-C4 Beta asymmetry)\n   * Eyes Open, Check C3 and C4 Beta Z-score difference\n   * Pass if |difference| < 1.0\n   */\n  calculateBetaCoherence() {\n    const c3Beta = this.getZScore('EO', 'absolute', 'C3', 'Beta');\n    const c4Beta = this.getZScore('EO', 'absolute', 'C4', 'Beta');\n\n    if (c3Beta == null || c4Beta == null) {\n      return {\n        name: 'Beta Coherence',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing C3/C4 Beta Z-scores'\n      };\n    }\n\n    const asymmetry = Math.abs(c3Beta - c4Beta);\n    const score = asymmetry < THRESHOLDS.FOCUS_AND_ATTENTION.BETA_COHERENCE.ASYMMETRY_THRESHOLD ? 1 : 0;\n\n    return {\n      name: 'Beta Coherence',\n      value: { c3Beta, c4Beta, asymmetry },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `C3 Beta Z=${c3Beta.toFixed(2)}, C4 Beta Z=${c4Beta.toFixed(2)}, Asymmetry=${asymmetry.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Theta/Beta Ratio\n   * Eyes Open, Cz Theta and Beta Z-scores\n   * Pass if Theta < 1.0 and Beta > -1.0\n   */\n  calculateThetaBetaRatio() {\n    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n\n    if (czTheta == null || czBeta == null) {\n      return {\n        name: 'Theta/Beta Ratio',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Cz Theta/Beta Z-scores'\n      };\n    }\n\n    const score = (czTheta < THRESHOLDS.FOCUS_AND_ATTENTION.THETA_BETA_RATIO.THETA_HIGH &&\n                   czBeta > THRESHOLDS.FOCUS_AND_ATTENTION.THETA_BETA_RATIO.BETA_LOW) ? 1 : 0;\n\n    return {\n      name: 'Theta/Beta Ratio',\n      value: { czTheta, czBeta },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Cz Theta Z=${czTheta.toFixed(2)} (< 1.0), Beta Z=${czBeta.toFixed(2)} (> -1.0)`\n    };\n  }\n\n  /**\n   * BURNOUT AND FATIGUE METRICS\n   */\n\n  /**\n   * Metric 1: Delta Activity (Frontal Delta)\n   * Eyes Open, Fz Delta Z-score\n   * Pass if < 1.0 (not elevated)\n   */\n  calculateDeltaActivity() {\n    const fzDelta = this.getZScore('EO', 'absolute', 'Fz', 'Delta');\n\n    if (fzDelta == null) {\n      return {\n        name: 'Delta Activity',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Fz Delta Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(fzDelta, THRESHOLDS.BURNOUT_AND_FATIGUE.DELTA_ACTIVITY.DELTA_ELEVATED, 'below');\n\n    return {\n      name: 'Delta Activity',\n      value: fzDelta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Fz Delta Z-score: ${fzDelta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Theta Dominance\n   * Eyes Open, Average Theta Z-score across regions\n   * Pass if average < 1.0\n   */\n  calculateThetaDominance() {\n    const fzTheta = this.getZScore('EO', 'absolute', 'Fz', 'Theta');\n    const czTheta = this.getZScore('EO', 'absolute', 'Cz', 'Theta');\n    const pzTheta = this.getZScore('EO', 'absolute', 'Pz', 'Theta');\n\n    if (fzTheta == null || czTheta == null || pzTheta == null) {\n      return {\n        name: 'Theta Dominance',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Theta Z-scores'\n      };\n    }\n\n    const avgTheta = (fzTheta + czTheta + pzTheta) / 3;\n    const score = avgTheta < THRESHOLDS.BURNOUT_AND_FATIGUE.THETA_DOMINANCE.THETA_EXCESSIVE ? 1 : 0;\n\n    return {\n      name: 'Theta Dominance',\n      value: avgTheta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Average Theta Z-score: ${avgTheta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Alpha Suppression\n   * Eyes Closed, Average Alpha Z-score\n   * Pass if > -1.0 (not suppressed)\n   */\n  calculateAlphaSuppression() {\n    const fzAlpha = this.getZScore('EC', 'absolute', 'Fz', 'Alpha');\n    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n\n    if (fzAlpha == null || czAlpha == null || pzAlpha == null) {\n      return {\n        name: 'Alpha Suppression',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Alpha Z-scores'\n      };\n    }\n\n    const avgAlpha = (fzAlpha + czAlpha + pzAlpha) / 3;\n    const score = avgAlpha > THRESHOLDS.BURNOUT_AND_FATIGUE.ALPHA_SUPPRESSION.ALPHA_LOW ? 1 : 0;\n\n    return {\n      name: 'Alpha Suppression',\n      value: avgAlpha,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Average Alpha Z-score: ${avgAlpha.toFixed(2)} (> -1.0 is normal)`\n    };\n  }\n\n  /**\n   * EMOTIONAL REGULATION METRICS\n   */\n\n  /**\n   * Metric 1: Right Frontal Alpha\n   * Eyes Closed, F4 Alpha Z-score\n   * Pass if > -1.0 (not reduced)\n   */\n  calculateRightFrontalAlpha() {\n    const f4Alpha = this.getZScore('EC', 'absolute', 'F4', 'Alpha');\n\n    if (f4Alpha == null) {\n      return {\n        name: 'Right Frontal Alpha',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing F4 Alpha Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(f4Alpha, THRESHOLDS.EMOTIONAL_REGULATION.RIGHT_FRONTAL_ALPHA.ALPHA_LOW, 'above');\n\n    return {\n      name: 'Right Frontal Alpha',\n      value: f4Alpha,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `F4 Alpha Z-score: ${f4Alpha.toFixed(2)} (> -1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Alpha Asymmetry (F3-F4)\n   * Eyes Closed, F3 and F4 Alpha Z-score difference\n   * Pass if |difference| < 1.0\n   */\n  calculateAlphaAsymmetry() {\n    const f3Alpha = this.getZScore('EC', 'absolute', 'F3', 'Alpha');\n    const f4Alpha = this.getZScore('EC', 'absolute', 'F4', 'Alpha');\n\n    if (f3Alpha == null || f4Alpha == null) {\n      return {\n        name: 'Alpha Asymmetry',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing F3/F4 Alpha Z-scores'\n      };\n    }\n\n    const asymmetry = Math.abs(f3Alpha - f4Alpha);\n    const score = asymmetry < THRESHOLDS.EMOTIONAL_REGULATION.ALPHA_ASYMMETRY.ASYMMETRY_THRESHOLD ? 1 : 0;\n\n    return {\n      name: 'Alpha Asymmetry',\n      value: { f3Alpha, f4Alpha, asymmetry },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `F3 Alpha Z=${f3Alpha.toFixed(2)}, F4 Alpha Z=${f4Alpha.toFixed(2)}, Asymmetry=${asymmetry.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Beta Stress Response\n   * Eyes Open, Frontal Beta Z-scores\n   * Pass if both F3 and F4 < 1.0\n   */\n  calculateBetaStress() {\n    const f3Beta = this.getZScore('EO', 'absolute', 'F3', 'Beta');\n    const f4Beta = this.getZScore('EO', 'absolute', 'F4', 'Beta');\n\n    if (f3Beta == null || f4Beta == null) {\n      return {\n        name: 'Beta Stress Response',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing F3/F4 Beta Z-scores'\n      };\n    }\n\n    const score = (f3Beta < THRESHOLDS.EMOTIONAL_REGULATION.BETA_STRESS.BETA_ELEVATED &&\n                   f4Beta < THRESHOLDS.EMOTIONAL_REGULATION.BETA_STRESS.BETA_ELEVATED) ? 1 : 0;\n\n    return {\n      name: 'Beta Stress Response',\n      value: { f3Beta, f4Beta },\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `F3 Beta Z=${f3Beta.toFixed(2)}, F4 Beta Z=${f4Beta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  /**\n   * LEARNING METRICS\n   */\n\n  /**\n   * Metric 1: Central Theta\n   * Eyes Closed, Cz Theta Z-score\n   * Pass if within Â±1.0\n   */\n  calculateCentralTheta() {\n    const czTheta = this.getZScore('EC', 'absolute', 'Cz', 'Theta');\n\n    if (czTheta == null) {\n      return {\n        name: 'Central Theta',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Cz Theta Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(czTheta, THRESHOLDS.LEARNING.CENTRAL_THETA.NORMAL_RANGE, 'within');\n\n    return {\n      name: 'Central Theta',\n      value: czTheta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Cz Theta Z-score: ${czTheta.toFixed(2)} (within Â±1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Alpha Modulation\n   * Eyes Closed, Cz Alpha Z-score\n   * Pass if within Â±1.0\n   */\n  calculateAlphaModulation() {\n    const czAlpha = this.getZScore('EC', 'absolute', 'Cz', 'Alpha');\n\n    if (czAlpha == null) {\n      return {\n        name: 'Alpha Modulation',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Cz Alpha Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(czAlpha, THRESHOLDS.LEARNING.ALPHA_MODULATION.NORMAL_RANGE, 'within');\n\n    return {\n      name: 'Alpha Modulation',\n      value: czAlpha,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Cz Alpha Z-score: ${czAlpha.toFixed(2)} (within Â±1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Beta Engagement\n   * Eyes Open, Cz Beta Z-score\n   * Pass if within Â±1.0\n   */\n  calculateBetaEngagement() {\n    const czBeta = this.getZScore('EO', 'absolute', 'Cz', 'Beta');\n\n    if (czBeta == null) {\n      return {\n        name: 'Beta Engagement',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing Cz Beta Z-score'\n      };\n    }\n\n    const score = this.scoreZMetric(czBeta, THRESHOLDS.LEARNING.BETA_ENGAGEMENT.NORMAL_RANGE, 'within');\n\n    return {\n      name: 'Beta Engagement',\n      value: czBeta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Cz Beta Z-score: ${czBeta.toFixed(2)} (within Â±1.0 is normal)`\n    };\n  }\n\n  /**\n   * CREATIVITY METRICS\n   */\n\n  /**\n   * Metric 1: Alpha Power\n   * Eyes Closed, Parietal Alpha Z-scores (P3, P4, Pz)\n   * Pass if average > -1.0\n   */\n  calculateAlphaPower() {\n    const p3Alpha = this.getZScore('EC', 'absolute', 'P3', 'Alpha');\n    const p4Alpha = this.getZScore('EC', 'absolute', 'P4', 'Alpha');\n    const pzAlpha = this.getZScore('EC', 'absolute', 'Pz', 'Alpha');\n\n    if (p3Alpha == null || p4Alpha == null || pzAlpha == null) {\n      return {\n        name: 'Alpha Power',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing parietal Alpha Z-scores'\n      };\n    }\n\n    const avgAlpha = (p3Alpha + p4Alpha + pzAlpha) / 3;\n    const score = avgAlpha > THRESHOLDS.CREATIVITY.ALPHA_POWER.ALPHA_LOW ? 1 : 0;\n\n    return {\n      name: 'Alpha Power',\n      value: avgAlpha,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Average parietal Alpha Z-score: ${avgAlpha.toFixed(2)} (> -1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 2: Theta Enhancement\n   * Eyes Closed, Parietal Theta Z-scores\n   * Pass if average within Â±1.0\n   */\n  calculateThetaEnhancement() {\n    const p3Theta = this.getZScore('EC', 'absolute', 'P3', 'Theta');\n    const p4Theta = this.getZScore('EC', 'absolute', 'P4', 'Theta');\n    const pzTheta = this.getZScore('EC', 'absolute', 'Pz', 'Theta');\n\n    if (p3Theta == null || p4Theta == null || pzTheta == null) {\n      return {\n        name: 'Theta Enhancement',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing parietal Theta Z-scores'\n      };\n    }\n\n    const avgTheta = (p3Theta + p4Theta + pzTheta) / 3;\n    const score = this.scoreZMetric(avgTheta, THRESHOLDS.CREATIVITY.THETA_ENHANCEMENT.NORMAL_RANGE, 'within');\n\n    return {\n      name: 'Theta Enhancement',\n      value: avgTheta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Average parietal Theta Z-score: ${avgTheta.toFixed(2)} (within Â±1.0 is normal)`\n    };\n  }\n\n  /**\n   * Metric 3: Low Beta Activity\n   * Eyes Closed, Parietal Beta Z-scores\n   * Pass if average < 1.0\n   */\n  calculateLowBeta() {\n    const p3Beta = this.getZScore('EC', 'absolute', 'P3', 'Beta');\n    const p4Beta = this.getZScore('EC', 'absolute', 'P4', 'Beta');\n    const pzBeta = this.getZScore('EC', 'absolute', 'Pz', 'Beta');\n\n    if (p3Beta == null || p4Beta == null || pzBeta == null) {\n      return {\n        name: 'Low Beta Activity',\n        value: null,\n        score: 0,\n        interpretation: 'Insufficient data',\n        details: 'Missing parietal Beta Z-scores'\n      };\n    }\n\n    const avgBeta = (p3Beta + p4Beta + pzBeta) / 3;\n    const score = avgBeta < THRESHOLDS.CREATIVITY.LOW_BETA.BETA_HIGH ? 1 : 0;\n\n    return {\n      name: 'Low Beta Activity',\n      value: avgBeta,\n      score,\n      interpretation: score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n      details: `Average parietal Beta Z-score: ${avgBeta.toFixed(2)} (< 1.0 is normal)`\n    };\n  }\n\n  // ==================== PARAMETER AGGREGATIONS ====================\n\n  /**\n   * Parameter 1: COGNITION (Score 0-3)\n   */\n  calculateCognition() {\n    const metric1 = this.calculateFocusScore();\n    const metric2 = this.calculateAlphaPeak();\n    const metric3 = this.calculateAlphaThetaBalance();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Cognition',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 2: STRESS (Score 0-3)\n   */\n  calculateStress() {\n    const metric1 = this.calculateArousalScore();\n    const metric2 = this.calculateRelaxationScore();\n    const metric3 = this.calculateRegeneration();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Stress',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 3: FOCUS AND ATTENTION (Score 0-3)\n   */\n  calculateFocusAttention() {\n    const metric1 = this.calculateFocusTheta();\n    const metric2 = this.calculateBetaCoherence();\n    const metric3 = this.calculateThetaBetaRatio();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Focus and Attention',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 4: BURNOUT AND FATIGUE (Score 0-3)\n   */\n  calculateBurnoutFatigue() {\n    const metric1 = this.calculateDeltaActivity();\n    const metric2 = this.calculateThetaDominance();\n    const metric3 = this.calculateAlphaSuppression();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Burnout and Fatigue',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 5: EMOTIONAL REGULATION (Score 0-3)\n   */\n  calculateEmotionalRegulation() {\n    const metric1 = this.calculateRightFrontalAlpha();\n    const metric2 = this.calculateAlphaAsymmetry();\n    const metric3 = this.calculateBetaStress();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Emotional Regulation',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 6: LEARNING (Score 0-3)\n   */\n  calculateLearning() {\n    const metric1 = this.calculateCentralTheta();\n    const metric2 = this.calculateAlphaModulation();\n    const metric3 = this.calculateBetaEngagement();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Learning',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n\n  /**\n   * Parameter 7: CREATIVITY (Score 0-3)\n   */\n  calculateCreativity() {\n    const metric1 = this.calculateAlphaPower();\n    const metric2 = this.calculateThetaEnhancement();\n    const metric3 = this.calculateLowBeta();\n\n    const totalScore = metric1.score + metric2.score + metric3.score;\n\n    return {\n      name: 'Creativity',\n      score: totalScore,\n      maxScore: 3,\n      classification: this.classifyScore(totalScore),\n      metrics: [metric1, metric2, metric3]\n    };\n  }\n}\n\nmodule.exports = ZScoreCalculator;\n","numLines":910,"startLine":1,"totalLines":910}}}
{"parentUuid":"f9087124-2515-4e64-8d4d-08a138cbd90d","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HPpkRGZshfag7xjLCdENhh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the Gemini PDF generator more closely and look at temperature settings:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":576,"cache_creation_input_tokens":19060,"cache_read_input_tokens":46751,"cache_creation":{"ephemeral_5m_input_tokens":19060,"ephemeral_1h_input_tokens":0},"output_tokens":187,"service_tier":"standard"}},"requestId":"req_011CVjNGMhduvSDUyJwQ8ZrK","type":"assistant","uuid":"94f4b34d-8f32-4a2e-a027-e22f4409ce2c","timestamp":"2025-12-03T07:34:43.758Z"}
{"parentUuid":"94f4b34d-8f32-4a2e-a027-e22f4409ce2c","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HPpkRGZshfag7xjLCdENhh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013frQg9TbTnbNUzxGUAYZtz","name":"Read","input":{"file_path":"D:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":576,"cache_creation_input_tokens":19060,"cache_read_input_tokens":46751,"cache_creation":{"ephemeral_5m_input_tokens":19060,"ephemeral_1h_input_tokens":0},"output_tokens":187,"service_tier":"standard"}},"requestId":"req_011CVjNGMhduvSDUyJwQ8ZrK","type":"assistant","uuid":"32e6424d-bd51-4f71-823a-2d79be72ac6a","timestamp":"2025-12-03T07:34:44.279Z"}
{"parentUuid":"32e6424d-bd51-4f71-823a-2d79be72ac6a","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HPpkRGZshfag7xjLCdENhh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C9WhtcdhorNVwsMCAARD6u","name":"Grep","input":{"pattern":"temperature|generationConfig|top_p|top_k","path":"D:\\Todays\\Neuro360\\server","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":576,"cache_creation_input_tokens":19060,"cache_read_input_tokens":46751,"cache_creation":{"ephemeral_5m_input_tokens":19060,"ephemeral_1h_input_tokens":0},"output_tokens":187,"service_tier":"standard"}},"requestId":"req_011CVjNGMhduvSDUyJwQ8ZrK","type":"assistant","uuid":"0781972e-1acc-4b1a-9efd-33a3bab6c340","timestamp":"2025-12-03T07:34:45.528Z"}
{"parentUuid":"0781972e-1acc-4b1a-9efd-33a3bab6c340","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013frQg9TbTnbNUzxGUAYZtz","type":"tool_result","content":"     1â†’const PDFDocument = require('pdfkit');\n     2â†’const fs = require('fs');\n     3â†’const path = require('path');\n     4â†’const GeminiService = require('./geminiService');\n     5â†’\n     6â†’class GeminiPdfGenerator {\n     7â†’  constructor(patientData, algorithmResults, qeegData) {\n     8â†’    this.patientData = patientData;\n     9â†’    this.algorithmResults = algorithmResults;\n    10â†’    this.qeegData = qeegData;\n    11â†’    this.geminiReportData = null;\n    12â†’  }\n    13â†’\n    14â†’  /**\n    15â†’   * Transform algorithm results to Gemini input format\n    16â†’   */\n    17â†’  transformToGeminiFormat() {\n    18â†’    const brainParameters = {\n    19â†’      Cognition: null,\n    20â†’      Stress: null,\n    21â†’      FocusAndAttention: null,\n    22â†’      BurnoutAndFatigue: null,\n    23â†’      EmotionalRegulation: null,\n    24â†’      Learning: null,\n    25â†’      Creativity: null\n    26â†’    };\n    27â†’\n    28â†’    // Map the parameters from algorithm results\n    29â†’    this.algorithmResults.parameters.forEach(param => {\n    30â†’      const paramName = param.name.replace(/\\s+/g, '');\n    31â†’      if (brainParameters.hasOwnProperty(paramName)) {\n    32â†’        brainParameters[paramName] = {\n    33â†’          score: param.score,\n    34â†’          maxScore: param.maxScore,\n    35â†’          bucket: param.bucket || param.classification,\n    36â†’          subparameters: (param.metrics || param.subParameters || []).map(metric => ({\n    37â†’            name: metric.name,\n    38â†’            score: metric.score,\n    39â†’            value: metric.value,\n    40â†’            threshold: metric.threshold\n    41â†’          }))\n    42â†’        };\n    43â†’      }\n    44â†’    });\n    45â†’\n    46â†’    return brainParameters;\n    47â†’  }\n    48â†’\n    49â†’  /**\n    50â†’   * Generate report structure using Gemini AI\n    51â†’   */\n    52â†’  async generateReportStructure() {\n    53â†’    console.log('ğŸ¤– Generating report structure with Gemini AI...');\n    54â†’    console.log('ğŸ“Š Brain Parameters:', JSON.stringify(this.transformToGeminiFormat(), null, 2));\n    55â†’\n    56â†’    try {\n    57â†’      const brainParameters = this.transformToGeminiFormat();\n    58â†’      const result = await GeminiService.generateBrainPerformanceReport(brainParameters);\n    59â†’\n    60â†’      if (!result.success) {\n    61â†’        console.error('âŒ Gemini API returned error:', result.error);\n    62â†’        throw new Error(`Gemini AI failed: ${result.error}`);\n    63â†’      }\n    64â†’\n    65â†’      this.geminiReportData = result.data;\n    66â†’      console.log('âœ… Gemini report structure generated successfully');\n    67â†’      console.log('ğŸ“„ Report has', result.data.parameters?.length || 0, 'parameters');\n    68â†’      return this.geminiReportData;\n    69â†’    } catch (error) {\n    70â†’      console.error('âŒ Error in generateReportStructure:', error.message);\n    71â†’      console.error('   Stack:', error.stack);\n    72â†’      throw error;\n    73â†’    }\n    74â†’  }\n    75â†’\n    76â†’  /**\n    77â†’   * Main report generation function\n    78â†’   */\n    79â†’  async generateReport(outputPath) {\n    80â†’    try {\n    81â†’      // Step 1: Try to generate AI report structure with Gemini\n    82â†’      let usingGemini = false;\n    83â†’      try {\n    84â†’        console.log('ğŸ¤– Attempting to generate report with Gemini AI...');\n    85â†’        await this.generateReportStructure();\n    86â†’        usingGemini = true;\n    87â†’        console.log('âœ… Gemini AI report structure ready');\n    88â†’      } catch (geminiError) {\n    89â†’        console.error('âš ï¸ Gemini AI failed, using fallback data structure');\n    90â†’        console.error('   Gemini Error:', geminiError.message);\n    91â†’\n    92â†’        // Fallback: Create basic report structure from algorithm data\n    93â†’        this.geminiReportData = this.createFallbackReportStructure();\n    94â†’        console.log('âœ… Fallback report structure created');\n    95â†’      }\n    96â†’\n    97â†’      // Step 2: Create PDF from the report structure (AI or fallback)\n    98â†’      const doc = new PDFDocument({\n    99â†’        size: 'A4',\n   100â†’        margins: { top: 50, bottom: 50, left: 50, right: 50 }\n   101â†’      });\n   102â†’\n   103â†’      const stream = fs.createWriteStream(outputPath);\n   104â†’      doc.pipe(stream);\n   105â†’\n   106â†’      // Generate PDF content\n   107â†’      await this.generatePDFContent(doc);\n   108â†’\n   109â†’      doc.end();\n   110â†’\n   111â†’      // Wait for PDF to finish writing\n   112â†’      await new Promise((resolve, reject) => {\n   113â†’        stream.on('finish', resolve);\n   114â†’        stream.on('error', reject);\n   115â†’      });\n   116â†’\n   117â†’      const sourceType = usingGemini ? 'Gemini AI' : 'Fallback (Basic)';\n   118â†’      console.log(`âœ… PDF generated successfully with ${sourceType} content`);\n   119â†’      return outputPath;\n   120â†’\n   121â†’    } catch (error) {\n   122â†’      console.error('âŒ Error generating PDF:', error);\n   123â†’      console.error('   Stack:', error.stack);\n   124â†’      throw error;\n   125â†’    }\n   126â†’  }\n   127â†’\n   128â†’  /**\n   129â†’   * Create fallback report structure when Gemini fails\n   130â†’   */\n   131â†’  createFallbackReportStructure() {\n   132â†’    console.log('ğŸ“‹ Creating fallback report structure...');\n   133â†’    console.log('   Algorithm results:', JSON.stringify(this.algorithmResults, null, 2));\n   134â†’\n   135â†’    const parameters = this.algorithmResults.parameters.map(param => {\n   136â†’      // Use metrics (correct field from algorithm) instead of subParameters\n   137â†’      const subMetrics = param.metrics || param.subParameters || [];\n   138â†’\n   139â†’      console.log(`   Processing ${param.name}:`);\n   140â†’      console.log(`     Score: ${param.score}/${param.maxScore}`);\n   141â†’      console.log(`     Classification: ${param.classification}`);\n   142â†’      console.log(`     Metrics count: ${subMetrics.length}`);\n   143â†’\n   144â†’      return {\n   145â†’        name: param.name,\n   146â†’        score: param.score,\n   147â†’        bucket: param.classification || 'Average',\n   148â†’        bucketColor: this.getBucketColor(param.classification),\n   149â†’        summary: `${param.name} score is ${param.score} out of ${param.maxScore} (${param.classification || 'Average'})`,\n   150â†’        subparameters: subMetrics.map(metric => ({\n   151â†’          name: metric.name || 'Metric',\n   152â†’          score: metric.score !== undefined ? metric.score : (metric.value || 0),\n   153â†’          interpretation: metric.score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n   154â†’          details: metric.value !== undefined ? `Value: ${metric.value.toFixed(2)} (Threshold: ${metric.threshold})` : ''\n   155â†’        }))\n   156â†’      };\n   157â†’    });\n   158â†’\n   159â†’    console.log('   Fallback structure created with', parameters.length, 'parameters');\n   160â†’\n   161â†’    return {\n   162â†’      title: 'Brain Performance Report',\n   163â†’      patientSummary: `This report shows the analysis of ${this.algorithmResults.parameters.length} brain performance parameters for ${this.patientData.name}. Overall score: ${this.algorithmResults.overallScore || 'N/A'}.`,\n   164â†’      parameters: parameters,\n   165â†’      recommendations: [\n   166â†’        'Continue monitoring brain health metrics regularly',\n   167â†’        'Maintain healthy lifestyle habits including proper sleep and exercise',\n   168â†’        'Consult with healthcare provider for detailed interpretation and personalized recommendations'\n   169â†’      ]\n   170â†’    };\n   171â†’  }\n   172â†’\n   173â†’  /**\n   174â†’   * Generate PDF content from Gemini AI data\n   175â†’   */\n   176â†’  async generatePDFContent(doc) {\n   177â†’    const reportData = this.geminiReportData;\n   178â†’\n   179â†’    console.log('\\nğŸ“„ === Generating PDF Content ===');\n   180â†’    console.log('   Report Title:', reportData.title);\n   181â†’    console.log('   Parameters count:', reportData.parameters?.length || 0);\n   182â†’\n   183â†’    if (reportData.parameters && reportData.parameters.length > 0) {\n   184â†’      reportData.parameters.forEach((param, idx) => {\n   185â†’        console.log(`   ${idx + 1}. ${param.name}: ${param.score} (${param.bucket}), Sub-metrics: ${param.subparameters?.length || 0}`);\n   186â†’      });\n   187â†’    }\n   188â†’\n   189â†’    // Header\n   190â†’    this.addHeader(doc);\n   191â†’\n   192â†’    // Patient Information\n   193â†’    this.addPatientInfo(doc);\n   194â†’\n   195â†’    doc.moveDown(1);\n   196â†’\n   197â†’    // Title\n   198â†’    doc.fontSize(24)\n   199â†’       .fillColor('#323956')\n   200â†’       .font('Helvetica-Bold')\n   201â†’       .text(reportData.title || 'Brain Performance Report', { align: 'center' });\n   202â†’\n   203â†’    doc.moveDown(1);\n   204â†’\n   205â†’    // Parameters Section\n   206â†’    if (reportData.parameters && reportData.parameters.length > 0) {\n   207â†’      console.log('\\nğŸ“Š Adding parameters to PDF...');\n   208â†’      reportData.parameters.forEach((param, index) => {\n   209â†’        this.addParameterSection(doc, param, index);\n   210â†’      });\n   211â†’      console.log('âœ… All parameters added to PDF\\n');\n   212â†’    } else {\n   213â†’      console.error('âŒ No parameters found in report data!');\n   214â†’    }\n   215â†’\n   216â†’    doc.moveDown(2);\n   217â†’\n   218â†’    // Patient Summary\n   219â†’    if (reportData.patientSummary) {\n   220â†’      this.addSummarySection(doc, reportData.patientSummary);\n   221â†’    }\n   222â†’\n   223â†’    // Recommendations\n   224â†’    if (reportData.recommendations && reportData.recommendations.length > 0) {\n   225â†’      this.addRecommendations(doc, reportData.recommendations);\n   226â†’    }\n   227â†’\n   228â†’    // Footer\n   229â†’    this.addFooter(doc);\n   230â†’  }\n   231â†’\n   232â†’  /**\n   233â†’   * Add header to PDF\n   234â†’   */\n   235â†’  addHeader(doc) {\n   236â†’    doc.fontSize(10)\n   237â†’       .fillColor('#666666')\n   238â†’       .text('NeuroSense360 Brain Performance Report', 50, 30);\n   239â†’\n   240â†’    doc.fontSize(8)\n   241â†’       .text(new Date().toLocaleDateString(), 450, 30);\n   242â†’\n   243â†’    doc.moveTo(50, 45)\n   244â†’       .lineTo(545, 45)\n   245â†’       .stroke('#CCCCCC');\n   246â†’\n   247â†’    doc.moveDown(2);\n   248â†’  }\n   249â†’\n   250â†’  /**\n   251â†’   * Add patient information\n   252â†’   */\n   253â†’  addPatientInfo(doc) {\n   254â†’    const y = doc.y;\n   255â†’\n   256â†’    doc.fontSize(10)\n   257â†’       .fillColor('#323956')\n   258â†’       .font('Helvetica-Bold')\n   259â†’       .text('Patient Information', 50, y);\n   260â†’\n   261â†’    doc.fontSize(9)\n   262â†’       .fillColor('#666666')\n   263â†’       .font('Helvetica')\n   264â†’       .text(`Name: ${this.patientData.name || 'N/A'}`, 50, y + 20)\n   265â†’       .text(`Age: ${this.patientData.age || 'N/A'}`, 50, y + 35)\n   266â†’       .text(`Gender: ${this.patientData.gender || 'N/A'}`, 50, y + 50);\n   267â†’\n   268â†’    if (this.patientData.clinicName) {\n   269â†’      doc.text(`Clinic: ${this.patientData.clinicName}`, 300, y + 20);\n   270â†’    }\n   271â†’\n   272â†’    doc.text(`Report Date: ${new Date().toLocaleDateString()}`, 300, y + 35);\n   273â†’\n   274â†’    doc.moveDown(3);\n   275â†’  }\n   276â†’\n   277â†’  /**\n   278â†’   * Add parameter section\n   279â†’   */\n   280â†’  addParameterSection(doc, param, index) {\n   281â†’    const y = doc.y;\n   282â†’\n   283â†’    // Check if we need a new page\n   284â†’    if (y > 650) {\n   285â†’      doc.addPage();\n   286â†’    }\n   287â†’\n   288â†’    // Parameter header with background color\n   289â†’    const bgColor = this.getBucketColor(param.bucketColor || param.bucket);\n   290â†’\n   291â†’    doc.rect(50, y, 495, 30)\n   292â†’       .fill(bgColor);\n   293â†’\n   294â†’    doc.fontSize(14)\n   295â†’       .fillColor('#FFFFFF')\n   296â†’       .font('Helvetica-Bold')\n   297â†’       .text(param.name, 60, y + 8);\n   298â†’\n   299â†’    // Show score with maxScore for clarity\n   300â†’    const scoreText = param.maxScore ? `${param.score}/${param.maxScore}` : `${param.score}`;\n   301â†’    doc.fontSize(12)\n   302â†’       .text(`Score: ${scoreText}`, 380, y + 8);\n   303â†’\n   304â†’    doc.fontSize(10)\n   305â†’       .fillColor('#FFFFFF')\n   306â†’       .font('Helvetica')\n   307â†’       .text(param.bucket || '', 480, y + 10);\n   308â†’\n   309â†’    doc.moveDown(2);\n   310â†’\n   311â†’    // Parameter summary\n   312â†’    if (param.summary) {\n   313â†’      doc.fontSize(10)\n   314â†’         .fillColor('#666666')\n   315â†’         .font('Helvetica-Oblique')\n   316â†’         .text(param.summary, 60, doc.y, {\n   317â†’           width: 475,\n   318â†’           align: 'left'\n   319â†’         });\n   320â†’\n   321â†’      doc.moveDown(0.5);\n   322â†’    }\n   323â†’\n   324â†’    // Subparameters (metrics)\n   325â†’    if (param.subparameters && param.subparameters.length > 0) {\n   326â†’      console.log(`   ğŸ“Š Adding ${param.subparameters.length} sub-metrics for ${param.name}`);\n   327â†’\n   328â†’      doc.fontSize(9)\n   329â†’         .fillColor('#323956')\n   330â†’         .font('Helvetica-Bold')\n   331â†’         .text('Details:', 60, doc.y);\n   332â†’\n   333â†’      doc.moveDown(0.3);\n   334â†’\n   335â†’      param.subparameters.forEach((sub, idx) => {\n   336â†’        console.log(`     ${idx + 1}. ${sub.name}: score=${sub.score}, interpretation=\"${sub.interpretation}\"`);\n   337â†’\n   338â†’        doc.fontSize(8)\n   339â†’           .fillColor('#666666')\n   340â†’           .font('Helvetica')\n   341â†’           .text(`â€¢ ${sub.name}: `, 70, doc.y, { continued: true })\n   342â†’           .font('Helvetica-Bold')\n   343â†’           .fillColor(sub.score === 1 ? '#38A169' : '#E53E3E')\n   344â†’           .text(`${sub.score === 1 ? 'âœ“' : 'âœ—'}`, { continued: true })\n   345â†’           .fillColor('#666666')\n   346â†’           .font('Helvetica')\n   347â†’           .text(` ${sub.interpretation || ''}`, { width: 450 });\n   348â†’\n   349â†’        // Add details if available\n   350â†’        if (sub.details) {\n   351â†’          doc.fontSize(7)\n   352â†’             .fillColor('#999999')\n   353â†’             .text(`  ${sub.details}`, 80, doc.y);\n   354â†’        }\n   355â†’\n   356â†’        doc.moveDown(0.2);\n   357â†’      });\n   358â†’    } else {\n   359â†’      console.log(`   âš ï¸ No sub-metrics for ${param.name}`);\n   360â†’    }\n   361â†’\n   362â†’    doc.moveDown(1.5);\n   363â†’  }\n   364â†’\n   365â†’  /**\n   366â†’   * Add summary section\n   367â†’   */\n   368â†’  addSummarySection(doc, summary) {\n   369â†’    const y = doc.y;\n   370â†’\n   371â†’    if (y > 650) {\n   372â†’      doc.addPage();\n   373â†’    }\n   374â†’\n   375â†’    doc.fontSize(14)\n   376â†’       .fillColor('#323956')\n   377â†’       .font('Helvetica-Bold')\n   378â†’       .text('Overall Summary', 50, doc.y);\n   379â†’\n   380â†’    doc.moveDown(0.5);\n   381â†’\n   382â†’    doc.fontSize(10)\n   383â†’       .fillColor('#666666')\n   384â†’       .font('Helvetica')\n   385â†’       .text(summary, {\n   386â†’         width: 495,\n   387â†’         align: 'justify'\n   388â†’       });\n   389â†’\n   390â†’    doc.moveDown(1);\n   391â†’  }\n   392â†’\n   393â†’  /**\n   394â†’   * Add recommendations\n   395â†’   */\n   396â†’  addRecommendations(doc, recommendations) {\n   397â†’    const y = doc.y;\n   398â†’\n   399â†’    if (y > 650) {\n   400â†’      doc.addPage();\n   401â†’    }\n   402â†’\n   403â†’    doc.fontSize(14)\n   404â†’       .fillColor('#323956')\n   405â†’       .font('Helvetica-Bold')\n   406â†’       .text('Recommendations', 50, doc.y);\n   407â†’\n   408â†’    doc.moveDown(0.5);\n   409â†’\n   410â†’    recommendations.forEach(rec => {\n   411â†’      doc.fontSize(9)\n   412â†’         .fillColor('#666666')\n   413â†’         .font('Helvetica')\n   414â†’         .text(`â€¢ ${rec}`, 60, doc.y, {\n   415â†’           width: 475\n   416â†’         });\n   417â†’\n   418â†’      doc.moveDown(0.3);\n   419â†’    });\n   420â†’  }\n   421â†’\n   422â†’  /**\n   423â†’   * Add footer\n   424â†’   */\n   425â†’  addFooter(doc) {\n   426â†’    const bottomY = 750;\n   427â†’\n   428â†’    doc.fontSize(7)\n   429â†’       .fillColor('#999999')\n   430â†’       .text('This report is generated using AI-powered analysis and should be interpreted by a qualified healthcare professional.',\n   431â†’             50, bottomY, {\n   432â†’               width: 495,\n   433â†’               align: 'center'\n   434â†’             });\n   435â†’\n   436â†’    doc.fontSize(7)\n   437â†’       .text('Â© 2025 NeuroSense360. Powered by Google Gemini AI.',\n   438â†’             50, bottomY + 15, {\n   439â†’               width: 495,\n   440â†’               align: 'center'\n   441â†’             });\n   442â†’  }\n   443â†’\n   444â†’  /**\n   445â†’   * Get color for bucket classification\n   446â†’   */\n   447â†’  getBucketColor(bucketOrColor) {\n   448â†’    // If it's already a hex color\n   449â†’    if (bucketOrColor && bucketOrColor.startsWith('#')) {\n   450â†’      return bucketOrColor;\n   451â†’    }\n   452â†’\n   453â†’    // Default color mapping\n   454â†’    const colorMap = {\n   455â†’      'Poor': '#E53E3E',\n   456â†’      'Below Average': '#F56565',\n   457â†’      'Average': '#ED8936',\n   458â†’      'Good': '#48BB78',\n   459â†’      'Excellent': '#38A169',\n   460â†’      'Low': '#E53E3E',\n   461â†’      'Moderate': '#ED8936',\n   462â†’      'High': '#F56565'\n   463â†’    };\n   464â†’\n   465â†’    return colorMap[bucketOrColor] || '#4299E1';\n   466â†’  }\n   467â†’}\n   468â†’\n   469â†’module.exports = GeminiPdfGenerator;\n   470â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"64d715b3-783f-44e4-9456-4c8ae12e479f","timestamp":"2025-12-03T07:34:48.705Z","toolUseResult":{"type":"text","file":{"filePath":"D:\\Todays\\Neuro360\\server\\services\\geminiPdfGenerator.js","content":"const PDFDocument = require('pdfkit');\nconst fs = require('fs');\nconst path = require('path');\nconst GeminiService = require('./geminiService');\n\nclass GeminiPdfGenerator {\n  constructor(patientData, algorithmResults, qeegData) {\n    this.patientData = patientData;\n    this.algorithmResults = algorithmResults;\n    this.qeegData = qeegData;\n    this.geminiReportData = null;\n  }\n\n  /**\n   * Transform algorithm results to Gemini input format\n   */\n  transformToGeminiFormat() {\n    const brainParameters = {\n      Cognition: null,\n      Stress: null,\n      FocusAndAttention: null,\n      BurnoutAndFatigue: null,\n      EmotionalRegulation: null,\n      Learning: null,\n      Creativity: null\n    };\n\n    // Map the parameters from algorithm results\n    this.algorithmResults.parameters.forEach(param => {\n      const paramName = param.name.replace(/\\s+/g, '');\n      if (brainParameters.hasOwnProperty(paramName)) {\n        brainParameters[paramName] = {\n          score: param.score,\n          maxScore: param.maxScore,\n          bucket: param.bucket || param.classification,\n          subparameters: (param.metrics || param.subParameters || []).map(metric => ({\n            name: metric.name,\n            score: metric.score,\n            value: metric.value,\n            threshold: metric.threshold\n          }))\n        };\n      }\n    });\n\n    return brainParameters;\n  }\n\n  /**\n   * Generate report structure using Gemini AI\n   */\n  async generateReportStructure() {\n    console.log('ğŸ¤– Generating report structure with Gemini AI...');\n    console.log('ğŸ“Š Brain Parameters:', JSON.stringify(this.transformToGeminiFormat(), null, 2));\n\n    try {\n      const brainParameters = this.transformToGeminiFormat();\n      const result = await GeminiService.generateBrainPerformanceReport(brainParameters);\n\n      if (!result.success) {\n        console.error('âŒ Gemini API returned error:', result.error);\n        throw new Error(`Gemini AI failed: ${result.error}`);\n      }\n\n      this.geminiReportData = result.data;\n      console.log('âœ… Gemini report structure generated successfully');\n      console.log('ğŸ“„ Report has', result.data.parameters?.length || 0, 'parameters');\n      return this.geminiReportData;\n    } catch (error) {\n      console.error('âŒ Error in generateReportStructure:', error.message);\n      console.error('   Stack:', error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Main report generation function\n   */\n  async generateReport(outputPath) {\n    try {\n      // Step 1: Try to generate AI report structure with Gemini\n      let usingGemini = false;\n      try {\n        console.log('ğŸ¤– Attempting to generate report with Gemini AI...');\n        await this.generateReportStructure();\n        usingGemini = true;\n        console.log('âœ… Gemini AI report structure ready');\n      } catch (geminiError) {\n        console.error('âš ï¸ Gemini AI failed, using fallback data structure');\n        console.error('   Gemini Error:', geminiError.message);\n\n        // Fallback: Create basic report structure from algorithm data\n        this.geminiReportData = this.createFallbackReportStructure();\n        console.log('âœ… Fallback report structure created');\n      }\n\n      // Step 2: Create PDF from the report structure (AI or fallback)\n      const doc = new PDFDocument({\n        size: 'A4',\n        margins: { top: 50, bottom: 50, left: 50, right: 50 }\n      });\n\n      const stream = fs.createWriteStream(outputPath);\n      doc.pipe(stream);\n\n      // Generate PDF content\n      await this.generatePDFContent(doc);\n\n      doc.end();\n\n      // Wait for PDF to finish writing\n      await new Promise((resolve, reject) => {\n        stream.on('finish', resolve);\n        stream.on('error', reject);\n      });\n\n      const sourceType = usingGemini ? 'Gemini AI' : 'Fallback (Basic)';\n      console.log(`âœ… PDF generated successfully with ${sourceType} content`);\n      return outputPath;\n\n    } catch (error) {\n      console.error('âŒ Error generating PDF:', error);\n      console.error('   Stack:', error.stack);\n      throw error;\n    }\n  }\n\n  /**\n   * Create fallback report structure when Gemini fails\n   */\n  createFallbackReportStructure() {\n    console.log('ğŸ“‹ Creating fallback report structure...');\n    console.log('   Algorithm results:', JSON.stringify(this.algorithmResults, null, 2));\n\n    const parameters = this.algorithmResults.parameters.map(param => {\n      // Use metrics (correct field from algorithm) instead of subParameters\n      const subMetrics = param.metrics || param.subParameters || [];\n\n      console.log(`   Processing ${param.name}:`);\n      console.log(`     Score: ${param.score}/${param.maxScore}`);\n      console.log(`     Classification: ${param.classification}`);\n      console.log(`     Metrics count: ${subMetrics.length}`);\n\n      return {\n        name: param.name,\n        score: param.score,\n        bucket: param.classification || 'Average',\n        bucketColor: this.getBucketColor(param.classification),\n        summary: `${param.name} score is ${param.score} out of ${param.maxScore} (${param.classification || 'Average'})`,\n        subparameters: subMetrics.map(metric => ({\n          name: metric.name || 'Metric',\n          score: metric.score !== undefined ? metric.score : (metric.value || 0),\n          interpretation: metric.score === 1 ? 'âœ“ Within optimal range' : 'âœ— Outside optimal range',\n          details: metric.value !== undefined ? `Value: ${metric.value.toFixed(2)} (Threshold: ${metric.threshold})` : ''\n        }))\n      };\n    });\n\n    console.log('   Fallback structure created with', parameters.length, 'parameters');\n\n    return {\n      title: 'Brain Performance Report',\n      patientSummary: `This report shows the analysis of ${this.algorithmResults.parameters.length} brain performance parameters for ${this.patientData.name}. Overall score: ${this.algorithmResults.overallScore || 'N/A'}.`,\n      parameters: parameters,\n      recommendations: [\n        'Continue monitoring brain health metrics regularly',\n        'Maintain healthy lifestyle habits including proper sleep and exercise',\n        'Consult with healthcare provider for detailed interpretation and personalized recommendations'\n      ]\n    };\n  }\n\n  /**\n   * Generate PDF content from Gemini AI data\n   */\n  async generatePDFContent(doc) {\n    const reportData = this.geminiReportData;\n\n    console.log('\\nğŸ“„ === Generating PDF Content ===');\n    console.log('   Report Title:', reportData.title);\n    console.log('   Parameters count:', reportData.parameters?.length || 0);\n\n    if (reportData.parameters && reportData.parameters.length > 0) {\n      reportData.parameters.forEach((param, idx) => {\n        console.log(`   ${idx + 1}. ${param.name}: ${param.score} (${param.bucket}), Sub-metrics: ${param.subparameters?.length || 0}`);\n      });\n    }\n\n    // Header\n    this.addHeader(doc);\n\n    // Patient Information\n    this.addPatientInfo(doc);\n\n    doc.moveDown(1);\n\n    // Title\n    doc.fontSize(24)\n       .fillColor('#323956')\n       .font('Helvetica-Bold')\n       .text(reportData.title || 'Brain Performance Report', { align: 'center' });\n\n    doc.moveDown(1);\n\n    // Parameters Section\n    if (reportData.parameters && reportData.parameters.length > 0) {\n      console.log('\\nğŸ“Š Adding parameters to PDF...');\n      reportData.parameters.forEach((param, index) => {\n        this.addParameterSection(doc, param, index);\n      });\n      console.log('âœ… All parameters added to PDF\\n');\n    } else {\n      console.error('âŒ No parameters found in report data!');\n    }\n\n    doc.moveDown(2);\n\n    // Patient Summary\n    if (reportData.patientSummary) {\n      this.addSummarySection(doc, reportData.patientSummary);\n    }\n\n    // Recommendations\n    if (reportData.recommendations && reportData.recommendations.length > 0) {\n      this.addRecommendations(doc, reportData.recommendations);\n    }\n\n    // Footer\n    this.addFooter(doc);\n  }\n\n  /**\n   * Add header to PDF\n   */\n  addHeader(doc) {\n    doc.fontSize(10)\n       .fillColor('#666666')\n       .text('NeuroSense360 Brain Performance Report', 50, 30);\n\n    doc.fontSize(8)\n       .text(new Date().toLocaleDateString(), 450, 30);\n\n    doc.moveTo(50, 45)\n       .lineTo(545, 45)\n       .stroke('#CCCCCC');\n\n    doc.moveDown(2);\n  }\n\n  /**\n   * Add patient information\n   */\n  addPatientInfo(doc) {\n    const y = doc.y;\n\n    doc.fontSize(10)\n       .fillColor('#323956')\n       .font('Helvetica-Bold')\n       .text('Patient Information', 50, y);\n\n    doc.fontSize(9)\n       .fillColor('#666666')\n       .font('Helvetica')\n       .text(`Name: ${this.patientData.name || 'N/A'}`, 50, y + 20)\n       .text(`Age: ${this.patientData.age || 'N/A'}`, 50, y + 35)\n       .text(`Gender: ${this.patientData.gender || 'N/A'}`, 50, y + 50);\n\n    if (this.patientData.clinicName) {\n      doc.text(`Clinic: ${this.patientData.clinicName}`, 300, y + 20);\n    }\n\n    doc.text(`Report Date: ${new Date().toLocaleDateString()}`, 300, y + 35);\n\n    doc.moveDown(3);\n  }\n\n  /**\n   * Add parameter section\n   */\n  addParameterSection(doc, param, index) {\n    const y = doc.y;\n\n    // Check if we need a new page\n    if (y > 650) {\n      doc.addPage();\n    }\n\n    // Parameter header with background color\n    const bgColor = this.getBucketColor(param.bucketColor || param.bucket);\n\n    doc.rect(50, y, 495, 30)\n       .fill(bgColor);\n\n    doc.fontSize(14)\n       .fillColor('#FFFFFF')\n       .font('Helvetica-Bold')\n       .text(param.name, 60, y + 8);\n\n    // Show score with maxScore for clarity\n    const scoreText = param.maxScore ? `${param.score}/${param.maxScore}` : `${param.score}`;\n    doc.fontSize(12)\n       .text(`Score: ${scoreText}`, 380, y + 8);\n\n    doc.fontSize(10)\n       .fillColor('#FFFFFF')\n       .font('Helvetica')\n       .text(param.bucket || '', 480, y + 10);\n\n    doc.moveDown(2);\n\n    // Parameter summary\n    if (param.summary) {\n      doc.fontSize(10)\n         .fillColor('#666666')\n         .font('Helvetica-Oblique')\n         .text(param.summary, 60, doc.y, {\n           width: 475,\n           align: 'left'\n         });\n\n      doc.moveDown(0.5);\n    }\n\n    // Subparameters (metrics)\n    if (param.subparameters && param.subparameters.length > 0) {\n      console.log(`   ğŸ“Š Adding ${param.subparameters.length} sub-metrics for ${param.name}`);\n\n      doc.fontSize(9)\n         .fillColor('#323956')\n         .font('Helvetica-Bold')\n         .text('Details:', 60, doc.y);\n\n      doc.moveDown(0.3);\n\n      param.subparameters.forEach((sub, idx) => {\n        console.log(`     ${idx + 1}. ${sub.name}: score=${sub.score}, interpretation=\"${sub.interpretation}\"`);\n\n        doc.fontSize(8)\n           .fillColor('#666666')\n           .font('Helvetica')\n           .text(`â€¢ ${sub.name}: `, 70, doc.y, { continued: true })\n           .font('Helvetica-Bold')\n           .fillColor(sub.score === 1 ? '#38A169' : '#E53E3E')\n           .text(`${sub.score === 1 ? 'âœ“' : 'âœ—'}`, { continued: true })\n           .fillColor('#666666')\n           .font('Helvetica')\n           .text(` ${sub.interpretation || ''}`, { width: 450 });\n\n        // Add details if available\n        if (sub.details) {\n          doc.fontSize(7)\n             .fillColor('#999999')\n             .text(`  ${sub.details}`, 80, doc.y);\n        }\n\n        doc.moveDown(0.2);\n      });\n    } else {\n      console.log(`   âš ï¸ No sub-metrics for ${param.name}`);\n    }\n\n    doc.moveDown(1.5);\n  }\n\n  /**\n   * Add summary section\n   */\n  addSummarySection(doc, summary) {\n    const y = doc.y;\n\n    if (y > 650) {\n      doc.addPage();\n    }\n\n    doc.fontSize(14)\n       .fillColor('#323956')\n       .font('Helvetica-Bold')\n       .text('Overall Summary', 50, doc.y);\n\n    doc.moveDown(0.5);\n\n    doc.fontSize(10)\n       .fillColor('#666666')\n       .font('Helvetica')\n       .text(summary, {\n         width: 495,\n         align: 'justify'\n       });\n\n    doc.moveDown(1);\n  }\n\n  /**\n   * Add recommendations\n   */\n  addRecommendations(doc, recommendations) {\n    const y = doc.y;\n\n    if (y > 650) {\n      doc.addPage();\n    }\n\n    doc.fontSize(14)\n       .fillColor('#323956')\n       .font('Helvetica-Bold')\n       .text('Recommendations', 50, doc.y);\n\n    doc.moveDown(0.5);\n\n    recommendations.forEach(rec => {\n      doc.fontSize(9)\n         .fillColor('#666666')\n         .font('Helvetica')\n         .text(`â€¢ ${rec}`, 60, doc.y, {\n           width: 475\n         });\n\n      doc.moveDown(0.3);\n    });\n  }\n\n  /**\n   * Add footer\n   */\n  addFooter(doc) {\n    const bottomY = 750;\n\n    doc.fontSize(7)\n       .fillColor('#999999')\n       .text('This report is generated using AI-powered analysis and should be interpreted by a qualified healthcare professional.',\n             50, bottomY, {\n               width: 495,\n               align: 'center'\n             });\n\n    doc.fontSize(7)\n       .text('Â© 2025 NeuroSense360. Powered by Google Gemini AI.',\n             50, bottomY + 15, {\n               width: 495,\n               align: 'center'\n             });\n  }\n\n  /**\n   * Get color for bucket classification\n   */\n  getBucketColor(bucketOrColor) {\n    // If it's already a hex color\n    if (bucketOrColor && bucketOrColor.startsWith('#')) {\n      return bucketOrColor;\n    }\n\n    // Default color mapping\n    const colorMap = {\n      'Poor': '#E53E3E',\n      'Below Average': '#F56565',\n      'Average': '#ED8936',\n      'Good': '#48BB78',\n      'Excellent': '#38A169',\n      'Low': '#E53E3E',\n      'Moderate': '#ED8936',\n      'High': '#F56565'\n    };\n\n    return colorMap[bucketOrColor] || '#4299E1';\n  }\n}\n\nmodule.exports = GeminiPdfGenerator;\n","numLines":470,"startLine":1,"totalLines":470}}}
{"parentUuid":"64d715b3-783f-44e4-9456-4c8ae12e479f","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C9WhtcdhorNVwsMCAARD6u","type":"tool_result","content":"D:\\Todays\\Neuro360\\server\\services\\aiPdfGeneratorEnhanced.js:742:        temperature: 0.7,\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:242:        temperature: 0.7,\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"58fc9404-4071-4a9e-a254-7f9e4385f740","timestamp":"2025-12-03T07:34:48.796Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"D:\\Todays\\Neuro360\\server\\services\\aiPdfGeneratorEnhanced.js:742:        temperature: 0.7,\r\nD:\\Todays\\Neuro360\\server\\services\\aiPdfGenerator.js:242:        temperature: 0.7,","numLines":2,"appliedLimit":20}}
{"parentUuid":"58fc9404-4071-4a9e-a254-7f9e4385f740","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XvgjmKKQccNuXUZeSimb9M","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I have a complete picture. Let me check if there are temperature configurations in the Gemini service:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7004,"cache_read_input_tokens":65811,"cache_creation":{"ephemeral_5m_input_tokens":7004,"ephemeral_1h_input_tokens":0},"output_tokens":168,"service_tier":"standard"}},"requestId":"req_011CVjNJKZx8yixC3dS8xA2r","type":"assistant","uuid":"b4ee68c0-00d7-425c-a933-5829f4e6b34b","timestamp":"2025-12-03T07:35:11.558Z"}
{"parentUuid":"b4ee68c0-00d7-425c-a933-5829f4e6b34b","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XvgjmKKQccNuXUZeSimb9M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BJfFqrKrpdUXAg4QLvdbTz","name":"Grep","input":{"pattern":"getGenerativeModel|generateContent","path":"D:\\Todays\\Neuro360\\server\\services","output_mode":"content","-B":2,"-A":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7004,"cache_read_input_tokens":65811,"cache_creation":{"ephemeral_5m_input_tokens":7004,"ephemeral_1h_input_tokens":0},"output_tokens":168,"service_tier":"standard"}},"requestId":"req_011CVjNJKZx8yixC3dS8xA2r","type":"assistant","uuid":"e403f2af-aead-4055-97e5-a26c350a5712","timestamp":"2025-12-03T07:35:13.141Z"}
{"parentUuid":"e403f2af-aead-4055-97e5-a26c350a5712","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BJfFqrKrpdUXAg4QLvdbTz","type":"tool_result","content":"D:\\Todays\\Neuro360\\server\\services\\qeegParser.js-11-class QEEGParser {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-12-  /**\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:13:   * Fetch available Gemini models that support generateContent\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-14-   * @returns {Promise<Array>} List of available models\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-15-   */\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-16-  static async fetchAvailableModels() {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-17-    try {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-18-      console.log('ğŸ” Fetching available Gemini models...');\r\n--\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-28-      const data = await response.json();\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-29-\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:30:      // Filter models that support generateContent\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-31-      const supportedModels = (data.models || []).filter(model =>\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:32:        model.supportedGenerationMethods?.includes('generateContent')\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-33-      );\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-34-\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:35:      console.log(`âœ… Found ${supportedModels.length} models that support generateContent:`);\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-36-      supportedModels.forEach(model => {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-37-        console.log(`   - ${model.name}`);\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-38-      });\r\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"0a2ff38a-5ae0-4b10-a2c2-2cda9a7d1ea0","timestamp":"2025-12-03T07:35:14.676Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"D:\\Todays\\Neuro360\\server\\services\\qeegParser.js-11-class QEEGParser {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-12-  /**\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:13:   * Fetch available Gemini models that support generateContent\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-14-   * @returns {Promise<Array>} List of available models\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-15-   */\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-16-  static async fetchAvailableModels() {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-17-    try {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-18-      console.log('ğŸ” Fetching available Gemini models...');\r\n--\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-28-      const data = await response.json();\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-29-\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:30:      // Filter models that support generateContent\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-31-      const supportedModels = (data.models || []).filter(model =>\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:32:        model.supportedGenerationMethods?.includes('generateContent')\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-33-      );\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-34-\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js:35:      console.log(`âœ… Found ${supportedModels.length} models that support generateContent:`);\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-36-      supportedModels.forEach(model => {\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-37-        console.log(`   - ${model.name}`);\r\nD:\\Todays\\Neuro360\\server\\services\\qeegParser.js-38-      });\r","numLines":20,"appliedLimit":20}}
{"parentUuid":"0a2ff38a-5ae0-4b10-a2c2-2cda9a7d1ea0","isSidechain":true,"userType":"external","cwd":"D:\\Todays\\Neuro360","sessionId":"b76b9fa2-b7b9-4263-ba26-f5908112b50d","version":"2.0.33","gitBranch":"main","agentId":"d09b2004","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01K92EK3AhDZ4tMobJw43NBP","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding. Let me present my findings:\n\n# CRITICAL ISSUE FOUND: Non-Deterministic QEEG Calculations\n\n## Executive Summary\nI've identified **THE PRIMARY SOURCE** of non-deterministic behavior: **Gemini AI data extraction is inherently non-deterministic**. Every time you upload the same PDF, Gemini AI may extract slightly different values from the PDF, leading to different calculation results.\n\n---\n\n## Sources of Non-Deterministic Behavior\n\n### 1. PRIMARY ISSUE: Gemini AI Extraction (qeegParser.js)\n**SEVERITY: CRITICAL - This is the main culprit**\n\n**Location:** `D:\\Todays\\Neuro360\\server\\services\\qeegParser.js` (lines 461-606)\n\n**Problem:**\n- Gemini AI is used to extract QEEG data from PDFs via the `parsePDF()` method\n- **AI models are inherently non-deterministic** - they can return different values for the same input\n- There is **NO temperature parameter configured** to control randomness\n- Even with temperature=0, Gemini may still produce slight variations\n\n**Evidence:**\n```javascript\n// Line 509 - Model initialized WITHOUT temperature config\ngeminiModel = genAI.getGenerativeModel({ model: modelName });\n\n// Line 529 - Gemini called for data extraction\nconst result = await geminiModel.generateContent(prompt);\n```\n\n**Impact:**\n- **Same PDF â†’ Different extracted values â†’ Different calculations â†’ Different scores**\n- This explains why uploading the same report multiple times gives different results\n\n**Specific values affected:**\n- All absolute power values (Theta, Alpha, Beta, HiBeta, Delta)\n- All relative power values\n- Alpha Peak Frequency\n- Every channel (Fz, Cz, Pz, F3, F4, C3, C4, P3, P4)\n\n---\n\n### 2. SECONDARY ISSUE: Default Values in Alpha Peak (algorithmCalculator.js)\n**SEVERITY: MEDIUM**\n\n**Location:** `D:\\Todays\\Neuro360\\server\\services\\algorithmCalculator.js` (lines 150-173)\n\n**Problem:**\n```javascript\n// Line 153 - Uses fallback values which may differ\nconst alphaPeak = this.data.EC?.special?.alphaPeak || this.data.EC?.special?.O1 || null;\n```\n\n**Issue:** \n- If `alphaPeak` is missing, it falls back to `O1`\n- If both are missing, returns `null`\n- This conditional logic could produce different results if extraction is inconsistent\n\n---\n\n### 3. Floating-Point Precision (algorithmCalculator.js)\n**SEVERITY: LOW**\n\n**Locations:**\n- Line 129: `const avgRatio = (fzRatio + czRatio) / 2;`\n- Line 248: `const avgRatio = (fzRatio + czRatio) / 2;`\n- Line 320: `const modulation = ((ecAlpha - eoAlpha) / ecAlpha) * 100;`\n- Line 356: `const avgTheta = (fzTheta + czTheta) / 2;`\n\n**Issue:** \n- JavaScript floating-point arithmetic can have minor precision variations\n- However, this is **NOT the main issue** - differences would be in the 15th decimal place\n- The threshold comparisons could be affected if values are exactly on the boundary\n\n**Example of potential issue:**\n```javascript\n// Line 288 - Threshold comparison\nconst score = ratio >= 9.9 ? 1 : 0;\n// If ratio = 9.899999999 vs 9.900000001, different scores\n```\n\n---\n\n### 4. NOT AN ISSUE: Date/Time Usage\n**SEVERITY: NONE**\n\nThe uses of `Date.now()` and `new Date()` found are ONLY used for:\n- File naming (line 61, 347 in qeegRoutes.js) - doesn't affect calculations\n- Timestamps in responses (line 488) - metadata only\n- PDF generation timestamps (line 241, 272 in geminiPdfGenerator.js) - display only\n\n**These do NOT affect calculation results.**\n\n---\n\n### 5. NOT AN ISSUE: Math.random()\n**SEVERITY: NONE**\n\n**Location:** `D:\\Todays\\Neuro360\\server\\routes\\qeegRoutes.js` (line 61)\n\n```javascript\nconst uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n```\n\n**This is ONLY used for generating unique filenames** and does NOT affect calculations.\n\n---\n\n### 6. Calculation Logic is DETERMINISTIC\n**VERIFICATION: PASSED**\n\n**Good news:** The calculation logic in `algorithmCalculator.js` and `zscoreCalculator.js` is **fully deterministic**:\n- All threshold values are static constants\n- All comparisons use consistent operators\n- No random number generation in calculations\n- No date-dependent logic\n- All formulas are mathematical and reproducible\n\n---\n\n## Root Cause Analysis\n\n### The Problem Flow:\n\n```\n1. Same PDF uploaded â†’ \n2. Gemini AI extraction (NON-DETERMINISTIC) â†’ \n3. Slightly different values extracted â†’ \n4. Deterministic calculations run on different values â†’ \n5. Different final scores âŒ\n```\n\n### Why This Happens:\n\n**Gemini AI Behavior:**\n- Large Language Models use probabilistic sampling\n- Even with the same prompt and same PDF text, token selection varies\n- When extracting numerical values, slight variations occur:\n  - \"23.45\" might be extracted as \"23.4\" or \"23.5\" in different runs\n  - Values near table boundaries might be read differently\n  - Decimal precision may vary\n\n---\n\n## Recommendations to Fix Non-Determinism\n\n### CRITICAL FIXES (Must implement):\n\n#### 1. **Add Temperature=0 to Gemini Configuration**\n**File:** `qeegParser.js` (line 509)\n\n```javascript\n// CURRENT (NON-DETERMINISTIC):\ngeminiModel = genAI.getGenerativeModel({ model: modelName });\n\n// FIX (MORE DETERMINISTIC):\ngeminiModel = genAI.getGenerativeModel({ \n  model: modelName,\n  generationConfig: {\n    temperature: 0,      // Minimum randomness\n    topK: 1,            // Only pick most likely token\n    topP: 1             // No nucleus sampling\n  }\n});\n```\n\n**Impact:** This will significantly reduce (but not eliminate) variation in Gemini responses.\n\n#### 2. **Implement Extraction Result Caching**\n**Approach:** Cache Gemini extraction results by PDF hash\n\n```javascript\n// Pseudo-code for implementation:\nconst crypto = require('crypto');\n\n// Calculate MD5 hash of PDF\nconst pdfHash = crypto.createHash('md5').update(pdfBuffer).digest('hex');\n\n// Check cache first\nconst cachedResult = await cache.get(pdfHash);\nif (cachedResult) {\n  console.log('âœ… Using cached extraction result (deterministic)');\n  return cachedResult;\n}\n\n// Extract and cache\nconst extractedData = await geminiExtract(pdf);\nawait cache.set(pdfHash, extractedData, { ttl: 86400 }); // 24hr cache\nreturn extractedData;\n```\n\n**Impact:** **100% deterministic** for same PDFs - same PDF always gets same values.\n\n#### 3. **Add Extraction Validation & Normalization**\n**File:** `qeegParser.js` (after line 546)\n\n```javascript\n// Validate and normalize extracted values\nfunction normalizeExtractedValue(value, decimalPlaces = 2) {\n  if (value === null || value === undefined) return null;\n  \n  // Round to consistent decimal places\n  return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);\n}\n\n// Apply to all extracted values\nObject.keys(extractedData.absolute).forEach(channel => {\n  Object.keys(extractedData.absolute[channel]).forEach(band => {\n    extractedData.absolute[channel][band] = \n      normalizeExtractedValue(extractedData.absolute[channel][band]);\n  });\n});\n```\n\n**Impact:** Reduces precision-related variations.\n\n#### 4. **Alternative: Use Deterministic PDF Parser**\n**Best long-term solution:**\n\nReplace Gemini AI extraction with a deterministic PDF parsing library:\n- Use `pdf-parse` or `pdfjs-dist` to extract text\n- Use regex patterns to locate and extract numerical values\n- Parse table structures programmatically\n\n**Benefits:**\n- **100% deterministic** - same PDF always produces same values\n- Faster processing (no API calls)\n- No API costs\n- No rate limits\n\n**Drawbacks:**\n- Requires PDF format consistency\n- More brittle to PDF layout changes\n- Initial development effort\n\n---\n\n### OPTIONAL FIXES (Nice to have):\n\n#### 5. **Add Consistent Rounding to Threshold Comparisons**\n**File:** `algorithmCalculator.js` (multiple locations)\n\n```javascript\n// Instead of:\nconst score = ratio >= 9.9 ? 1 : 0;\n\n// Use:\nconst score = Math.round(ratio * 10) / 10 >= 9.9 ? 1 : 0;\n```\n\n#### 6. **Add Deterministic Alpha Peak Fallback**\n**File:** `algorithmCalculator.js` (line 153)\n\n```javascript\n// Current:\nconst alphaPeak = this.data.EC?.special?.alphaPeak || this.data.EC?.special?.O1 || null;\n\n// Fix: Log which value is used\nconst alphaPeak = this.data.EC?.special?.alphaPeak \n  || this.data.EC?.special?.O1 \n  || 10.0; // Fixed default instead of null\n\nconsole.log(`Alpha Peak source: ${this.data.EC?.special?.alphaPeak ? 'alphaPeak' : 'O1 fallback'}`);\n```\n\n---\n\n## Testing Recommendations\n\n### Test Protocol for Determinism:\n\n1. **Upload same PDF 10 times**\n2. **Compare ALL extracted values** (not just final scores)\n3. **Log every intermediate calculation**\n4. **Verify byte-for-byte identical results**\n\n### Test Script:\n```javascript\nconst results = [];\nfor (let i = 0; i < 10; i++) {\n  const result = await processQEEG(samePDF);\n  results.push(result);\n}\n\n// Check if all results are identical\nconst allIdentical = results.every(r => \n  JSON.stringify(r) === JSON.stringify(results[0])\n);\n\nconsole.log('Determinism test:', allIdentical ? 'PASSED âœ…' : 'FAILED âŒ');\n```\n\n---\n\n## Conclusion\n\n**The root cause is clear:** Gemini AI extraction is non-deterministic, causing the same PDF to produce different numerical values on each upload. The calculation logic itself is fine - it's deterministic and correct.\n\n**Priority fixes:**\n1. **HIGHEST:** Implement PDF extraction caching (100% fix)\n2. **HIGH:** Add temperature=0 to Gemini config (reduces variation)\n3. **MEDIUM:** Consider switching to deterministic PDF parser (long-term best solution)\n4. **LOW:** Add rounding normalization to extracted values\n\n**Would you like me to implement these fixes?** I can:\n- Add temperature=0 configuration\n- Implement extraction result caching\n- Create a deterministic PDF parser alternative\n- Add validation and normalization layers"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1056,"cache_read_input_tokens":72815,"cache_creation":{"ephemeral_5m_input_tokens":1056,"ephemeral_1h_input_tokens":0},"output_tokens":2807,"service_tier":"standard"}},"requestId":"req_011CVjNLDuST3auwEH9hD8CA","type":"assistant","uuid":"af748991-4aa6-4333-a8ad-6c80887df509","timestamp":"2025-12-03T07:36:27.894Z"}
