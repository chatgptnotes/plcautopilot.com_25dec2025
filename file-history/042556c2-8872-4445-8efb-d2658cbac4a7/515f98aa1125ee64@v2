const { GoogleGenerativeAI } = require('@google/generative-ai');
const rateLimiter = require('./geminiRateLimiter'); // Shared rate limiter

class GeminiService {
  constructor() {
    console.log('\nüîß Initializing Gemini Service...');
    this.apiKey = process.env.GEMINI_API_KEY;

    if (!this.apiKey) {
      console.error('‚ùå CRITICAL: GEMINI_API_KEY not found in environment variables!');
      console.error('   Please check your .env file');
    } else {
      console.log('‚úÖ Gemini API Key found');
      console.log('   Key length:', this.apiKey.length);
      console.log('   Key preview:', `${this.apiKey.substring(0, 15)}...`);
    }

    this.genAI = this.apiKey ? new GoogleGenerativeAI(this.apiKey) : null;
    this.model = null;
    console.log('‚úÖ Gemini Service initialized\n');
  }

  /**
   * Fetch available Gemini models
   */
  async fetchAvailableModels() {
    try {
      console.log('üîç Fetching available Gemini models for PDF generation...');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1/models?key=${this.apiKey}`
      );

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      const supportedModels = (data.models || []).filter(model =>
        model.supportedGenerationMethods?.includes('generateContent')
      );

      console.log(`‚úÖ Found ${supportedModels.length} models for PDF generation`);
      return supportedModels;
    } catch (error) {
      console.error('‚ùå Failed to fetch models:', error.message);
      return [];
    }
  }

  /**
   * Select best model for PDF generation
   */
  selectBestModel(models) {
    if (!models || models.length === 0) return null;

    // Prefer Gemini 3 Pro Preview (latest model, best reasoning)
    // Fallback to Flash models for speed if 3 Pro unavailable
    const preferences = ['3-pro-preview', 'flash', 'pro'];

    for (const preference of preferences) {
      const found = models.find(m =>
        m.name.toLowerCase().includes(preference)
      );
      if (found) {
        console.log(`‚úÖ Selected model for PDF: ${found.name}`);
        if (found.name.includes('3-pro')) {
          console.log('   üöÄ Using Gemini 3 Pro - Latest model with advanced reasoning');
        }
        return found.name;
      }
    }

    console.log(`‚úÖ Using first available model: ${models[0].name}`);
    return models[0].name;
  }

  /**
   * Initialize the Gemini model
   */
  async initModel() {
    if (!this.genAI) {
      throw new Error('Gemini API not initialized. Please check GEMINI_API_KEY.');
    }

    console.log('üîß Initializing Gemini model for PDF generation...');
    console.log('üîë API Key status:', this.apiKey ? 'Present' : 'MISSING');

    // Fetch available models dynamically
    const availableModels = await this.fetchAvailableModels();

    if (availableModels.length === 0) {
      console.error('\n‚ùå No models available for PDF generation!');
      console.error('Please check your GEMINI_API_KEY at https://aistudio.google.com/apikey\n');
      throw new Error('No Gemini models available. Check your API key.');
    }

    // Select best model
    const modelName = this.selectBestModel(availableModels);

    if (!modelName) {
      throw new Error('Could not select a valid model for PDF generation');
    }

    // Initialize model with full path and deterministic config
    console.log(`üîß Initializing model: ${modelName}`);
    this.model = this.genAI.getGenerativeModel({
      model: modelName,
      generationConfig: {
        temperature: 0,      // Minimum randomness for deterministic generation
        topK: 1,            // Only pick most likely token
        topP: 1             // No nucleus sampling
      }
    });

    // Test the model
    console.log('üìû Testing model...');
    try {
      const testResult = await this.model.generateContent('Hello');
      const testResponse = await testResult.response;
      testResponse.text();
      console.log('‚úÖ Model initialized and tested successfully for PDF generation');
    } catch (testError) {
      console.error(`‚ùå Model test failed:`, testError.message);
      throw new Error(`Failed to test model ${modelName}: ${testError.message}`);
    }

    return this.model;
  }

  /**
   * System prompt for brain performance report generation
   */
  getReportGenerationPrompt() {
    return `You are an expert neuroscience INFOGRAPHIC report generator powered by Gemini AI. Your primary task is to create a stunning, comprehensive, and visually captivating brain performance INFOGRAPHIC for patients.

‚ö†Ô∏è CRITICAL INSTRUCTION BEFORE YOU START:
YOU MUST USE THE EXACT SCORES PROVIDED IN THE INPUT DATA. DO NOT generate or invent your own scores. The scores are calculated from real patient brain data and MUST be preserved EXACTLY as provided. Your job is ONLY to create interpretations and visualizations - NOT to calculate or modify scores.

üéØ YOUR ROLE:
Generate a professional single-page A4 INFOGRAPHIC-STYLE brain health report based on QEEG (Quantitative Electroencephalography) analysis results. This is an INFOGRAPHIC, not a text document - prioritize visual presentation, clarity, and engaging design. The infographic must be informative yet accessible to non-medical readers.

üìä INPUT DATA:
You will receive 7 brain performance parameters with their ACTUAL CALCULATED SCORES, classifications, and sub-metrics:
1. **Cognition** - Mental processing, focus ability, and alpha-theta balance
2. **Stress** - Arousal levels, relaxation capacity, and regeneration ability
3. **Focus & Attention** - Concentration ability, theta levels, and mental alertness
4. **Burnout & Fatigue** - Energy levels, exhaustion markers, and delta wave patterns
5. **Emotional Regulation** - Mood stability, frontal alpha asymmetry, and emotional control
6. **Learning** - Cognitive flexibility, memory formation, and neural plasticity
7. **Creativity** - Divergent thinking, relaxation state, and innovative capacity

üìã SCORING SYSTEM:
- Each parameter is scored from 0-3 points
- Classification: Low (0-1), Medium (2), High (3)
- Sub-metrics contribute individual points to the total score
- **Special Note**: For Stress and Burnout parameters, LOWER scores are BETTER (0/3 = Healthy, 3/3 = High Problem)

üé® INFOGRAPHIC DESIGN REQUIREMENTS:

**REMEMBER: This is an INFOGRAPHIC - Visual Appeal is CRITICAL!**

1. **Infographic Visual Design**:
   - INFOGRAPHIC-STYLE: Modern, clean, colorful, and engaging layout
   - Use vibrant but professional color palette throughout
   - Each parameter MUST have a distinct visual identity with unique colors
   - Bold, eye-catching icons and graphical elements for each brain function
   - Large, prominent score displays with visual progress indicators
   - Color-coded scoring badges/banners (Green = Optimal, Yellow = Moderate, Red = Needs Attention)
   - Think: Magazine infographic quality, not medical report
   - Visual hierarchy: Big scores ‚Üí Clear icons ‚Üí Short summaries ‚Üí Details

2. **Content Structure**:
   - Patient-friendly language (avoid heavy medical jargon)
   - One-line impactful summary for each parameter
   - Clear explanation of what each metric means in daily life
   - Practical interpretation of scores
   - Holistic overall summary

3. **Infographic Parameter Presentation**:
   - Parameter name in BOLD, LARGE font with matching icon
   - Score displayed PROMINENTLY (e.g., "2/3 - Medium") with colored background badge
   - Eye-catching color-coded badge/banner based on classification
   - Visual progress bar or circular indicator for scores
   - List all sub-metrics with bold checkmarks (‚úì) or crosses (‚úó)
   - Ultra-concise explanation for each sub-metric (1 sentence max)
   - Use boxes, borders, and visual separators for clarity

4. **Color Coding Guidelines**:
   For HEALTH parameters (Cognition, Focus, Emotional Regulation, Learning, Creativity):
   - High (3/3): #38A169 (Green) - Excellent performance
   - Medium (2/3): #F59E0B (Amber) - Good, room for improvement
   - Low (0-1/3): #E53E3E (Red) - Needs attention

   For PROBLEM parameters (Stress, Burnout):
   - Low (0/3): #38A169 (Green) - Healthy, no issues
   - Medium (1-2/3): #F59E0B (Amber) - Moderate concern
   - High (3/3): #E53E3E (Red) - High concern

5. **Interpretations Guidelines**:
   - Explain what HIGH scores mean for each parameter
   - Explain what LOW scores mean
   - Connect brain metrics to real-life implications
   - Examples:
     * "High Focus & Attention (3/3): Your brain shows excellent concentration ability and minimal distracting theta activity"
     * "Low Stress (0/3): Great news! Your brain shows healthy relaxation patterns and low arousal"
     * "Medium Cognition (2/3): Good cognitive function with room for optimization in alpha-theta balance"

6. **Sub-Metrics Explanation Examples**:
   - "Focus Score (Theta:Beta Ratio): ‚úì Optimal - Your frontal brain regions show balanced activity for sustained attention"
   - "Relaxation Score: ‚úó Below threshold - Your brain may have difficulty shifting into relaxed states"
   - "Alpha Peak: ‚úì Normal - Healthy alpha rhythm frequency indicates good brain maturation"

7. **Overall Summary Requirements**:
   - Synthesize all 7 parameters into a cohesive narrative
   - Highlight strengths and areas for improvement
   - Provide context about what the overall pattern suggests
   - Maintain encouraging and constructive tone
   - 3-5 sentences maximum

8. **Recommendations**:
   - Provide 4-6 actionable, personalized recommendations
   - Base suggestions on the actual scores received
   - Include lifestyle, cognitive training, or mindfulness suggestions
   - Keep recommendations practical and achievable

üì§ OUTPUT FORMAT FOR INFOGRAPHIC:

‚ö†Ô∏è REMEMBER: Use the EXACT score, maxScore, and bucket values from the INPUT DATA. Do not modify them!

Return ONLY a valid JSON object (no markdown, no code blocks, no explanations) with this EXACT structure optimized for INFOGRAPHIC design:

{
  "title": "Brain Performance Infographic",
  "subtitle": "Visual Analysis of Your Brain Health Metrics",
  "patientSummary": "A comprehensive 3-5 sentence summary synthesizing all parameters, highlighting key strengths and areas for growth, with an encouraging and engaging tone suitable for an infographic",
  "parameters": [
    {
      "name": "Cognition",
      "score": 2,  /* ‚ö†Ô∏è USE EXACT SCORE FROM INPUT - this is just an example */
      "maxScore": 3,  /* ‚ö†Ô∏è USE EXACT maxScore FROM INPUT */
      "bucket": "Medium",  /* ‚ö†Ô∏è USE EXACT bucket FROM INPUT */
      "bucketColor": "#F59E0B",
      "icon": "üß†",
      "summary": "One ultra-impactful, short sentence summarizing this parameter (infographic-style: punchy and clear)",
      "subparameters": [
        {
          "name": "Focus Score (Theta:Beta Ratio)",
          "score": 1,  /* ‚ö†Ô∏è USE EXACT SUBPARAMETER SCORE FROM INPUT */
          "interpretation": "Clear, concise explanation (max 15 words) of what this score means",
          "details": "Technical detail: actual value and threshold"
        }
      ]
    }
  ],
  "recommendations": [
    "Specific actionable recommendation (concise, infographic-friendly)",
    "Another personalized suggestion (short and clear)",
    "Lifestyle tip (engaging and practical)",
    "Cognitive exercise or mindfulness practice (action-oriented)"
  ],
  "layoutSuggestions": {
    "colorScheme": "Vibrant infographic palette: Deep blue header (#323956), colorful parameter badges, white background (#FFFFFF), accent colors for visual interest",
    "structure": "Infographic grid layout: 2 columns for parameters with visual cards, bold header with title and patient info, eye-catching summary and recommendations section at bottom with icons"
  }
}

üö® CRITICAL INFOGRAPHIC REQUIREMENTS:
1. THIS IS AN INFOGRAPHIC - Keep all text concise, punchy, and visual-friendly
2. Return PURE JSON only - no code blocks, no markdown, no extra text
3. Include ALL subparameters from input data - don't skip any
4. ‚ö†Ô∏è CRITICAL: Use the EXACT score values from the input data - DO NOT generate your own scores
5. ‚ö†Ô∏è CRITICAL: Copy the score, maxScore, and bucket values EXACTLY as provided in the input
6. Remember: For Stress and Burnout, LOW scores are GOOD, HIGH scores are CONCERNING
7. Each subparameter must have the EXACT score (0 or 1) from the input data
8. Icons should be colorful brain-related emojis: üß† üí° üéØ ‚ö° üòå üìö üé® üåü ‚öñÔ∏è üî• or similar
9. Make interpretations ultra-relatable - focus on real-world meaning, avoid EEG jargon
10. Ensure bucketColor uses VIBRANT, DISTINCT hex codes for infographic appeal
11. Overall tone: Engaging, visual, magazine-quality infographic style
12. Summaries: Short, impactful, easy to scan (think social media infographic)
13. ‚ö†Ô∏è DO NOT INVENT OR MODIFY SCORES - Use input data scores verbatim!

‚ú® INFOGRAPHIC QUALITY CHECKLIST:
- ‚ö†Ô∏è Did you copy the EXACT score values from the input data without modification?
- ‚ö†Ô∏è Did you use the EXACT bucket/classification from the input data?
- Are all 7 parameters included with distinct visual identities?
- Do all parameters have their sub-metrics listed with visual indicators?
- Are interpretations ultra-concise and infographic-friendly (no long paragraphs)?
- Is the color coding vibrant and correct (especially for Stress/Burnout inverse scoring)?
- Does the summary provide a holistic view in an engaging, scannable format?
- Are recommendations specific, actionable, and infographic-ready?
- Is the overall design ready for a beautiful, magazine-quality infographic?

‚ö†Ô∏è FINAL REMINDER: Your ONLY job is to create interpretations and visual suggestions. The scores are ALREADY CALCULATED from real brain data. Copy them EXACTLY as provided!

Generate the INFOGRAPHIC report now based on the brain parameters data provided below. Remember: INFOGRAPHIC = Visual, Colorful, Concise, Engaging!`;
  }

  /**
   * Generate brain performance report using Gemini AI
   * @param {Object} brainParameters - The 7 brain parameters with scores and buckets
   * @returns {Promise<Object>} Generated report structure
   */
  async generateBrainPerformanceReport(brainParameters) {
    try {
      console.log('\nüîë Checking Gemini API configuration...');
      console.log('   API Key exists:', !!this.apiKey);
      console.log('   API Key length:', this.apiKey ? this.apiKey.length : 0);
      console.log('   API Key preview:', this.apiKey ? `${this.apiKey.substring(0, 10)}...` : 'MISSING');

      if (!this.model) {
        console.log('üì± Initializing Gemini model...');
        await this.initModel();
      }

      console.log('\nü§ñ Generating brain performance report with Gemini AI...');
      console.log('üìä Input parameters count:', Object.keys(brainParameters).length);

      // Log actual scores being sent
      console.log('üìä ACTUAL SCORES BEING SENT TO GEMINI:');
      Object.keys(brainParameters).forEach(key => {
        const param = brainParameters[key];
        if (param && param.score !== undefined) {
          console.log(`   ${key}: ${param.score}/${param.maxScore} (${param.bucket})`);
        }
      });

      // Create the prompt with system instructions and data
      const systemPrompt = this.getReportGenerationPrompt();
      const dataPrompt = `\n\n‚ö†Ô∏è CRITICAL: Use these EXACT scores - do not modify them!\n\nBrain Parameters Data:\n${JSON.stringify(brainParameters, null, 2)}\n\n‚ö†Ô∏è REMINDER: Copy the score, maxScore, and bucket values EXACTLY as shown above. Do not generate your own scores!\n\nPlease generate the infographic report description in JSON format as specified.`;

      const fullPrompt = systemPrompt + dataPrompt;
      console.log('üìù Prompt length:', fullPrompt.length, 'characters');

      // üõ°Ô∏è RATE LIMITING: Wait before making API call to respect quotas
      await rateLimiter.waitForRateLimit();

      // Generate content
      console.log('‚è≥ Calling Gemini API...');
      const result = await this.model.generateContent(fullPrompt);

      // ‚úÖ Record successful API call for quota tracking
      rateLimiter.recordRequest();

      const response = await result.response;
      const text = response.text();

      console.log('‚úÖ Gemini response received!');
      console.log('   Response length:', text.length, 'characters');

      // Try to parse JSON from the response
      let reportData;
      try {
        // Remove markdown code blocks if present
        const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        reportData = JSON.parse(jsonText);

        // Log what Gemini returned
        console.log('\nüìä SCORES RETURNED BY GEMINI:');
        if (reportData.parameters) {
          reportData.parameters.forEach(param => {
            console.log(`   ${param.name}: ${param.score}/${param.maxScore} (${param.bucket})`);
          });

          // VALIDATION: Check if Gemini changed the scores
          console.log('\nüîç VALIDATING SCORES (Input vs Gemini Output):');
          reportData.parameters.forEach(param => {
            const paramKey = param.name.replace(/\s+/g, '');
            const inputParam = brainParameters[paramKey];
            if (inputParam) {
              const scoreMatch = inputParam.score === param.score;
              const bucketMatch = inputParam.bucket === param.bucket;
              if (!scoreMatch || !bucketMatch) {
                console.log(`   ‚ö†Ô∏è MISMATCH for ${param.name}:`);
                console.log(`      Input:  score=${inputParam.score}, bucket=${inputParam.bucket}`);
                console.log(`      Gemini: score=${param.score}, bucket=${param.bucket}`);
              } else {
                console.log(`   ‚úÖ ${param.name}: Scores match correctly`);
              }
            }
          });
        }
      } catch (parseError) {
        console.error('Failed to parse JSON response:', parseError);
        // Return raw text if JSON parsing fails
        reportData = {
          title: 'Brain Performance Report',
          rawContent: text,
          parameters: [],
          error: 'Failed to parse structured response'
        };
      }

      return {
        success: true,
        data: reportData,
        rawResponse: text
      };

    } catch (error) {
      console.error('\n‚ùå === GEMINI API ERROR ===');
      console.error('Error Type:', error.constructor.name);
      console.error('Error Message:', error.message);
      console.error('Error Code:', error.code || 'N/A');
      console.error('Error Status:', error.status || 'N/A');
      console.error('Full Error:', JSON.stringify(error, null, 2));
      console.error('Stack:', error.stack);
      console.error('==========================\n');

      return {
        success: false,
        error: error.message,
        errorDetails: {
          type: error.constructor.name,
          code: error.code,
          status: error.status
        },
        data: null
      };
    }
  }

  /**
   * Generate simple text completion
   * @param {string} prompt - The prompt text
   * @returns {Promise<string>} Generated text
   */
  async generateText(prompt) {
    try {
      if (!this.model) {
        await this.initModel();
      }

      // üõ°Ô∏è RATE LIMITING: Wait before making API call
      await rateLimiter.waitForRateLimit();

      const result = await this.model.generateContent(prompt);

      // ‚úÖ Record successful API call
      rateLimiter.recordRequest();

      const response = await result.response;
      return response.text();

    } catch (error) {
      console.error('Error generating text with Gemini:', error);
      throw error;
    }
  }

  /**
   * Test Gemini API connection
   */
  async testConnection() {
    try {
      const response = await this.generateText('Hello! Please respond with "OK" if you can read this.');
      console.log('Gemini API test response:', response);
      return { success: true, response };
    } catch (error) {
      console.error('Gemini API test failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get Gemini API quota status
   * @returns {Object} Current quota usage and limits
   */
  getQuotaStatus() {
    return rateLimiter.getQuotaStatus();
  }
}

module.exports = new GeminiService();
