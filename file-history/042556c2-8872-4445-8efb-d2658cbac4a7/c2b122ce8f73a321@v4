const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const pdfParse = require('pdf-parse');
const XLSX = require('xlsx');
const rateLimiter = require('./geminiRateLimiter'); // Shared rate limiter
const OpenAIParser = require('./openAIParser'); // OpenAI parser for fallback

// Initialize Gemini AI client
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
let geminiModel = null;

// AI Service Selection: 'gemini' or 'openai'
// Default to OpenAI if GEMINI is not preferred
const AI_SERVICE = process.env.AI_SERVICE || (process.env.OPENAI_API_KEY ? 'openai' : 'gemini');

// Debug: Log which AI service is being used
console.log('\nüîÄ ===== AI SERVICE CONFIGURATION =====');
console.log(`   AI_SERVICE env var: ${process.env.AI_SERVICE}`);
console.log(`   Selected AI service: ${AI_SERVICE}`);
console.log(`   OpenAI key present: ${!!process.env.OPENAI_API_KEY}`);
console.log(`   Gemini key present: ${!!process.env.GEMINI_API_KEY}`);
console.log('=====================================\n');

// In-memory cache for PDF extraction results (ensures deterministic behavior)
// Key: PDF MD5 hash ‚Üí Value: Extracted QEEG data
const extractionCache = new Map();

// Cache statistics for monitoring
const cacheStats = {
  hits: 0,
  misses: 0,
  totalExtractions: 0
};

class QEEGParser {
  /**
   * Fetch available Gemini models that support generateContent
   * @returns {Promise<Array>} List of available models
   */
  static async fetchAvailableModels() {
    try {
      console.log('üîç Fetching available Gemini models...');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1/models?key=${process.env.GEMINI_API_KEY}`
      );

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      // Filter models that support generateContent
      const supportedModels = (data.models || []).filter(model =>
        model.supportedGenerationMethods?.includes('generateContent')
      );

      console.log(`‚úÖ Found ${supportedModels.length} models that support generateContent:`);
      supportedModels.forEach(model => {
        console.log(`   - ${model.name}`);
      });

      return supportedModels;
    } catch (error) {
      console.error('‚ùå Failed to fetch models:', error.message);
      return [];
    }
  }

  /**
   * Select best available model from list
   * @param {Array} models - List of available models
   * @returns {string|null} Model name to use
   */
  static selectBestModel(models) {
    if (!models || models.length === 0) return null;

    // Priority: flash models (fastest) > pro models > any other
    const preferences = ['flash', 'pro'];

    for (const preference of preferences) {
      const found = models.find(m =>
        m.name.toLowerCase().includes(preference)
      );
      if (found) {
        console.log(`‚úÖ Selected model: ${found.name}`);
        return found.name;
      }
    }

    // Fallback to first available
    console.log(`‚úÖ Using first available model: ${models[0].name}`);
    return models[0].name;
  }

  /**
   * Validate Gemini API key is configured and appears valid
   * @throws {Error} if API key is missing or invalid format
   */
  static validateAPIKey() {
    const apiKey = process.env.GEMINI_API_KEY;

    // Check if key exists
    if (!apiKey || apiKey.trim() === '') {
      const error = new Error('GEMINI_API_KEY environment variable is not set');
      error.code = 'MISSING_API_KEY';
      throw error;
    }

    // Check if key is placeholder
    if (apiKey === 'your-gemini-api-key-here' || apiKey.includes('placeholder')) {
      const error = new Error('GEMINI_API_KEY is set to placeholder value. Please configure a valid Gemini API key.');
      error.code = 'INVALID_API_KEY';
      throw error;
    }

    console.log('‚úÖ Gemini API key validation passed');
    return true;
  }

  /**
   * Test Gemini API connection with a simple request
   * @returns {Promise<boolean>} true if connection successful
   * @throws {Error} if connection fails
   */
  static async testAPIConnection() {
    try {
      this.validateAPIKey();

      console.log('üîå Testing Gemini API connection...');

      if (!geminiModel) {
        console.log('üîë API Key check:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          throw new Error('No Gemini models available. Check your API key at https://aistudio.google.com/apikey');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model');
        }

        // Initialize model with full path
        console.log(`üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({ model: modelName });

        // Test it with simple call
        console.log('üìû Testing model with simple call...');
        const testResult = await geminiModel.generateContent('Hello');
        await testResult.response;
        console.log('‚úÖ Model initialized and tested successfully');
      }

      const result = await geminiModel.generateContent('Reply with OK');
      const response = await result.response;
      const text = response.text();

      if (text) {
        console.log('‚úÖ Gemini API connection successful');
        return true;
      } else {
        throw new Error('Gemini API returned unexpected response');
      }

    } catch (error) {
      console.error('‚ùå Gemini API connection test failed:', error.message);
      const enhancedError = new Error(`Gemini API connection test failed: ${error.message}`);
      enhancedError.code = 'API_CONNECTION_FAILED';
      enhancedError.originalError = error;
      throw enhancedError;
    }
  }

  /**
   * Detect report type (raw power values or Z-scores)
   * @param {Object} file - Multer file object
   * @returns {Promise<string>} 'raw' or 'zscore'
   */
  static async detectReportType(file) {
    try {
      console.log(`üîç Detecting report type for: ${file.originalname}`);

      const dataBuffer = fs.readFileSync(file.path);
      const pdfData = await pdfParse(dataBuffer);
      const text = pdfData.text.toLowerCase();

      // Keyword detection
      const zscoreKeywords = ['z-score', 'z score', 'z =', 'z=', 'standard deviation', 'sd from mean'];
      const rawKeywords = ['absolute power (Œºv¬≤)', 'absolute power (uv¬≤)', 'relative power (%)', 'Œºv¬≤', 'uv¬≤'];

      let zscoreCount = 0;
      let rawCount = 0;

      // Count keyword occurrences
      zscoreKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        zscoreCount += matches;
      });

      rawKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        rawCount += matches;
      });

      console.log(`   Z-score keywords found: ${zscoreCount}`);
      console.log(`   Raw power keywords found: ${rawCount}`);

      // Decision logic
      if (zscoreCount > rawCount && zscoreCount >= 3) {
        console.log(`‚úÖ Detected: Z-SCORE report`);
        return 'zscore';
      } else if (rawCount > zscoreCount && rawCount >= 2) {
        console.log(`‚úÖ Detected: RAW POWER report`);
        return 'raw';
      } else if (zscoreCount > 0 && rawCount > 0) {
        // Mixed report - check for table structure
        if (text.includes('z-score table') || text.includes('z score table')) {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring Z-SCORE`);
          return 'zscore';
        } else {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring RAW POWER`);
          return 'raw';
        }
      } else {
        // Fallback: assume raw if unclear
        console.warn(`‚ö†Ô∏è Could not clearly detect report type - defaulting to RAW POWER`);
        return 'raw';
      }

    } catch (error) {
      console.error(`‚ùå Error detecting report type for ${file.originalname}:`, error.message);
      // Safe default
      console.warn(`   Defaulting to RAW POWER mode`);
      return 'raw';
    }
  }

  /**
   * Main method to parse uploaded files
   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data
   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data
   * @returns {Object} Parsed QEEG data
   */
  static async parse(eyesOpenFile, eyesClosedFile) {
    try {
      console.log('\nüìÑ === QEEG File Parsing Started ===');
      console.log('  - Eyes Open:', eyesOpenFile?.originalname);
      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);

      // STEP 1: Detect report types
      console.log('\nüîç STEP 1: Detecting report types...');
      const eoReportType = await this.detectReportType(eyesOpenFile);
      const ecReportType = await this.detectReportType(eyesClosedFile);

      console.log(`\nüìä Detection Results:`);
      console.log(`  - Eyes Open: ${eoReportType.toUpperCase()}`);
      console.log(`  - Eyes Closed: ${ecReportType.toUpperCase()}`);

      // STEP 2: Validate matching types
      console.log('\n‚úì STEP 2: Validating report type consistency...');
      if (eoReportType !== ecReportType) {
        const error = new Error(
          `‚ùå Mismatched report types detected!\n\n` +
          `Eyes Open is ${eoReportType.toUpperCase()}, but Eyes Closed is ${ecReportType.toUpperCase()}.\n\n` +
          `Both files must be the same type (either both RAW POWER or both Z-SCORE reports).\n` +
          `Please upload matching report types and try again.`
        );
        error.code = 'REPORT_TYPE_MISMATCH';
        throw error;
      }

      const reportType = eoReportType;
      console.log(`‚úÖ Report type validated: ${reportType.toUpperCase()} mode\n`);

      // STEP 3: Determine file formats (pdf, csv, excel)
      console.log('üìÅ STEP 3: Determining file formats...');
      const eoFileType = this.getFileType(eyesOpenFile.originalname);
      const ecFileType = this.getFileType(eyesClosedFile.originalname);
      console.log(`  - Eyes Open: ${eoFileType}`);
      console.log(`  - Eyes Closed: ${ecFileType}\n`);

      // STEP 4: Parse each file with appropriate method
      console.log('üìñ STEP 4: Extracting data from files...');
      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO', reportType);
      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC', reportType);

      // STEP 5: Combine data with metadata
      console.log('\nüîó STEP 5: Combining data...');
      const combinedData = {
        EO: eyesOpenData,
        EC: eyesClosedData,
        dataType: reportType // Add metadata
      };

      console.log(`‚úÖ QEEG files parsed successfully in ${reportType.toUpperCase()} mode`);
      console.log('=== QEEG File Parsing Completed ===\n');
      return combinedData;

    } catch (error) {
      console.error('\n‚ùå === QEEG File Parsing Failed ===');
      console.error('Error:', error.message);
      if (error.code === 'REPORT_TYPE_MISMATCH') {
        // Re-throw mismatch errors with original message
        throw error;
      } else {
        throw new Error(`Failed to parse QEEG files: ${error.message}`);
      }
    }
  }

  /**
   * Determine file type from filename
   */
  static getFileType(filename) {
    const ext = path.extname(filename).toLowerCase();
    if (ext === '.pdf') return 'pdf';
    if (ext === '.csv') return 'csv';
    if (ext === '.xlsx' || ext === '.xls') return 'excel';
    throw new Error(`Unsupported file type: ${ext}`);
  }

  /**
   * Parse a single file based on its type
   */
  static async parseFile(file, fileType, condition, reportType = 'raw') {
    if (fileType === 'pdf') {
      return await this.parsePDF(file, condition, reportType);
    } else if (fileType === 'csv') {
      return this.parseCSV(file);
    } else if (fileType === 'excel') {
      return this.parseExcel(file);
    }
    throw new Error(`Unknown file type: ${fileType}`);
  }

  /**
   * Get extraction prompt based on report type
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   * @param {string} pdfText - PDF text content
   * @returns {string} Extraction prompt
   */
  static getExtractionPrompt(condition, reportType, pdfText) {
    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';

    if (reportType === 'zscore') {
      // Z-SCORE extraction prompt
      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.

**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.
- Negative values = below average (lower than normal)
- Zero (0) = average (normal)
- Positive values = above average (higher than normal)

Look for tables labeled with "Z-score", "Z score", "Z", or "Standard Deviation" in the headers.

Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract Z-scores for these frequency bands:
- Delta (1-4 Hz)
- Theta (4-8 Hz)
- Alpha (8-13 Hz)
- Beta (13-30 Hz)
- HiBeta / High Beta (20-30 Hz)

Also extract:
- Alpha Peak Frequency (Hz) and its Z-score if available

If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return ONLY this EXACT JSON format:
{
  "zscores": {
    "absolute": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    },
    "relative": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

PDF Content:
${pdfText.substring(0, 15000)}`;

    } else {
      // RAW POWER extraction prompt (highly improved for complete extraction)
      return `You are an expert QEEG data extraction specialist. Your task is to extract COMPLETE frequency band data from this ${conditionName} QEEG report PDF.

üéØ YOUR MISSION: Extract 100% COMPLETE DATA - No Missing Bands Allowed!

üìä WHAT TO EXTRACT:
Extract TWO complete tables:
1. **Absolute Power (ŒºV¬≤)** - Brain wave power in microvolts squared
2. **Relative Power (%)** - Percentage distribution (MUST sum to ~100% per channel)

üìç WHERE TO LOOK IN THE PDF:
- Usually on Pages 13 & 24 (for Eyes Open & Eyes Closed)
- Look for table headers like:
  * "Absolute Power" / "Absolute Spectral Power" / "Absolute" / "ABS"
  * "Relative Power" / "Relative Spectral Power" / "Relative" / "REL"
  * "Monopolar" / "Linked Ears" / "Average Reference"
- Tables may span multiple pages - check thoroughly!
- Sometimes bands are in separate sections or sub-tables

üß† CHANNELS TO EXTRACT (19 channels):
FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

üìä FREQUENCY BANDS (ALL 5 REQUIRED):
For EACH channel, you MUST extract ALL 5 bands:
1. **Delta** (Œ¥) - 0.5-4 Hz - Usually highest power
2. **Theta** (Œ∏) - 4-8 Hz
3. **Alpha** (Œ±) - 8-13 Hz - Often dominant when relaxed
4. **Beta** (Œ≤) - 13-30 Hz
5. **HiBeta** (High Beta / Œ≤Œ≤) - 30-50 Hz - Usually smallest

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ABSOLUTELY CRITICAL REQUIREMENTS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

1. **100% COMPLETENESS**: Extract ALL 5 bands for EVERY channel
   - If a band shows "0" or very small value (0.1, 0.01), INCLUDE IT
   - DO NOT leave any band as 0 unless it truly says 0 in the table

2. **VALIDATION CHECK**: For Relative Power, EACH channel must sum to ~100%
   Example: Fz: Delta(30%) + Theta(20%) + Alpha(25%) + Beta(20%) + HiBeta(5%) = 100%
   - If your extracted data doesn't sum to ~100% for EACH channel, YOU MADE A MISTAKE
   - Go back and find the missing bands!

3. **SEARCH THOROUGHLY**:
   - Check ALL pages of the PDF, not just the first page
   - Look for continuation of tables on next pages
   - Some PDFs have separate sub-tables for each band - combine them
   - Tables might be labeled "Page 1/2", "Page 2/2" - check both!

4. **DON'T SKIP CHANNELS**: All 19 channels should have complete data
   - If some channels are truly missing from PDF, use 0 for those
   - But most standard QEEG reports have all 19 channels

5. **PRESERVE EXACT VALUES**: Copy numbers exactly as they appear
   - Don't round or modify values
   - Include decimal places (e.g., 25.3, not 25)

üìã EXAMPLE OF **CORRECT** EXTRACTION (Relative Power):
{
  "Fz": {
    "Delta": 28.5,   // ‚úì Has value
    "Theta": 22.3,   // ‚úì Has value
    "Alpha": 25.1,   // ‚úì Has value
    "Beta": 18.9,    // ‚úì Has value
    "HiBeta": 5.2    // ‚úì Has value
  }
  // Sum = 100% ‚úì CORRECT!
}

‚ùå EXAMPLE OF **WRONG** EXTRACTION:
{
  "Fz": {
    "Delta": 28.5,
    "Theta": 22.3,
    "Alpha": 0,      // ‚ùå WRONG - Missing!
    "Beta": 0,       // ‚ùå WRONG - Missing!
    "HiBeta": 0      // ‚ùå WRONG - Missing!
  }
  // Sum = 50.8% ‚ùå INCOMPLETE! Find the missing bands!
}

üîç EXTRACTION STRATEGY:
1. First, locate the Absolute Power table - extract all bands for all channels
2. Then, locate the Relative Power table - extract all bands for all channels
3. Double-check: Does each channel's relative power sum to ~100%?
4. If NO, go back and search for missing data in other pages/sections
5. Extract Alpha Peak Frequency (usually noted as "Peak Alpha" or "APF")

Also extract Alpha Peak Frequency (APF) if available (typical range: 8-13 Hz).

**OUTPUT FORMAT RULES**:
- Return ONLY the JSON object (no markdown, no explanations, no code blocks)
- Just pure JSON starting with { and ending with }
- No \`\`\`json markers
- No text before or after the JSON

Return the data in this EXACT JSON format:
{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "O1": 10.0
  }
}

PDF Content:
${pdfText.substring(0, 15000)}`;
    }
  }

  /**
   * Calculate MD5 hash of PDF file for caching
   * @param {Buffer} dataBuffer - PDF file buffer
   * @returns {string} MD5 hash
   */
  static calculatePDFHash(dataBuffer) {
    return crypto.createHash('md5').update(dataBuffer).digest('hex');
  }

  /**
   * Normalize extracted value to consistent decimal places
   * Prevents precision-related variations
   * @param {number} value - The value to normalize
   * @param {number} decimalPlaces - Number of decimal places (default: 2)
   * @returns {number|null} Normalized value
   */
  static normalizeValue(value, decimalPlaces = 2) {
    if (value === null || value === undefined || isNaN(value)) {
      return null;
    }

    // Round to consistent decimal places
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(value * multiplier) / multiplier;
  }

  /**
   * Normalize all values in extracted QEEG data
   * Ensures consistent precision across all measurements
   * @param {Object} extractedData - The raw extracted data
   * @returns {Object} Normalized data
   */
  static normalizeExtractedData(extractedData) {
    const normalized = JSON.parse(JSON.stringify(extractedData)); // Deep clone

    // Normalize absolute power values
    if (normalized.absolute) {
      Object.keys(normalized.absolute).forEach(channel => {
        Object.keys(normalized.absolute[channel]).forEach(band => {
          normalized.absolute[channel][band] =
            this.normalizeValue(normalized.absolute[channel][band], 2);
        });
      });
    }

    // Normalize relative power values
    if (normalized.relative) {
      Object.keys(normalized.relative).forEach(channel => {
        Object.keys(normalized.relative[channel]).forEach(band => {
          normalized.relative[channel][band] =
            this.normalizeValue(normalized.relative[channel][band], 2);
        });
      });
    }

    // Normalize special values (alpha peak, etc.)
    if (normalized.special) {
      Object.keys(normalized.special).forEach(key => {
        normalized.special[key] = this.normalizeValue(normalized.special[key], 2);
      });
    }

    // Normalize zscores if present (for z-score reports)
    if (normalized.zscores) {
      if (normalized.zscores.absolute) {
        Object.keys(normalized.zscores.absolute).forEach(channel => {
          Object.keys(normalized.zscores.absolute[channel]).forEach(band => {
            normalized.zscores.absolute[channel][band] =
              this.normalizeValue(normalized.zscores.absolute[channel][band], 2);
          });
        });
      }
      if (normalized.zscores.relative) {
        Object.keys(normalized.zscores.relative).forEach(channel => {
          Object.keys(normalized.zscores.relative[channel]).forEach(band => {
            normalized.zscores.relative[channel][band] =
              this.normalizeValue(normalized.zscores.relative[channel][band], 2);
          });
        });
      }
    }

    return normalized;
  }

  /**
   * Parse PDF file using Gemini AI with caching for deterministic results
   * @param {Object} file - Multer file object
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   */
  static async parsePDF(file, condition, reportType = 'raw') {
    // üîÄ AI SERVICE SELECTION: Use OpenAI or Gemini based on configuration
    if (AI_SERVICE === 'openai') {
      console.log(`  üîÄ Using OpenAI GPT-4 for PDF parsing (configured via AI_SERVICE)`);
      return await OpenAIParser.parsePDF(file, condition, reportType);
    }

    console.log(`  üîç Parsing PDF with Gemini AI (${condition}, ${reportType.toUpperCase()} mode)...`);

    try {
      // Validate API key before attempting to use it
      this.validateAPIKey();

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);

      // Calculate PDF hash for caching (ensures same PDF = same result)
      const pdfHash = this.calculatePDFHash(dataBuffer);
      const cacheKey = `${pdfHash}_${condition}_${reportType}`;

      console.log(`  üîë PDF Hash: ${pdfHash.substring(0, 12)}... (for deterministic caching)`);

      // Check cache first
      if (extractionCache.has(cacheKey)) {
        cacheStats.hits++;
        cacheStats.totalExtractions++;
        console.log(`  ‚úÖ CACHE HIT! Using cached extraction result (100% deterministic)`);
        console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses, ${((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1)}% hit rate`);
        return extractionCache.get(cacheKey);
      }

      cacheStats.misses++;
      cacheStats.totalExtractions++;
      console.log(`  ‚ö†Ô∏è  Cache miss - extracting data with Gemini AI...`);
      console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses`);

      const pdfData = await pdfParse(dataBuffer);

      // Extract text from PDF
      const pdfText = pdfData.text;

      // Get appropriate extraction prompt based on report type
      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);

      // Initialize Gemini model if not already done
      if (!geminiModel) {
        console.log('  üîß Initializing Gemini model for data extraction...');
        console.log('  üîë API Key status:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');
        console.log('  üîë API Key length:', process.env.GEMINI_API_KEY?.length || 0);
        console.log('  üîë API Key preview:', process.env.GEMINI_API_KEY ? `${process.env.GEMINI_API_KEY.substring(0, 20)}...` : 'N/A');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          console.error('\n  ‚ùå === NO MODELS AVAILABLE ===');
          console.error('  Please check:');
          console.error('  1. GEMINI_API_KEY is correct in .env file');
          console.error('  2. API key has proper permissions');
          console.error('  3. Visit: https://aistudio.google.com/apikey to get a new key');
          console.error('  4. Make sure Generative Language API is enabled');
          console.error('  ================================\n');
          throw new Error('No Gemini models available. Check your API key.');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model from available models');
        }

        // Initialize model with full path and deterministic config
        console.log(`  üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({
          model: modelName,
          generationConfig: {
            temperature: 0,      // Minimum randomness for deterministic extraction
            topK: 1,            // Only pick most likely token
            topP: 1             // No nucleus sampling
          }
        });

        // Test the model with a simple call
        console.log(`  üìû Testing ${modelName} with simple call...`);
        try {
          const testResult = await geminiModel.generateContent('Hello');
          const testResponse = await testResult.response;
          const testText = testResponse.text();

          console.log(`  ‚úÖ Model initialized and tested successfully`);
          console.log(`  üìù Test response: ${testText.substring(0, 50)}...`);
        } catch (testError) {
          console.error(`  ‚ùå Model test failed:`, testError.message);
          throw new Error(`Failed to test model ${modelName}: ${testError.message}`);
        }
      }

      console.log(`  ü§ñ Using Gemini AI for data extraction (${condition})...`);

      // üõ°Ô∏è RATE LIMITING: Wait before making API call to respect quotas
      await rateLimiter.waitForRateLimit();

      // Call Gemini API with retry logic for quota/rate limit errors
      let result;
      let retryCount = 0;
      const maxRetries = 3;

      while (retryCount <= maxRetries) {
        try {
          result = await geminiModel.generateContent(prompt);

          // ‚úÖ Record successful API call for quota tracking
          rateLimiter.recordRequest();

          break; // Success, exit retry loop
        } catch (apiError) {
          // Check if it's a quota/rate limit error
          if (apiError.message && (apiError.message.includes('quota') || apiError.message.includes('429'))) {
            const retryDelay = Math.pow(2, retryCount) * 5000; // Exponential backoff: 5s, 10s, 20s

            console.warn(`  ‚ö†Ô∏è  Gemini API quota/rate limit hit (attempt ${retryCount + 1}/${maxRetries + 1})`);

            if (retryCount < maxRetries) {
              console.log(`  ‚è≥ Waiting ${retryDelay / 1000} seconds before retry...`);
              await new Promise(resolve => setTimeout(resolve, retryDelay));
              retryCount++;
              continue;
            } else {
              // Max retries reached, throw enhanced error
              const enhancedError = new Error(
                'Gemini API quota exceeded. Your free tier allows 20 requests per day. ' +
                'Please wait a few hours for quota to reset, or upgrade to a paid plan at https://ai.google.dev/pricing'
              );
              enhancedError.code = 'GEMINI_QUOTA_EXCEEDED';
              enhancedError.originalError = apiError;
              throw enhancedError;
            }
          } else {
            // Not a quota error, throw immediately
            throw apiError;
          }
        }
      }

      const response = await result.response;
      const text = response.text();

      console.log(`  üìù Gemini response received (${condition}), length: ${text.length} characters`);

      // Parse JSON from response (remove markdown code blocks if present)
      let extractedData;
      try {
        const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const rawData = JSON.parse(jsonText);

        // üîß NORMALIZE all values to consistent decimal places
        // This ensures minor extraction variations don't affect calculations
        extractedData = this.normalizeExtractedData(rawData);

        console.log(`  ‚úÖ PDF data extracted and normalized successfully (${condition})`);

        // === ENHANCED DEBUG: Show COMPLETE extracted data ===
        console.log(`\n  üêõ === DEBUG: COMPLETE EXTRACTED DATA (${condition}) ===`);
        console.log(`  üìä ABSOLUTE POWER (ŒºV¬≤):`);
        if (extractedData.absolute) {
          Object.keys(extractedData.absolute).forEach(channel => {
            const bands = extractedData.absolute[channel];
            console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
          });
        }

        console.log(`\n  üìä RELATIVE POWER (%):`);
        if (extractedData.relative) {
          Object.keys(extractedData.relative).forEach(channel => {
            const bands = extractedData.relative[channel];
            const sum = (bands.Delta || 0) + (bands.Theta || 0) + (bands.Alpha || 0) + (bands.Beta || 0) + (bands.HiBeta || 0);
            console.log(`     ${channel}: Delta=${bands.Delta}%, Theta=${bands.Theta}%, Alpha=${bands.Alpha}%, Beta=${bands.Beta}%, HiBeta=${bands.HiBeta}% [Sum=${sum.toFixed(1)}%]`);
          });
        }

        console.log(`\n  üìä SPECIAL VALUES:`);
        if (extractedData.special) {
          console.log(`     Alpha Peak: ${extractedData.special.alphaPeak} Hz`);
          if (extractedData.special.O1) console.log(`     O1: ${extractedData.special.O1} Hz`);
        }

        // If Z-score data exists
        if (extractedData.zscores) {
          console.log(`\n  üìä Z-SCORE DATA (ABSOLUTE):`);
          if (extractedData.zscores.absolute) {
            Object.keys(extractedData.zscores.absolute).forEach(channel => {
              const bands = extractedData.zscores.absolute[channel];
              console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
            });
          }

          console.log(`\n  üìä Z-SCORE DATA (RELATIVE):`);
          if (extractedData.zscores.relative) {
            Object.keys(extractedData.zscores.relative).forEach(channel => {
              const bands = extractedData.zscores.relative[channel];
              console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
            });
          }
        }
        console.log(`  === END DEBUG: EXTRACTED DATA ===\n`);

      } catch (parseError) {
        console.error(`  ‚ùå Failed to parse JSON from Gemini response (${condition}):`, parseError.message);
        console.error(`  üìÑ Raw response:`, text.substring(0, 500));
        throw new Error(`Failed to parse JSON from Gemini response: ${parseError.message}`);
      }

      // Add detailed logging
      console.log(`  üìä Data extraction summary (${condition}):`);
      console.log(`     - Absolute power channels: ${Object.keys(extractedData.absolute || {}).length}`);
      console.log(`     - Relative power channels: ${Object.keys(extractedData.relative || {}).length}`);
      console.log(`     - Special values: ${JSON.stringify(extractedData.special || {})}`);

      // Log sample extracted values for verification (prove it's real patient data, not static)
      console.log(`\n  üìã Sample Extracted Values (${condition}) - Proof of Dynamic Extraction:`);
      if (extractedData.absolute?.Fz) {
        console.log(`     - Fz Absolute: Theta=${extractedData.absolute.Fz.Theta}, Beta=${extractedData.absolute.Fz.Beta}`);
      }
      if (extractedData.absolute?.Pz) {
        console.log(`     - Pz Absolute: Alpha=${extractedData.absolute.Pz.Alpha}, HiBeta=${extractedData.absolute.Pz.HiBeta}`);
      }
      if (extractedData.relative?.Pz) {
        console.log(`     - Pz Relative: Alpha=${extractedData.relative.Pz.Alpha}, Beta=${extractedData.relative.Pz.Beta}`);
      }
      if (extractedData.absolute?.F3 && extractedData.absolute?.F4) {
        console.log(`     - F3/F4 Absolute Alpha: F3=${extractedData.absolute.F3.Alpha}, F4=${extractedData.absolute.F4.Alpha}`);
      }
      if (extractedData.special?.alphaPeak) {
        console.log(`     - Alpha Peak Frequency: ${extractedData.special.alphaPeak} Hz`);
      }

      // Validate extracted data has minimum required fields
      const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
      const absoluteChannels = Object.keys(extractedData.absolute || {});
      const relativeChannels = Object.keys(extractedData.relative || {});

      const missingAbsolute = requiredChannels.filter(ch => !absoluteChannels.includes(ch));
      const missingRelative = requiredChannels.filter(ch => !relativeChannels.includes(ch));

      if (missingAbsolute.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing absolute power channels: ${missingAbsolute.join(', ')}`);
      }
      if (missingRelative.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing relative power channels: ${missingRelative.join(', ')}`);
      }

      // üîç VALIDATE: Check if relative power sums to ~100% for each channel
      console.log(`\n  üîç Validating relative power values (${condition})...`);
      let incompleteChannels = [];

      for (const channel of requiredChannels) {
        if (extractedData.relative?.[channel]) {
          const bands = extractedData.relative[channel];
          const sum = (bands.Delta || 0) + (bands.Theta || 0) + (bands.Alpha || 0) +
                     (bands.Beta || 0) + (bands.HiBeta || 0);

          // Check if sum is close to 100% (allow ¬±5% tolerance)
          if (sum < 95 || sum > 105) {
            incompleteChannels.push({
              channel,
              sum: sum.toFixed(1),
              bands: {
                Delta: bands.Delta || 0,
                Theta: bands.Theta || 0,
                Alpha: bands.Alpha || 0,
                Beta: bands.Beta || 0,
                HiBeta: bands.HiBeta || 0
              }
            });
          }
        }
      }

      if (incompleteChannels.length > 0) {
        console.error(`\n  ‚ùå ==================== DATA EXTRACTION INCOMPLETE ====================`);
        console.error(`  ‚ùå CRITICAL: ${incompleteChannels.length} channels have incorrect relative power sums!`);
        console.error(`  ‚ùå Relative power MUST sum to ~100% for each channel.`);
        console.error(`  ‚ùå Incomplete extraction will cause INCORRECT ALGORITHM RESULTS!\n`);

        incompleteChannels.forEach(({ channel, sum, bands }) => {
          console.error(`     Channel ${channel}: Sum = ${sum}% (Expected: ~100%)`);
          console.error(`       Delta: ${bands.Delta}% | Theta: ${bands.Theta}% | Alpha: ${bands.Alpha}%`);
          console.error(`       Beta: ${bands.Beta}% | HiBeta: ${bands.HiBeta}%`);

          // Identify which bands are likely missing (have 0 or very low values)
          const missingBands = [];
          Object.entries(bands).forEach(([band, value]) => {
            if (value === 0 || value < 0.1) {
              missingBands.push(band);
            }
          });

          if (missingBands.length > 0) {
            console.error(`       ‚ö†Ô∏è  Likely missing bands: ${missingBands.join(', ')}`);
          }
          console.error('');
        });

        console.error(`  ‚ùå RECOMMENDATION: Check if the PDF contains all frequency band values.`);
        console.error(`  ‚ùå Gemini may need to look in different table sections or pages.`);
        console.error(`  ‚ùå ====================================================================\n`);
      } else {
        console.log(`  ‚úÖ Relative power validation passed: All channels sum to ~100%`);
      }

      // ‚úÖ CACHE the extraction result for deterministic behavior
      // Same PDF will now ALWAYS return the same values
      extractionCache.set(cacheKey, extractedData);
      console.log(`  üíæ Extraction result cached (key: ${pdfHash.substring(0, 12)}...)`);
      console.log(`  üìä Cache size: ${extractionCache.size} entries`);

      return extractedData;

    } catch (error) {
      console.error(`  ‚ùå Gemini API error (${condition}):`, error.message);

      // Log more details for debugging
      if (error.response) {
        console.error(`  ‚ùå Gemini API Status:`, error.response?.status);
        console.error(`  ‚ùå Gemini API Error:`, error.response?.data);
      }

      console.error(`  üìÑ Error stack:`, error.stack);

      // Re-throw with more context
      const enhancedError = new Error(`Failed to extract QEEG data from PDF using Gemini (${condition}): ${error.message}`);
      enhancedError.code = 'PDF_EXTRACTION_FAILED';
      enhancedError.originalError = error;
      enhancedError.condition = condition;
      throw enhancedError;
    }
  }

  /**
   * Parse CSV file
   */
  static parseCSV(file) {
    console.log('  üìä Parsing CSV file...');

    // Read CSV file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert CSV data to our format
    const data = this.convertCSVToFormat(jsonData);

    console.log('  ‚úÖ CSV parsed successfully');
    return data;
  }

  /**
   * Parse Excel file
   */
  static parseExcel(file) {
    console.log('  üìä Parsing Excel file...');

    // Read Excel file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert Excel data to our format
    const data = this.convertExcelToFormat(jsonData);

    console.log('  ‚úÖ Excel parsed successfully');
    return data;
  }

  /**
   * Convert CSV data to expected format
   */
  static convertCSVToFormat(csvData) {
    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta
    const result = {
      absolute: {},
      relative: {},
      special: { alphaPeak: 10.0, O1: 10.0 }
    };

    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];

    for (const row of csvData) {
      const channel = row.Channel;
      const powerType = row.PowerType?.toLowerCase();

      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {
        result[powerType][channel] = {
          Delta: parseFloat(row.Delta) || 0,
          Theta: parseFloat(row.Theta) || 0,
          Alpha: parseFloat(row.Alpha) || 0,
          Beta: parseFloat(row.Beta) || 0,
          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0
        };
      }
    }

    return result;
  }

  /**
   * Convert Excel data to expected format (same as CSV for now)
   */
  static convertExcelToFormat(excelData) {
    return this.convertCSVToFormat(excelData);
  }

  /**
   * Get cache statistics
   * @returns {Object} Cache statistics
   */
  static getCacheStats() {
    return {
      ...cacheStats,
      cacheSize: extractionCache.size,
      hitRate: cacheStats.totalExtractions > 0
        ? ((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1) + '%'
        : '0%'
    };
  }

  /**
   * Clear extraction cache (useful for testing or memory management)
   * @param {string} pdfHash - Optional: Clear specific PDF hash, or all if not provided
   */
  static clearCache(pdfHash = null) {
    if (pdfHash) {
      // Clear specific PDF
      let cleared = 0;
      for (const key of extractionCache.keys()) {
        if (key.startsWith(pdfHash)) {
          extractionCache.delete(key);
          cleared++;
        }
      }
      console.log(`üóëÔ∏è  Cleared ${cleared} cache entries for PDF hash: ${pdfHash.substring(0, 12)}...`);
    } else {
      // Clear all
      const size = extractionCache.size;
      extractionCache.clear();
      cacheStats.hits = 0;
      cacheStats.misses = 0;
      cacheStats.totalExtractions = 0;
      console.log(`üóëÔ∏è  Cleared entire extraction cache (${size} entries)`);
    }
  }

  /**
   * Get Gemini API quota status
   * @returns {Object} Current quota usage and limits
   */
  static getQuotaStatus() {
    return rateLimiter.getQuotaStatus();
  }
}

module.exports = QEEGParser;
