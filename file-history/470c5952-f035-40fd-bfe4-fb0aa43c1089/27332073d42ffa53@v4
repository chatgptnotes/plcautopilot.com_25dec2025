const fs = require('fs');
const crypto = require('crypto');
const pdfParse = require('pdf-parse');
const OpenAI = require('openai');

console.log('ðŸ”§ Loading OpenAI Parser...');
console.log(`   OpenAI API Key: ${process.env.OPENAI_API_KEY ? 'Present (length: ' + process.env.OPENAI_API_KEY.length + ')' : 'MISSING!'}`);

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

console.log('âœ… OpenAI Parser loaded successfully\n');

// In-memory cache (same as Gemini parser)
const extractionCache = new Map();

// Cache statistics
const cacheStats = {
  hits: 0,
  misses: 0,
  totalExtractions: 0
};

class OpenAIParser {
  /**
   * Validate OpenAI API key
   */
  static validateAPIKey() {
    const apiKey = process.env.OPENAI_API_KEY;

    if (!apiKey || apiKey.trim() === '') {
      const error = new Error('OPENAI_API_KEY environment variable is not set');
      error.code = 'MISSING_API_KEY';
      throw error;
    }

    console.log('âœ… OpenAI API key validation passed');
    return true;
  }

  /**
   * Get extraction prompt for OpenAI (same logic as Gemini)
   */
  static getExtractionPrompt(condition, reportType, pdfText) {
    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';

    if (reportType === 'zscore') {
      // Z-SCORE extraction prompt
      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.

**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.
- Negative values = below average (lower than normal)
- Zero (0) = average (normal)
- Positive values = above average (higher than normal)

Look for tables labeled with "Z-score", "Z score", "Z", or "Standard Deviation" in the headers.

Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract Z-scores for these frequency bands:
- Delta (1-4 Hz)
- Theta (4-8 Hz)
- Alpha (8-13 Hz)
- Beta (13-30 Hz)
- HiBeta / High Beta (20-30 Hz)

Also extract:
- Alpha Peak Frequency (Hz) and its Z-score if available

If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return ONLY this EXACT JSON format:
{
  "zscores": {
    "absolute": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    },
    "relative": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

PDF Content (ONLY PAGES 13 & 24):
${pdfText}`;

    } else {
      // RAW POWER extraction prompt
      return `You are an expert QEEG data extraction specialist. Your task is to extract COMPLETE frequency band data from this ${conditionName} QEEG report PDF.

ðŸŽ¯ YOUR MISSION: Extract 100% COMPLETE DATA - No Missing Bands Allowed!

ðŸ“Š WHAT TO EXTRACT:
You must extract THREE pieces of data from this PDF:
1. **Z-scored Alpha Peak** (Hz) - From page 13
2. **Absolute Power (Î¼VÂ²)** - Brain wave power in microvolts squared - From page 24
3. **Relative Power (%)** - Percentage distribution (MUST sum to ~100% per channel) - From page 24

ðŸ“ WHERE TO LOOK IN THE PDF:
- âš ï¸ IMPORTANT: This content contains ONLY pages 13 and 24 from the full PDF report!

  **PAGE 13** - Z-scored Alpha Peak:
  - Look for "Z-scored Alpha Peak" / "Alpha Peak Frequency" / "Peak Alpha"
  - This is typically a table showing alpha peak frequency (Hz) with z-scores
  - Extract the alpha peak frequency value (usually 8-13 Hz range)

  **PAGE 24** - Power Tables (BOTH on same page):
  - Look for TWO tables on page 24:
    * "Absolute Power" / "Absolute Spectral Power" / "Absolute" / "ABS" (Î¼VÂ²)
    * "Relative Power" / "Relative Spectral Power" / "Relative" / "REL" (%)
  - Both Absolute AND Relative tables are on page 24
  - Look for headers like "Monopolar" / "Linked Ears" / "Average Reference"

- The text below contains ONLY these two pages - no other pages are included!

ðŸ§  CHANNELS TO EXTRACT (19 channels):
FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

ðŸ“Š FREQUENCY BANDS (ALL 5 REQUIRED):
For EACH channel, you MUST extract ALL 5 bands:
1. **Delta** (Î´) - 0.5-4 Hz
2. **Theta** (Î¸) - 4-8 Hz
3. **Alpha** (Î±) - 8-13 Hz
4. **Beta** (Î²) - 13-30 Hz
5. **HiBeta** (High Beta / Î²Î²) - 30-50 Hz

âš ï¸ CRITICAL REQUIREMENTS:
1. Extract ALL 5 bands for EVERY channel
2. For Relative Power, EACH channel must sum to ~100%
3. Preserve exact decimal values from the PDF
4. Do not skip any channels or bands
5. Extract Alpha Peak frequency from page 13 (look for z-scored value)
6. Extract BOTH Absolute and Relative power tables from page 24

**OUTPUT FORMAT**:
Return ONLY pure JSON (no markdown, no code blocks, no explanations):

{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

NOTES:
- alphaPeak: Extract from page 13 (Z-scored Alpha Peak table)
- alphaPeakZscore: If z-score value is available, extract it; otherwise use 0.0
- Absolute & Relative power: Extract from page 24
- This text contains ONLY pages 13 and 24 - all other pages have been excluded

PDF Content (ONLY PAGES 13 & 24):
${pdfText}`;
    }
  }

  /**
   * Calculate MD5 hash for caching
   */
  static calculatePDFHash(dataBuffer) {
    return crypto.createHash('md5').update(dataBuffer).digest('hex');
  }

  /**
   * Normalize extracted values
   */
  static normalizeValue(value, decimalPlaces = 2) {
    if (value === null || value === undefined || isNaN(value)) {
      return null;
    }
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(value * multiplier) / multiplier;
  }

  /**
   * Normalize all values in extracted data
   */
  static normalizeExtractedData(extractedData) {
    const normalized = JSON.parse(JSON.stringify(extractedData));

    if (normalized.absolute) {
      Object.keys(normalized.absolute).forEach(channel => {
        Object.keys(normalized.absolute[channel]).forEach(band => {
          normalized.absolute[channel][band] =
            this.normalizeValue(normalized.absolute[channel][band], 2);
        });
      });
    }

    if (normalized.relative) {
      Object.keys(normalized.relative).forEach(channel => {
        Object.keys(normalized.relative[channel]).forEach(band => {
          normalized.relative[channel][band] =
            this.normalizeValue(normalized.relative[channel][band], 2);
        });
      });
    }

    if (normalized.special) {
      Object.keys(normalized.special).forEach(key => {
        normalized.special[key] = this.normalizeValue(normalized.special[key], 2);
      });
    }

    if (normalized.zscores) {
      if (normalized.zscores.absolute) {
        Object.keys(normalized.zscores.absolute).forEach(channel => {
          Object.keys(normalized.zscores.absolute[channel]).forEach(band => {
            normalized.zscores.absolute[channel][band] =
              this.normalizeValue(normalized.zscores.absolute[channel][band], 2);
          });
        });
      }
      if (normalized.zscores.relative) {
        Object.keys(normalized.zscores.relative).forEach(channel => {
          Object.keys(normalized.zscores.relative[channel]).forEach(band => {
            normalized.zscores.relative[channel][band] =
              this.normalizeValue(normalized.zscores.relative[channel][band], 2);
          });
        });
      }
    }

    return normalized;
  }

  /**
   * Extract text from specific pages of a PDF
   * @param {Buffer} dataBuffer - PDF file buffer
   * @param {Array<number>} pageNumbers - Array of page numbers to extract (1-indexed)
   * @returns {Promise<string>} - Combined text from specified pages
   */
  static async extractSpecificPages(dataBuffer, pageNumbers) {
    try {
      console.log(`  ðŸ“„ Extracting specific pages: ${pageNumbers.join(', ')}`);

      // First, get total page count
      const pdfData = await pdfParse(dataBuffer);
      const totalPages = pdfData.numpages;

      console.log(`  ðŸ“š PDF has ${totalPages} total pages`);

      // Validate page numbers
      const validPages = pageNumbers.filter(num => num > 0 && num <= totalPages);
      if (validPages.length === 0) {
        console.warn(`  âš ï¸  None of the requested pages exist in PDF`);
        return pdfData.text; // Fallback to full text
      }

      console.log(`  âœ… Valid pages to extract: ${validPages.join(', ')}`);

      // Extract text from specific pages
      // Since pdf-parse doesn't support page-specific extraction directly,
      // we'll use a heuristic: split by page break patterns and select pages
      const fullText = pdfData.text;
      const pageTexts = [];

      // Common page break indicators
      const pageBreakPattern = /\f|\n\s*\d+\s*\n|\n\s*Page\s+\d+/gi;
      const pages = fullText.split(pageBreakPattern);

      console.log(`  ðŸ“Š Text split into ${pages.length} segments`);

      // Extract requested pages (adjust for 0-indexed array)
      for (const pageNum of validPages) {
        const pageIndex = pageNum - 1;
        if (pageIndex < pages.length) {
          pageTexts.push(`\n=== PAGE ${pageNum} ===\n${pages[pageIndex]}\n`);
          console.log(`  âœ“ Extracted page ${pageNum} (${pages[pageIndex].length} chars)`);
        } else {
          console.warn(`  âš ï¸  Page ${pageNum} not found in split segments`);
        }
      }

      const combinedText = pageTexts.join('\n');
      console.log(`  âœ… Total extracted text: ${combinedText.length} characters from ${pageTexts.length} pages`);

      return combinedText.length > 100 ? combinedText : fullText;

    } catch (error) {
      console.error(`  âŒ Error extracting specific pages:`, error.message);
      // Fallback: return full PDF text
      const fallbackData = await pdfParse(dataBuffer);
      return fallbackData.text;
    }
  }

  /**
   * Parse PDF using OpenAI GPT-4
   */
  static async parsePDF(file, condition, reportType = 'raw') {
    console.log(`  ðŸ” Parsing PDF with OpenAI GPT-4 (${condition}, ${reportType.toUpperCase()} mode)...`);

    try {
      // Validate API key
      this.validateAPIKey();

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);

      // Calculate hash for caching
      const pdfHash = this.calculatePDFHash(dataBuffer);
      const cacheKey = `openai_${pdfHash}_${condition}_${reportType}`;

      console.log(`  ðŸ”‘ PDF Hash: ${pdfHash.substring(0, 12)}... (for caching)`);

      // Check cache first
      if (extractionCache.has(cacheKey)) {
        cacheStats.hits++;
        cacheStats.totalExtractions++;
        console.log(`  âœ… CACHE HIT! Using cached extraction result`);
        console.log(`  ðŸ“Š Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses`);
        return extractionCache.get(cacheKey);
      }

      cacheStats.misses++;
      cacheStats.totalExtractions++;
      console.log(`  âš ï¸  Cache miss - extracting with OpenAI...`);

      // Extract ONLY pages 13 and 24 (where data tables are located)
      console.log(`  ðŸŽ¯ Targeting specific pages: 13 (Alpha Peak) and 24 (Power Tables)`);
      const pdfText = await this.extractSpecificPages(dataBuffer, [13, 24]);

      // Get extraction prompt
      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);

      console.log(`  ðŸ¤– Calling OpenAI GPT-4...`);

      // Call OpenAI API
      const completion = await openai.chat.completions.create({
        model: "gpt-4o", // Using GPT-4 Turbo for best accuracy
        messages: [
          {
            role: "system",
            content: "You are a medical data extraction expert specializing in QEEG reports. Extract data accurately and return only valid JSON."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0, // Deterministic output
        response_format: { type: "json_object" } // Force JSON response
      });

      const responseText = completion.choices[0].message.content;
      console.log(`  ðŸ“ OpenAI response received, length: ${responseText.length} characters`);

      // Parse JSON response
      let extractedData;
      try {
        const jsonText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const rawData = JSON.parse(jsonText);

        // Normalize values
        extractedData = this.normalizeExtractedData(rawData);

        console.log(`  âœ… PDF data extracted and normalized successfully (${condition})`);

        // Debug output
        console.log(`\n  ðŸ› === OpenAI EXTRACTED DATA (${condition}) ===`);
        if (extractedData.absolute) {
          console.log(`  ðŸ“Š ABSOLUTE POWER: ${Object.keys(extractedData.absolute).length} channels`);
        }
        if (extractedData.relative) {
          console.log(`  ðŸ“Š RELATIVE POWER: ${Object.keys(extractedData.relative).length} channels`);
        }
        console.log(`  === END DEBUG ===\n`);

      } catch (parseError) {
        console.error(`  âŒ Failed to parse JSON from OpenAI response:`, parseError.message);
        console.error(`  ðŸ“„ Raw response:`, responseText.substring(0, 500));
        throw new Error(`Failed to parse JSON from OpenAI: ${parseError.message}`);
      }

      // Cache the result
      extractionCache.set(cacheKey, extractedData);
      console.log(`  ðŸ’¾ Result cached (key: ${pdfHash.substring(0, 12)}...)`);

      return extractedData;

    } catch (error) {
      console.error(`  âŒ OpenAI API error (${condition}):`, error.message);

      // Enhanced error for quota issues
      if (error.message && error.message.includes('quota')) {
        const enhancedError = new Error(
          'OpenAI API quota exceeded. Please check your API key and billing at https://platform.openai.com/account/billing'
        );
        enhancedError.code = 'OPENAI_QUOTA_EXCEEDED';
        enhancedError.originalError = error;
        throw enhancedError;
      }

      throw error;
    }
  }

  /**
   * Get cache statistics
   */
  static getCacheStats() {
    return {
      ...cacheStats,
      cacheSize: extractionCache.size,
      hitRate: cacheStats.totalExtractions > 0
        ? ((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1) + '%'
        : '0%'
    };
  }
}

module.exports = OpenAIParser;
