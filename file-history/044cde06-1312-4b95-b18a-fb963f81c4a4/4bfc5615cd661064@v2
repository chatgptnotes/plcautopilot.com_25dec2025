const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const QEEGParser = require('../services/qeegParser');
const AlgorithmCalculator = require('../services/algorithmCalculator');
// OLD generators (keeping for fallback)
const PDFReportGenerator = require('../services/pdfGenerator');
const TemplateBasedPDFGenerator = require('../services/pdfGeneratorTemplate');
const templateManager = require('../services/pdf/templateManager');
const AIPdfGenerator = require('../services/aiPdfGenerator');
const SupabaseStorage = require('../services/supabaseStorage');

// NEW: Gemini AI Service for report generation
let GeminiService = null;
try {
  GeminiService = require('../services/geminiService');
  console.log('‚úÖ Gemini AI Service loaded successfully');
} catch (error) {
  console.error('‚ùå CRITICAL: Gemini AI Service failed to load!');
  console.error('   Error:', error.message);
  console.error('   Stack:', error.stack);
}

// NEW: Gemini PDF Generator - Uses Gemini AI for content generation
let GeminiPdfGenerator = null;
try {
  GeminiPdfGenerator = require('../services/geminiPdfGenerator');
  console.log('‚úÖ Gemini PDF Generator loaded successfully');
  console.log('   Generator available:', !!GeminiPdfGenerator);
} catch (error) {
  console.error('‚ùå CRITICAL: Gemini PDF Generator failed to load!');
  console.error('   Error:', error.message);
  console.error('   Stack:', error.stack);
}

// OLD: Enhanced AI PDF Generator with OpenAI (keeping as fallback)
let EnhancedAIPdfGenerator = null;
try {
  EnhancedAIPdfGenerator = require('../services/aiPdfGeneratorEnhanced');
  console.log('‚úÖ Enhanced AI PDF Generator loaded successfully');
} catch (error) {
  console.warn('‚ö†Ô∏è  Enhanced AI PDF Generator failed to load:', error.message);
  console.warn('   Will use fallback PDF generator');
}

const router = express.Router();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(__dirname, '../uploads');
    // Ensure upload directory exists
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB limit - increased to handle larger QEEG files
  },
  fileFilter: function (req, file, cb) {
    const allowedExtensions = ['.pdf', '.csv', '.xlsx', '.xls'];
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedExtensions.includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error(`Only ${allowedExtensions.join(', ')} files are allowed`));
    }
  }
});

/**
 * POST /api/qeeg/process
 * Process QEEG files and calculate 7 brain health parameters
 */
router.post('/process', upload.fields([
  { name: 'eyesOpen', maxCount: 1 },
  { name: 'eyesClosed', maxCount: 1 }
]), async (req, res) => {
  let eyesOpenFile = null;
  let eyesClosedFile = null;

  try {
    console.log('\nüî¨ === QEEG Processing Started ===\n');

    // Get uploaded files
    const files = req.files;
    if (!files || !files.eyesOpen || !files.eyesClosed) {
      return res.status(400).json({
        error: true,
        message: 'Both Eyes Open and Eyes Closed files are required'
      });
    }

    eyesOpenFile = files.eyesOpen[0];
    eyesClosedFile = files.eyesClosed[0];

    console.log('üìÅ Files received:');
    console.log('  - Eyes Open:', eyesOpenFile.originalname, `(${(eyesOpenFile.size / 1024).toFixed(2)} KB)`);
    console.log('  - Eyes Closed:', eyesClosedFile.originalname, `(${(eyesClosedFile.size / 1024).toFixed(2)} KB)`);

    // Get patient info from request body
    const {
      patientId,
      patientName,
      clinicName,
      dateOfBirth,
      age,
      gender,
      handedness
    } = req.body;

    console.log('\nüë§ Patient Information:');
    console.log('  - Patient ID:', patientId);
    console.log('  - Patient Name:', patientName);
    console.log('  - Clinic:', clinicName);
    console.log('  - Date of Birth:', dateOfBirth);
    console.log('  - Age:', age);
    console.log('  - Gender:', gender);
    console.log('  - Handedness:', handedness);

    // Validate OpenAI API configuration before processing (OPTIONAL - don't fail if missing)
    console.log('\nüîê Checking OpenAI API configuration...');
    try {
      await QEEGParser.testAPIConnection();
      console.log('‚úÖ OpenAI API configured properly');
    } catch (apiError) {
      console.warn('‚ö†Ô∏è  OpenAI API not configured or failed test:', apiError.message);
      console.warn('   Continuing with processing anyway...');
      // Don't throw error - allow processing to continue without OpenAI
    }

    // Step 1: Parse QEEG files
    console.log('\nüìä Step 1: Parsing QEEG files...');

    // Show cache stats before parsing
    const cacheStatsBefore = QEEGParser.getCacheStats();
    console.log('üìä Cache Statistics (Before):');
    console.log(`   - Cache hits: ${cacheStatsBefore.hits}`);
    console.log(`   - Cache misses: ${cacheStatsBefore.misses}`);
    console.log(`   - Hit rate: ${cacheStatsBefore.hitRate}`);
    console.log(`   - Cache size: ${cacheStatsBefore.cacheSize} entries`);

    const qeegData = await QEEGParser.parse(eyesOpenFile, eyesClosedFile);

    // Show cache stats after parsing
    const cacheStatsAfter = QEEGParser.getCacheStats();
    console.log('\nüìä Cache Statistics (After):');
    console.log(`   - Cache hits: ${cacheStatsAfter.hits}`);
    console.log(`   - Cache misses: ${cacheStatsAfter.misses}`);
    console.log(`   - Hit rate: ${cacheStatsAfter.hitRate}`);
    console.log(`   - Cache size: ${cacheStatsAfter.cacheSize} entries`);

    if (cacheStatsAfter.hits > cacheStatsBefore.hits) {
      console.log('   ‚úÖ CACHE HIT! Data retrieved from cache (no API quota used)');
    } else {
      console.log('   ‚ö†Ô∏è  CACHE MISS - Gemini API was called (quota consumed)');
    }

    // Validate that we got real patient data
    console.log('\nüìä QEEG Data Validation:');
    console.log('  - Eyes Open (EO) channels:', Object.keys(qeegData.EO?.absolute || {}).length);
    console.log('  - Eyes Closed (EC) channels:', Object.keys(qeegData.EC?.absolute || {}).length);
    console.log('  - Using REAL PATIENT DATA (not sample data)');
    console.log('  - Patient:', patientName, `(ID: ${patientId})`);

    // Verify non-zero values (proof of real data extraction)
    const eoFzTheta = qeegData.EO?.absolute?.Fz?.Theta || 0;
    const ecPzAlpha = qeegData.EC?.absolute?.Pz?.Alpha || 0;
    console.log('  - Sample Values (proof of extraction):');
    console.log(`    * EO Fz Theta: ${eoFzTheta}`);
    console.log(`    * EC Pz Alpha: ${ecPzAlpha}`);

    // Warn if all values are zero (indicates parsing failure)
    if (eoFzTheta === 0 && ecPzAlpha === 0) {
      console.warn('  ‚ö†Ô∏è  WARNING: Sample values are zero - possible parsing issue!');
    }

    // COMPREHENSIVE VALIDATION CHECKS
    console.log('\nüîç Comprehensive Data Validation:');

    // Check 1: Verify key channels have data
    const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4'];
    let missingChannels = 0;
    requiredChannels.forEach(ch => {
      const hasEO = qeegData.EO?.absolute?.[ch]?.Theta !== undefined;
      const hasEC = qeegData.EC?.absolute?.[ch]?.Alpha !== undefined;
      if (!hasEO || !hasEC) {
        console.warn(`  ‚ö†Ô∏è  Missing data for channel ${ch}`);
        missingChannels++;
      }
    });
    if (missingChannels === 0) {
      console.log('  ‚úÖ All required channels have data');
    }

    // Check 2: Verify values are in reasonable ranges (not all zeros or defaults)
    const testValues = [
      qeegData.EO?.absolute?.Fz?.Theta,
      qeegData.EO?.absolute?.Fz?.Beta,
      qeegData.EC?.absolute?.Pz?.Alpha,
      qeegData.EC?.relative?.Pz?.Alpha,
      qeegData.EC?.relative?.Pz?.Beta
    ];
    const uniqueValues = new Set(testValues.filter(v => v !== null && v !== undefined));
    if (uniqueValues.size <= 1) {
      console.warn('  ‚ö†Ô∏è  WARNING: All test values are the same - possible static data!');
    } else {
      console.log(`  ‚úÖ Data shows ${uniqueValues.size} unique values (not static)`);
    }

    // Check 3: Verify relative power sums to ~100% for a sample channel
    if (qeegData.EO?.relative?.Fz) {
      const fzBands = qeegData.EO.relative.Fz;
      const sum = (fzBands.Delta || 0) + (fzBands.Theta || 0) +
                  (fzBands.Alpha || 0) + (fzBands.Beta || 0) +
                  (fzBands.HiBeta || 0);
      console.log(`  üìä Relative power sum (EO Fz): ${sum.toFixed(1)}%`);
      if (sum < 80 || sum > 120) {
        console.warn(`  ‚ö†Ô∏è  WARNING: Relative power sum is ${sum.toFixed(1)}% (expected ~100%)`);
      } else {
        console.log('  ‚úÖ Relative power validation passed');
      }
    }

    // Check 4: Verify critical values for calculations exist
    const criticalValues = {
      'Relaxation (Pz EC Relative Alpha)': qeegData.EC?.relative?.Pz?.Alpha,
      'Relaxation (Pz EC Relative Beta)': qeegData.EC?.relative?.Pz?.Beta,
      'Focus (Fz EO Theta)': qeegData.EO?.absolute?.Fz?.Theta,
      'Focus (Fz EO Beta)': qeegData.EO?.absolute?.Fz?.Beta,
      'Alpha Peak': qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1
    };

    console.log('\n  üéØ Critical Values Check:');
    let missingCritical = 0;
    Object.entries(criticalValues).forEach(([name, value]) => {
      if (value === null || value === undefined) {
        console.warn(`  ‚ùå MISSING: ${name}`);
        missingCritical++;
      } else {
        console.log(`  ‚úÖ ${name}: ${value}`);
      }
    });

    if (missingCritical > 0) {
      console.warn(`\n  ‚ö†Ô∏è  WARNING: ${missingCritical} critical values missing - calculations may be inaccurate!`);
    } else {
      console.log('\n  ‚úÖ All critical values present - ready for calculation');
    }

    // Step 2: Calculate parameters with RAW power calculator
    console.log('\nüßÆ Step 2: Calculating 7 brain health parameters...');
    console.log('üìä Using Raw Power Calculator (as per specification)');

    const calculator = new AlgorithmCalculator(qeegData);
    const results = calculator.calculate();

    console.log('\n‚úÖ Calculation completed successfully!');
    console.log('üìà Results Summary:');
    results.parameters.forEach(param => {
      console.log(`  - ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);
    });
    console.log(`  - Overall Score: ${results.overallScore}/21`);

    // COMPREHENSIVE DEBUG SUMMARY
    console.log('\n' + '='.repeat(80));
    console.log('üìã COMPREHENSIVE DEBUG SUMMARY - FULL PIPELINE');
    console.log('='.repeat(80));

    console.log('\n1Ô∏è‚É£  DATA EXTRACTION PHASE:');
    console.log(`    Patient: ${patientName} (ID: ${patientId})`);
    console.log(`    Calculator: RAW Power (as per specification)`);
    console.log(`    EO Channels: ${Object.keys(qeegData.EO?.absolute || {}).length}`);
    console.log(`    EC Channels: ${Object.keys(qeegData.EC?.absolute || {}).length}`);

    console.log('\n2Ô∏è‚É£  SAMPLE EXTRACTED DATA:');
    console.log('    Key Values Used in Calculations:');
    console.log(`    - Fz EO Absolute Theta: ${qeegData.EO?.absolute?.Fz?.Theta || 'N/A'}`);
    console.log(`    - Fz EO Absolute Beta: ${qeegData.EO?.absolute?.Fz?.Beta || 'N/A'}`);
    console.log(`    - Pz EC Relative Alpha: ${qeegData.EC?.relative?.Pz?.Alpha || 'N/A'}`);
    console.log(`    - Pz EC Relative Beta: ${qeegData.EC?.relative?.Pz?.Beta || 'N/A'}`);
    console.log(`    - Alpha Peak: ${qeegData.EC?.special?.alphaPeak || qeegData.EC?.special?.O1 || 'N/A'} Hz`);

    console.log('\n3Ô∏è‚É£  CALCULATION RESULTS:');
    results.parameters.forEach((param, idx) => {
      console.log(`    ${idx + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);
      param.metrics.forEach(metric => {
        console.log(`       - ${metric.name}: ${metric.score} point`);
        if (metric.description) {
          console.log(`         ${metric.description}`);
        }
      });
    });

    // Removed hardcoded test comparison for specific patient
    // All patients now get their actual calculated scores without comparison

    console.log('\n' + '='.repeat(80));
    console.log('END OF DEBUG SUMMARY');
    console.log('='.repeat(80) + '\n');

    // Step 3: Auto-generate PDF report
    console.log('\nüìÑ Step 3: Auto-generating PDF report...');
    let pdfUrl = null;
    let pdfFilename = null;

    try {
      // Prepare patient data for PDF
      const pdfPatientData = {
        name: patientName,
        dateOfBirth: dateOfBirth || 'N/A',
        age: age || 'N/A',
        gender: gender || 'Not specified',
        handedness: handedness || 'Not specified',
        patientId: patientId,
        clinicName: clinicName
      };

      // Prepare algorithm results for PDF
      const pdfAlgorithmResults = {
        parameters: results.parameters,
        overallScore: results.overallScore
      };

      // Debug: Log parameters being sent to PDF
      console.log('\nüìä Parameters for PDF:');
      console.log('  - Total Parameters:', pdfAlgorithmResults.parameters.length);
      console.log('  - Overall Score:', pdfAlgorithmResults.overallScore);
      pdfAlgorithmResults.parameters.forEach((param, i) => {
        console.log(`  ${i + 1}. ${param.name}: ${param.score}/${param.maxScore} (${param.classification})`);
      });

      // Create output filename
      const timestamp = Date.now();
      const sanitizedName = (patientName || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();
      pdfFilename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;
      const uploadsDir = path.join(__dirname, '../uploads');
      const pdfOutputPath = path.join(uploadsDir, pdfFilename);

      // Ensure uploads directory exists
      if (!fs.existsSync(uploadsDir)) {
        console.log('üìÅ Creating uploads directory...');
        fs.mkdirSync(uploadsDir, { recursive: true });
      }

      console.log('üìù Generating PDF to:', pdfFilename);
      console.log('   Full path:', pdfOutputPath);

      // === USE GEMINI PDF GENERATOR (with fallback) ===
      console.log('\nüîç Checking available PDF generators...');
      console.log('   GeminiPdfGenerator available:', !!GeminiPdfGenerator);
      console.log('   EnhancedAIPdfGenerator available:', !!EnhancedAIPdfGenerator);
      console.log('   PDFReportGenerator available:', !!PDFReportGenerator);

      let pdfGenerator;
      // AI PDF GENERATOR - Now uses OpenAI (naming is legacy from Gemini migration)
      const USE_AI_PDF_GENERATOR = true; // Set to false to use basic fallback

      if (USE_AI_PDF_GENERATOR && GeminiPdfGenerator) {
        console.log('\nü§ñ === USING AI PDF GENERATOR (OpenAI) ===');
        console.log('   Engine: OpenAI GPT-4 + PDFKit');
        console.log('   Patient:', pdfPatientData.name);
        console.log('   Parameters:', pdfAlgorithmResults.parameters.length);
        try {
          pdfGenerator = new GeminiPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);
          console.log('‚úÖ Gemini PDF Generator instantiated successfully');
        } catch (instantiateError) {
          console.error('‚ùå Failed to instantiate Gemini PDF Generator:', instantiateError.message);
          throw instantiateError;
        }
      } else if (EnhancedAIPdfGenerator) {
        console.log('ü§ñ Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');
        pdfGenerator = new EnhancedAIPdfGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);
      } else {
        console.log('üìÑ Using Standard PDF Generator (Basic fallback)');
        pdfGenerator = new PDFReportGenerator(pdfPatientData, pdfAlgorithmResults, qeegData);
      }

      // Generate the PDF
      console.log('\nüìù Calling pdfGenerator.generateReport()...');
      console.log('   Output path:', pdfOutputPath);

      try {
        await pdfGenerator.generateReport(pdfOutputPath);
        console.log('‚úÖ PDF generation completed!');
      } catch (genError) {
        console.error('‚ùå PDF generation threw error:', genError.message);
        console.error('   Stack:', genError.stack);
        throw genError;
      }

      // Verify file was created
      if (!fs.existsSync(pdfOutputPath)) {
        throw new Error('PDF file was not created at expected path: ' + pdfOutputPath);
      }

      console.log('‚úÖ PDF file verified at:', pdfOutputPath);
      console.log('üìÑ File:', pdfFilename);
      console.log('üìä Size:', (fs.statSync(pdfOutputPath).size / 1024).toFixed(2), 'KB');

      // Upload to Supabase Storage
      try {
        console.log('\n‚òÅÔ∏è  Uploading PDF to Supabase storage...');
        const uploadResult = await SupabaseStorage.uploadFile(
          pdfOutputPath,
          'patient-reports', // bucket name - FIXED
          `reports/${pdfFilename}` // path in bucket
        );

        // Verify upload was successful and URL is valid
        if (uploadResult && uploadResult.url) {
          pdfUrl = uploadResult.url;
          console.log('‚úÖ PDF uploaded to Supabase successfully');
          console.log('üîó Supabase URL:', pdfUrl);

          // Delete local file after successful Supabase upload
          try {
            fs.unlinkSync(pdfOutputPath);
            console.log('üóëÔ∏è  Local PDF file deleted after successful upload');
          } catch (deleteError) {
            console.warn('‚ö†Ô∏è  Could not delete local PDF file:', deleteError.message);
          }
        } else {
          throw new Error('Supabase upload returned invalid result');
        }
      } catch (supabaseError) {
        console.error('‚ö†Ô∏è  Supabase upload failed, using local storage');
        console.error('   Error message:', supabaseError.message);
        console.error('   Error stack:', supabaseError.stack);
        console.error('   Full error:', JSON.stringify(supabaseError, null, 2));
        // Fallback to local storage
        pdfUrl = `/uploads/${pdfFilename}`;
        console.log('üìÅ Using local file as fallback:', pdfUrl);
      }

    } catch (pdfError) {
      console.error('\n‚ùå === PDF GENERATION FAILED ===');
      console.error('Error message:', pdfError.message);
      console.error('Error stack:', pdfError.stack);
      console.error('Full error:', pdfError);
      console.error('=================================\n');

      // Set pdfUrl to null so frontend knows PDF failed
      pdfUrl = null;

      // Don't fail the whole request if PDF fails - processing still succeeded
      console.log('‚ö†Ô∏è Continuing without PDF - processing succeeded');
    }

    // Clean up uploaded files
    try {
      fs.unlinkSync(eyesOpenFile.path);
      fs.unlinkSync(eyesClosedFile.path);
      console.log('\nüóëÔ∏è  Temporary files cleaned up');
    } catch (cleanupError) {
      console.error('‚ö†Ô∏è  Error cleaning up files:', cleanupError.message);
    }

    console.log('\nüèÅ === QEEG Processing Completed ===\n');

    // Final check for PDF URL
    if (!pdfUrl) {
      console.warn('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è WARNING: No PDF URL available in response!');
      console.warn('   pdfFilename was:', pdfFilename || 'NOT SET');
      console.warn('   This means PDF generation completely failed');
    } else {
      console.log('‚úÖ PDF URL ready:', pdfUrl);
      console.log('   Type:', pdfUrl.startsWith('http') ? 'Supabase' : 'Local');
    }

    // Send response
    res.json({
      success: true,
      data: {
        patientId,
        patientName,
        clinicName,
        processedAt: new Date().toISOString(),
        dataType: 'raw', // Using RAW power calculator (as per specification)
        results: results.parameters,
        overallScore: results.overallScore,
        maxScore: 21,
        pdfUrl: pdfUrl,
        pdfFilename: pdfFilename
      }
    });

  } catch (error) {
    console.error('\n‚ùå === QEEG Processing Failed ===');
    console.error('Error:', error.message);
    console.error('Error Code:', error.code || 'UNKNOWN');
    console.error('Stack:', error.stack);

    // Clean up files on error
    if (eyesOpenFile && fs.existsSync(eyesOpenFile.path)) {
      try {
        fs.unlinkSync(eyesOpenFile.path);
      } catch (e) {
        console.error('Error deleting Eyes Open file:', e.message);
      }
    }
    if (eyesClosedFile && fs.existsSync(eyesClosedFile.path)) {
      try {
        fs.unlinkSync(eyesClosedFile.path);
      } catch (e) {
        console.error('Error deleting Eyes Closed file:', e.message);
      }
    }

    // Categorize errors for better user feedback
    let statusCode = 500;
    let userMessage = error.message;

    // Check for Gemini quota error in error message
    if (error.message && error.message.includes('429') && error.message.includes('quota')) {
      error.code = 'GEMINI_QUOTA_EXCEEDED';
    }

    switch (error.code) {
      case 'MISSING_API_KEY':
      case 'INVALID_API_KEY':
      case 'INVALID_API_KEY_FORMAT':
      case 'API_CONNECTION_FAILED':
        statusCode = 503; // Service Unavailable
        userMessage = 'System configuration error: API key not properly configured. Please contact support.';
        break;

      case 'PDF_EXTRACTION_FAILED':
        statusCode = 422; // Unprocessable Entity
        userMessage = 'Failed to extract QEEG data from PDF. Please ensure the PDF contains valid QEEG tables with absolute and relative power values.';
        break;

      case 'GEMINI_QUOTA_EXCEEDED':
        statusCode = 429; // Too Many Requests
        userMessage = '‚ö†Ô∏è API Quota Exceeded\n\n' +
                     'The Gemini API free tier limit has been reached.\n\n' +
                     'Solutions:\n' +
                     '1. Wait a few hours for quota to reset (resets at midnight PST)\n' +
                     '2. Try re-uploading previously processed files (uses cache, no quota consumed)\n' +
                     '3. Upgrade to paid plan: https://ai.google.dev/pricing\n' +
                     '4. Contact administrator for assistance\n\n' +
                     'Cache Info: The system remembers files you\'ve uploaded before - those won\'t use quota!';
        break;

      default:
        // If error message contains Gemini quota keywords, classify it
        if (userMessage && (userMessage.includes('quota') || userMessage.includes('429') || userMessage.includes('Too Many Requests'))) {
          statusCode = 429;
          userMessage = '‚ö†Ô∏è API Quota Exceeded\n\n' +
                       'The Gemini AI service has reached its daily request limit.\n\n' +
                       'Solutions:\n' +
                       '‚Ä¢ Wait for quota reset (usually resets at midnight PST)\n' +
                       '‚Ä¢ Re-upload the same files (cached, no quota used)\n' +
                       '‚Ä¢ Contact administrator to upgrade API plan\n\n' +
                       'Technical Details: ' + error.message;
        } else {
          userMessage = error.message || 'Failed to process QEEG files';
        }
    }

    res.status(statusCode).json({
      error: true,
      message: userMessage,
      code: error.code || 'UNKNOWN_ERROR',
      technicalDetails: process.env.NODE_ENV === 'development' ? {
        originalMessage: error.message,
        stack: error.stack,
        condition: error.condition
      } : undefined
    });
  }
});

/**
 * POST /api/qeeg/generate-pdf
 * Generate PDF report from algorithm results
 */
router.post('/generate-pdf', async (req, res) => {
  try {
    console.log('\nüìÑ === PDF Report Generation Started ===\n');

    const { patientData, algorithmResults, qeegData } = req.body;

    // Validate input
    if (!patientData || !algorithmResults || !qeegData) {
      return res.status(400).json({
        error: true,
        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'
      });
    }

    console.log('üë§ Patient:', patientData.name);
    console.log('üìä Parameters:', algorithmResults.parameters?.length);

    // === USE GEMINI PDF GENERATOR (if available) ===
    let generator;
    if (GeminiPdfGenerator) {
      console.log('ü§ñ Using Gemini AI PDF Generator (Google Gemini + PDFKit)');
      generator = new GeminiPdfGenerator(patientData, algorithmResults, qeegData);
    } else if (EnhancedAIPdfGenerator) {
      console.log('ü§ñ Using Enhanced AI PDF Generator (OpenAI + PDFKit - Fallback)');
      generator = new EnhancedAIPdfGenerator(patientData, algorithmResults, qeegData);
    } else {
      console.log('üìÑ Using Standard PDF Generator (Basic fallback)');
      generator = new PDFReportGenerator(patientData, algorithmResults, qeegData);
    }

    // Create output filename
    const timestamp = Date.now();
    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `neurosense-report-${sanitizedName}-${timestamp}.pdf`;
    const outputPath = path.join(__dirname, '../uploads', filename);

    console.log('üìù Generating AI-powered PDF to:', filename);

    // Generate the PDF with AI insights
    const pdfPath = await generator.generateReport(outputPath);

    console.log('\n‚úÖ PDF Report Generated Successfully!');
    console.log('üìÑ File:', filename);
    console.log('üìä Size:', (fs.statSync(pdfPath).size / 1024).toFixed(2), 'KB');

    // Upload to Supabase Storage - TEMPORARILY DISABLED
    let supabaseUrl = null;
    let supabasePath = null;
    let uploadError = null;

    // DISABLE SUPABASE UPLOAD FOR NOW - USE LOCAL STORAGE ONLY
    console.log('\nüìÅ Using local storage (Supabase upload disabled)');
    uploadError = 'Supabase upload disabled - using local storage';

    /* COMMENTED OUT - Enable when Supabase is configured properly
    try {
      console.log('\n‚òÅÔ∏è  Uploading PDF to Supabase storage...');
      const uploadResult = await SupabaseStorage.uploadFile(
        pdfPath,
        'patient-reports', // bucket name
        `reports/${filename}` // path in bucket
      );

      // Verify upload was successful and URL is valid
      if (uploadResult && uploadResult.url) {
        supabaseUrl = uploadResult.url;
        supabasePath = uploadResult.path;

        console.log('‚úÖ PDF uploaded to Supabase successfully');
        console.log('üîó Supabase URL:', supabaseUrl);

        // Only delete local file after SUCCESSFUL Supabase upload
        try {
          fs.unlinkSync(pdfPath);
          console.log('üóëÔ∏è  Local PDF file deleted after successful upload');
        } catch (deleteError) {
          console.warn('‚ö†Ô∏è  Could not delete local PDF file:', deleteError.message);
        }
      } else {
        throw new Error('Supabase upload returned invalid result');
      }

    } catch (error) {
      console.error('‚ö†Ô∏è  Supabase upload failed, using local storage:', error.message);
      uploadError = error.message;
      // Keep local file as fallback - DO NOT DELETE
      console.log('üìÅ Using local file as fallback');
    }
    */

    console.log('\nüèÅ === PDF Generation Completed ===\n');

    // Return PDF info - prioritize Supabase URL
    res.json({
      success: true,
      data: {
        filename: filename,
        path: supabasePath || `/uploads/${filename}`,
        url: supabaseUrl || `${req.protocol}://${req.get('host')}/uploads/${filename}`,
        size: fs.existsSync(pdfPath) ? fs.statSync(pdfPath).size : 0,
        generatedAt: new Date().toISOString(),
        storage: supabaseUrl ? 'supabase' : 'local',
        uploadError: uploadError
      }
    });

  } catch (error) {
    console.error('\n‚ùå === PDF Generation Failed ===');
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);

    res.status(500).json({
      error: true,
      message: error.message || 'Failed to generate PDF report',
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * POST /api/qeeg/generate-sample-pdf
 * Generate a sample PDF report for testing
 */
router.post('/generate-sample-pdf', async (req, res) => {
  try {
    console.log('\nüìÑ === Sample PDF Generation Started ===\n');

    const pdfPath = await PDFReportGenerator.generateSampleReport();

    console.log('‚úÖ Sample PDF Generated!');
    console.log('üìÑ Path:', pdfPath);

    const filename = path.basename(pdfPath);

    res.json({
      success: true,
      data: {
        filename: filename,
        path: `/uploads/${filename}`,
        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,
        size: fs.statSync(pdfPath).size
      }
    });

  } catch (error) {
    console.error('‚ùå Sample PDF generation failed:', error);

    res.status(500).json({
      error: true,
      message: error.message
    });
  }
});

/**
 * POST /api/qeeg/generate-ai-pdf
 * Generate AI-powered PDF report with enhanced design and content
 */
router.post('/generate-ai-pdf', async (req, res) => {
  try {
    console.log('\nü§ñ === AI PDF Report Generation Started ===\n');

    const { patientData, algorithmResults, qeegData } = req.body;

    // Validate input
    if (!patientData || !algorithmResults || !qeegData) {
      return res.status(400).json({
        error: true,
        message: 'Missing required data: patientData, algorithmResults, and qeegData are required'
      });
    }

    console.log('üë§ Patient:', patientData.name);
    console.log('üìä Parameters:', algorithmResults.parameters?.length);
    console.log('üéØ Using AI-powered generation with enhanced prompt');

    // Generate AI PDF
    const generator = new AIPdfGenerator(patientData, algorithmResults, qeegData);

    // Create output filename
    const timestamp = Date.now();
    const sanitizedName = (patientData.name || 'patient').replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `ai-neurosense-report-${sanitizedName}-${timestamp}.pdf`;
    const outputPath = path.join(__dirname, '../uploads', filename);

    console.log('üìù Generating AI PDF to:', filename);

    // Generate the PDF
    const result = await generator.generateReport(outputPath);

    console.log('\n‚úÖ AI NeuroSense Report Generated Successfully!');
    console.log('üìÑ Text File:', path.basename(result.textOutputPath));
    console.log('üìÑ JSON File:', path.basename(result.outputPath));
    console.log('üìä Tokens Used:', result.tokensUsed);
    console.log('üìè Content Length:', result.contentLength, 'characters');
    console.log('\nüèÅ === AI PDF Generation Completed ===\n');

    // Return report info
    res.json({
      success: true,
      data: {
        textFile: {
          filename: path.basename(result.textOutputPath),
          path: `/uploads/${path.basename(result.textOutputPath)}`,
          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.textOutputPath)}`,
          type: 'Plain Text Report'
        },
        jsonFile: {
          filename: path.basename(result.outputPath),
          path: `/uploads/${path.basename(result.outputPath)}`,
          url: `${req.protocol}://${req.get('host')}/uploads/${path.basename(result.outputPath)}`,
          type: 'Structured Data (JSON)'
        },
        contentLength: result.contentLength,
        tokensUsed: result.tokensUsed,
        generatedAt: new Date().toISOString()
      },
      message: 'AI-powered NeuroSense report generated successfully. Text file contains formatted report ready for PDF conversion.'
    });

  } catch (error) {
    console.error('\n‚ùå === AI PDF Generation Failed ===');
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);

    res.status(500).json({
      error: true,
      message: error.message || 'Failed to generate AI PDF report',
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * POST /api/qeeg/generate-ai-sample-pdf
 * Generate a sample AI-powered PDF report for testing
 */
router.post('/generate-ai-sample-pdf', async (req, res) => {
  try {
    console.log('\nü§ñ === Sample AI PDF Generation Started ===\n');

    const result = await AIPdfGenerator.generateSampleReport();

    console.log('‚úÖ Sample AI PDF Generated!');
    console.log('üìÑ Path:', result.outputPath);

    const filename = path.basename(result.outputPath);

    res.json({
      success: true,
      data: {
        filename: filename,
        path: `/uploads/${filename}`,
        url: `${req.protocol}://${req.get('host')}/uploads/${filename}`,
        contentLength: result.contentLength,
        tokensUsed: result.tokensUsed,
        type: 'AI-Generated Sample (JSON format)'
      }
    });

  } catch (error) {
    console.error('‚ùå Sample AI PDF generation failed:', error);

    res.status(500).json({
      error: true,
      message: error.message
    });
  }
});

/**
 * GET /api/qeeg/supabase-pdfs
 * List all PDFs from Supabase bucket
 */
router.get('/supabase-pdfs', async (req, res) => {
  try {
    console.log('üìã Fetching PDFs from Supabase bucket...');

    const files = await SupabaseStorage.listFiles('patient-reports', 'reports');

    // Get public URLs for all files
    const pdfs = files.map(file => {
      const { createClient } = require('@supabase/supabase-js');
      const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);
      const { data: urlData } = supabase.storage
        .from('patient-reports')
        .getPublicUrl(`reports/${file.name}`);

      return {
        name: file.name,
        url: urlData.publicUrl,
        created_at: file.created_at,
        size: file.metadata?.size
      };
    });

    console.log(`‚úÖ Found ${pdfs.length} PDFs in Supabase bucket`);

    res.json({
      success: true,
      count: pdfs.length,
      pdfs: pdfs
    });

  } catch (error) {
    console.error('‚ùå Error listing Supabase PDFs:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/qeeg/test
 * Test endpoint to verify API is working
 */
router.get('/test', (req, res) => {
  res.json({
    success: true,
    message: 'QEEG Processing API is working',
    endpoints: {
      process: 'POST /api/qeeg/process - Upload and process QEEG files',
      generatePdf: 'POST /api/qeeg/generate-pdf - Generate PDF report from results (PDFKit)',
      generateSamplePdf: 'POST /api/qeeg/generate-sample-pdf - Generate sample PDF report (PDFKit)',
      generateAiPdf: 'POST /api/qeeg/generate-ai-pdf - Generate AI-powered PDF report (OpenAI)',
      generateAiSamplePdf: 'POST /api/qeeg/generate-ai-sample-pdf - Generate AI sample PDF report (OpenAI)',
      generateGeminiReport: 'POST /api/qeeg/generate-gemini-report - Generate AI report structure using Gemini',
      supabasePdfs: 'GET /api/qeeg/supabase-pdfs - List all PDFs from Supabase bucket',
      quotaStatus: 'GET /api/qeeg/quota-status - Check Gemini API quota usage'
    }
  });
});

/**
 * GET /api/qeeg/quota-status
 * Check Gemini API quota usage and limits
 */
router.get('/quota-status', (req, res) => {
  try {
    const quotaStatus = QEEGParser.getQuotaStatus();

    // Calculate time until reset
    const now = new Date();
    const nextReset = new Date(quotaStatus.nextDayReset);
    const hoursUntilReset = Math.max(0, (nextReset - now) / (1000 * 60 * 60));

    res.json({
      success: true,
      quota: {
        daily: {
          used: quotaStatus.dailyUsed,
          limit: quotaStatus.dailyLimit,
          remaining: quotaStatus.dailyRemaining,
          percentUsed: quotaStatus.dailyPercentUsed + '%',
          status: quotaStatus.dailyRemaining === 0 ? 'EXHAUSTED' :
                  quotaStatus.dailyPercentUsed >= 80 ? 'WARNING' : 'OK'
        },
        minute: {
          used: quotaStatus.minuteUsed,
          limit: quotaStatus.minuteLimit
        },
        lastRequest: quotaStatus.lastRequestTime,
        nextReset: quotaStatus.nextDayReset,
        hoursUntilReset: hoursUntilReset.toFixed(1)
      },
      recommendations: quotaStatus.dailyRemaining === 0 ? [
        'Daily quota exhausted. Wait ' + hoursUntilReset.toFixed(1) + ' hours for reset.',
        'Or re-upload the SAME files to use cache (no quota used)',
        'Or upgrade to paid plan at https://ai.google.dev/pricing'
      ] : quotaStatus.dailyPercentUsed >= 80 ? [
        'Approaching daily limit. Consider upgrading soon.',
        'Re-uploading same files uses cache (no quota)'
      ] : [
        'Quota is healthy. You can process ' + Math.floor(quotaStatus.dailyRemaining / 2) + ' more patients today.'
      ]
    });
  } catch (error) {
    console.error('Error getting quota status:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get quota status',
      message: error.message
    });
  }
});

/**
 * POST /api/qeeg/generate-gemini-report
 * Generate AI-powered report structure using Google Gemini
 */
router.post('/generate-gemini-report', async (req, res) => {
  try {
    console.log('\nü§ñ === Gemini AI Report Generation Started ===\n');

    if (!GeminiService) {
      return res.status(503).json({
        error: true,
        message: 'Gemini AI service is not available. Please check server configuration.'
      });
    }

    const { algorithmResults } = req.body;

    // Validate input
    if (!algorithmResults || !algorithmResults.parameters) {
      return res.status(400).json({
        error: true,
        message: 'Missing required data: algorithmResults with parameters array is required'
      });
    }

    console.log('üìä Processing', algorithmResults.parameters.length, 'brain parameters');

    // Transform algorithm results to the format expected by Gemini
    const brainParameters = {
      Cognition: null,
      Stress: null,
      FocusAndAttention: null,
      BurnoutAndFatigue: null,
      EmotionalRegulation: null,
      Learning: null,
      Creativity: null
    };

    // Map the parameters from algorithm results
    algorithmResults.parameters.forEach(param => {
      const paramName = param.name.replace(/\s+/g, '');
      if (brainParameters.hasOwnProperty(paramName)) {
        brainParameters[paramName] = {
          score: param.score,
          bucket: param.bucket,
          subparameters: param.subParameters || []
        };
      }
    });

    console.log('üß† Brain Parameters prepared for Gemini');

    // Generate report using Gemini AI
    const result = await GeminiService.generateBrainPerformanceReport(brainParameters);

    if (!result.success) {
      return res.status(500).json({
        error: true,
        message: 'Failed to generate report with Gemini AI',
        details: result.error
      });
    }

    console.log('‚úÖ Gemini AI report generated successfully');

    res.json({
      success: true,
      message: 'AI-powered report structure generated successfully',
      reportData: result.data,
      rawResponse: result.rawResponse
    });

  } catch (error) {
    console.error('‚ùå Error generating Gemini report:', error);
    res.status(500).json({
      error: true,
      message: 'Internal server error while generating Gemini report',
      details: error.message
    });
  }
});

module.exports = router;

