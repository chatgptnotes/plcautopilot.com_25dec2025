const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const pdfParse = require('pdf-parse');
const XLSX = require('xlsx');

// üöÄ TRADITIONAL PARSER (NO AI) - Fast, reliable, deterministic
const TraditionalQeegParser = require('./traditionalQeegParser');

// ‚ùå AI SERVICES REMOVED - No longer imported at startup
// const { GoogleGenerativeAI } = require('@google/generative-ai'); // REMOVED
// const rateLimiter = require('./geminiRateLimiter'); // REMOVED
// const OpenAIParser = require('./openAIParser'); // REMOVED

// Set AI variables to null (not loaded)
let OpenAIParser = null;
let genAI = null;
let geminiModel = null;
let rateLimiter = null;

// üîÄ AI Service: Read from environment variable
// Options: 'traditional' (default, no AI), 'openai', 'gemini'
const AI_SERVICE = process.env.AI_SERVICE || 'traditional';

// Debug: Log parsing service configuration
console.log('\nüîÄ ===== QEEG PARSING SERVICE CONFIGURATION =====');
console.log(`   Parser Mode: ${AI_SERVICE.toUpperCase()}`);
if (AI_SERVICE === 'traditional') {
  console.log(`   ‚úÖ Using TRADITIONAL PARSER (No AI, Fast, Deterministic)`);
  console.log(`   ‚úÖ AI Services: DISABLED (Not loaded at startup)`);
} else {
  console.log(`   ‚ö†Ô∏è  AI Mode Enabled - Services will load on-demand`);
  console.log(`   Gemini key present: ${!!process.env.GEMINI_API_KEY}`);
  console.log(`   OpenAI key present: ${!!process.env.OPENAI_API_KEY}`);
}
console.log('==============================================\n');

// In-memory cache for PDF extraction results (ensures deterministic behavior)
// Key: PDF MD5 hash ‚Üí Value: Extracted QEEG data
const extractionCache = new Map();

// Cache statistics for monitoring
const cacheStats = {
  hits: 0,
  misses: 0,
  totalExtractions: 0
};

class QEEGParser {
  /**
   * Fetch available Gemini models that support generateContent
   * @returns {Promise<Array>} List of available models
   */
  static async fetchAvailableModels() {
    try {
      console.log('üîç Fetching available Gemini models...');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1/models?key=${process.env.GEMINI_API_KEY}`
      );

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      // Filter models that support generateContent
      const supportedModels = (data.models || []).filter(model =>
        model.supportedGenerationMethods?.includes('generateContent')
      );

      console.log(`‚úÖ Found ${supportedModels.length} models that support generateContent:`);
      supportedModels.forEach(model => {
        console.log(`   - ${model.name}`);
      });

      return supportedModels;
    } catch (error) {
      console.error('‚ùå Failed to fetch models:', error.message);
      return [];
    }
  }

  /**
   * Select best available model from list
   * @param {Array} models - List of available models
   * @returns {string|null} Model name to use
   */
  static selectBestModel(models) {
    if (!models || models.length === 0) return null;

    // Priority: flash models (fastest) > pro models > any other
    const preferences = ['flash', 'pro'];

    for (const preference of preferences) {
      const found = models.find(m =>
        m.name.toLowerCase().includes(preference)
      );
      if (found) {
        console.log(`‚úÖ Selected model: ${found.name}`);
        return found.name;
      }
    }

    // Fallback to first available
    console.log(`‚úÖ Using first available model: ${models[0].name}`);
    return models[0].name;
  }

  /**
   * Validate Gemini API key is configured and appears valid
   * @throws {Error} if API key is missing or invalid format
   */
  static validateAPIKey() {
    const apiKey = process.env.GEMINI_API_KEY;

    // Check if key exists
    if (!apiKey || apiKey.trim() === '') {
      const error = new Error('GEMINI_API_KEY environment variable is not set');
      error.code = 'MISSING_API_KEY';
      throw error;
    }

    // Check if key is placeholder
    if (apiKey === 'your-gemini-api-key-here' || apiKey.includes('placeholder')) {
      const error = new Error('GEMINI_API_KEY is set to placeholder value. Please configure a valid Gemini API key.');
      error.code = 'INVALID_API_KEY';
      throw error;
    }

    console.log('‚úÖ Gemini API key validation passed');
    return true;
  }

  /**
   * Test Gemini API connection with a simple request
   * @returns {Promise<boolean>} true if connection successful
   * @throws {Error} if connection fails
   */
  static async testAPIConnection() {
    try {
      this.validateAPIKey();

      console.log('üîå Testing Gemini API connection...');

      if (!geminiModel) {
        console.log('üîë API Key check:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          throw new Error('No Gemini models available. Check your API key at https://aistudio.google.com/apikey');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model');
        }

        // Initialize model with full path
        console.log(`üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({ model: modelName });

        // Test it with simple call
        console.log('üìû Testing model with simple call...');
        const testResult = await geminiModel.generateContent('Hello');
        await testResult.response;
        console.log('‚úÖ Model initialized and tested successfully');
      }

      const result = await geminiModel.generateContent('Reply with OK');
      const response = await result.response;
      const text = response.text();

      if (text) {
        console.log('‚úÖ Gemini API connection successful');
        return true;
      } else {
        throw new Error('Gemini API returned unexpected response');
      }

    } catch (error) {
      console.error('‚ùå Gemini API connection test failed:', error.message);
      const enhancedError = new Error(`Gemini API connection test failed: ${error.message}`);
      enhancedError.code = 'API_CONNECTION_FAILED';
      enhancedError.originalError = error;
      throw enhancedError;
    }
  }

  /**
   * Detect report type (raw power values or Z-scores)
   * @param {Object} file - Multer file object
   * @returns {Promise<string>} 'raw' or 'zscore'
   */
  static async detectReportType(file) {
    try {
      console.log(`üîç Detecting report type for: ${file.originalname}`);

      const dataBuffer = fs.readFileSync(file.path);
      const pdfData = await pdfParse(dataBuffer);
      const text = pdfData.text.toLowerCase();

      // Keyword detection
      const zscoreKeywords = ['z-score', 'z score', 'z =', 'z=', 'standard deviation', 'sd from mean'];
      const rawKeywords = ['absolute power (Œºv¬≤)', 'absolute power (uv¬≤)', 'relative power (%)', 'Œºv¬≤', 'uv¬≤'];

      let zscoreCount = 0;
      let rawCount = 0;

      // Count keyword occurrences
      zscoreKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        zscoreCount += matches;
      });

      rawKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        rawCount += matches;
      });

      console.log(`   Z-score keywords found: ${zscoreCount}`);
      console.log(`   Raw power keywords found: ${rawCount}`);

      // Decision logic
      if (zscoreCount > rawCount && zscoreCount >= 3) {
        console.log(`‚úÖ Detected: Z-SCORE report`);
        return 'zscore';
      } else if (rawCount > zscoreCount && rawCount >= 2) {
        console.log(`‚úÖ Detected: RAW POWER report`);
        return 'raw';
      } else if (zscoreCount > 0 && rawCount > 0) {
        // Mixed report - check for table structure
        if (text.includes('z-score table') || text.includes('z score table')) {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring Z-SCORE`);
          return 'zscore';
        } else {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring RAW POWER`);
          return 'raw';
        }
      } else {
        // Fallback: assume raw if unclear
        console.warn(`‚ö†Ô∏è Could not clearly detect report type - defaulting to RAW POWER`);
        return 'raw';
      }

    } catch (error) {
      console.error(`‚ùå Error detecting report type for ${file.originalname}:`, error.message);
      // Safe default
      console.warn(`   Defaulting to RAW POWER mode`);
      return 'raw';
    }
  }

  /**
   * Main method to parse uploaded files
   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data
   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data
   * @returns {Object} Parsed QEEG data
   */
  static async parse(eyesOpenFile, eyesClosedFile) {
    try {
      console.log('\nüìÑ === QEEG File Parsing Started ===');
      console.log('  - Eyes Open:', eyesOpenFile?.originalname);
      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);

      // STEP 1: Detect report types
      console.log('\nüîç STEP 1: Detecting report types...');
      const eoReportType = await this.detectReportType(eyesOpenFile);
      const ecReportType = await this.detectReportType(eyesClosedFile);

      console.log(`\nüìä Detection Results:`);
      console.log(`  - Eyes Open: ${eoReportType.toUpperCase()}`);
      console.log(`  - Eyes Closed: ${ecReportType.toUpperCase()}`);

      // STEP 2: Validate matching types
      console.log('\n‚úì STEP 2: Validating report type consistency...');
      if (eoReportType !== ecReportType) {
        const error = new Error(
          `‚ùå Mismatched report types detected!\n\n` +
          `Eyes Open is ${eoReportType.toUpperCase()}, but Eyes Closed is ${ecReportType.toUpperCase()}.\n\n` +
          `Both files must be the same type (either both RAW POWER or both Z-SCORE reports).\n` +
          `Please upload matching report types and try again.`
        );
        error.code = 'REPORT_TYPE_MISMATCH';
        throw error;
      }

      const reportType = eoReportType;
      console.log(`‚úÖ Report type validated: ${reportType.toUpperCase()} mode\n`);

      // STEP 3: Determine file formats (pdf, csv, excel)
      console.log('üìÅ STEP 3: Determining file formats...');
      const eoFileType = this.getFileType(eyesOpenFile.originalname);
      const ecFileType = this.getFileType(eyesClosedFile.originalname);
      console.log(`  - Eyes Open: ${eoFileType}`);
      console.log(`  - Eyes Closed: ${ecFileType}\n`);

      // STEP 4: Parse each file with appropriate method
      console.log('üìñ STEP 4: Extracting data from files...');
      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO', reportType);
      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC', reportType);

      // STEP 5: Combine data with metadata
      console.log('\nüîó STEP 5: Combining data...');
      const combinedData = {
        EO: eyesOpenData,
        EC: eyesClosedData,
        dataType: reportType // Add metadata
      };

      console.log(`‚úÖ QEEG files parsed successfully in ${reportType.toUpperCase()} mode`);
      console.log('=== QEEG File Parsing Completed ===\n');
      return combinedData;

    } catch (error) {
      console.error('\n‚ùå === QEEG File Parsing Failed ===');
      console.error('Error:', error.message);
      if (error.code === 'REPORT_TYPE_MISMATCH') {
        // Re-throw mismatch errors with original message
        throw error;
      } else {
        throw new Error(`Failed to parse QEEG files: ${error.message}`);
      }
    }
  }

  /**
   * Determine file type from filename
   */
  static getFileType(filename) {
    const ext = path.extname(filename).toLowerCase();
    if (ext === '.pdf') return 'pdf';
    if (ext === '.csv') return 'csv';
    if (ext === '.xlsx' || ext === '.xls') return 'excel';
    throw new Error(`Unsupported file type: ${ext}`);
  }

  /**
   * Parse a single file based on its type
   */
  static async parseFile(file, fileType, condition, reportType = 'raw') {
    if (fileType === 'pdf') {
      return await this.parsePDF(file, condition, reportType);
    } else if (fileType === 'csv') {
      return this.parseCSV(file);
    } else if (fileType === 'excel') {
      return this.parseExcel(file);
    }
    throw new Error(`Unknown file type: ${fileType}`);
  }

  /**
   * Get extraction prompt based on report type
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   * @param {string} pdfText - PDF text content
   * @returns {string} Extraction prompt
   */
  static getExtractionPrompt(condition, reportType, pdfText) {
    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';

    if (reportType === 'zscore') {
      // Z-SCORE extraction prompt
      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.

**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.
- Negative values = below average (lower than normal)
- Zero (0) = average (normal)
- Positive values = above average (higher than normal)

Look for tables labeled with "Z-score", "Z score", "Z", or "Standard Deviation" in the headers.

Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract Z-scores for these frequency bands:
- Delta (1-4 Hz)
- Theta (4-8 Hz)
- Alpha (8-13 Hz)
- Beta (13-30 Hz)
- HiBeta / High Beta (20-30 Hz)

Also extract:
- Alpha Peak Frequency (Hz) and its Z-score if available

If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return ONLY this EXACT JSON format:
{
  "zscores": {
    "absolute": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    },
    "relative": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

PDF Content (Extracted from pages 13 & 24):
${this.extractRelevantPages(pdfText)}`;

    } else {
      // RAW POWER extraction prompt (highly improved for complete extraction)
      return `You are an expert QEEG data extraction specialist. Your task is to extract COMPLETE frequency band data from this ${conditionName} QEEG report PDF.

üéØ YOUR MISSION: Extract 100% COMPLETE DATA - No Missing Bands Allowed!

üìä WHAT TO EXTRACT:
Extract TWO complete tables:
1. **Absolute Power (ŒºV¬≤)** - Brain wave power in microvolts squared
2. **Relative Power (%)** - Percentage distribution (MUST sum to ~100% per channel)

üìç WHERE TO LOOK IN THE PDF:
- Usually on Pages 13 & 24 (for Eyes Open & Eyes Closed)
- Look for table headers like:
  * "Absolute Power" / "Absolute Spectral Power" / "Absolute" / "ABS"
  * "Relative Power" / "Relative Spectral Power" / "Relative" / "REL"
  * "Monopolar" / "Linked Ears" / "Average Reference"
- Tables may span multiple pages - check thoroughly!
- Sometimes bands are in separate sections or sub-tables

üß† CHANNELS TO EXTRACT (19 channels):
FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

üìä FREQUENCY BANDS (ALL 5 REQUIRED):
For EACH channel, you MUST extract ALL 5 bands:
1. **Delta** (Œ¥) - 0.5-4 Hz, 1-4 Hz, or labeled as "Delta" - Usually highest power
2. **Theta** (Œ∏) - 4-8 Hz or labeled as "Theta"
3. **Alpha** (Œ±) - 8-13 Hz or labeled as "Alpha" - Often dominant when relaxed
4. **Beta** (Œ≤) - 13-30 Hz, 13-25 Hz, or labeled as "Beta"
5. **HiBeta** (High Beta / Œ≤Œ≤) - 20-30 Hz, 25-30 Hz, 30-50 Hz, or labeled as "High Beta" / "HiBeta" / "Hi-Beta" - Usually smallest

‚ö†Ô∏è IMPORTANT: Band labels may vary in PDFs:
- Look for columns/rows labeled: "Delta", "Theta", "Alpha", "Beta", "High Beta", "Hi-Beta", "HiBeta", "Œ≤Œ≤"
- Frequency ranges might be shown in headers (e.g., "1-4 Hz", "4-8 Hz", etc.)
- Some tables have bands as COLUMNS, some as ROWS - check both!
- Tables may be split across multiple sections - search thoroughly!

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ABSOLUTELY CRITICAL REQUIREMENTS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

1. **100% COMPLETENESS**: Extract ALL 5 bands for EVERY channel
   - If a band shows "0" or very small value (0.1, 0.01), INCLUDE IT
   - DO NOT leave any band as 0 unless it truly says 0 in the table

2. **VALIDATION CHECK**: For Relative Power, EACH channel must sum to ~100%
   Example: Fz: Delta(30%) + Theta(20%) + Alpha(25%) + Beta(20%) + HiBeta(5%) = 100%
   - If your extracted data doesn't sum to ~100% for EACH channel, YOU MADE A MISTAKE
   - Go back and find the missing bands!

3. **SEARCH THOROUGHLY**:
   - Check ALL pages of the PDF, not just the first page
   - Look for continuation of tables on next pages
   - Some PDFs have separate sub-tables for each band - combine them
   - Tables might be labeled "Page 1/2", "Page 2/2" - check both!

4. **DON'T SKIP CHANNELS**: All 19 channels should have complete data
   - If some channels are truly missing from PDF, use 0 for those
   - But most standard QEEG reports have all 19 channels

5. **PRESERVE EXACT VALUES**: Copy numbers exactly as they appear
   - Don't round or modify values
   - Include decimal places (e.g., 25.3, not 25)

üìã EXAMPLE OF **CORRECT** EXTRACTION (Relative Power):
{
  "Fz": {
    "Delta": 28.5,   // ‚úì Has value
    "Theta": 22.3,   // ‚úì Has value
    "Alpha": 25.1,   // ‚úì Has value
    "Beta": 18.9,    // ‚úì Has value
    "HiBeta": 5.2    // ‚úì Has value
  }
  // Sum = 100% ‚úì CORRECT!
}

‚ùå EXAMPLE OF **WRONG** EXTRACTION:
{
  "Fz": {
    "Delta": 28.5,
    "Theta": 22.3,
    "Alpha": 0,      // ‚ùå WRONG - Missing!
    "Beta": 0,       // ‚ùå WRONG - Missing!
    "HiBeta": 0      // ‚ùå WRONG - Missing!
  }
  // Sum = 50.8% ‚ùå INCOMPLETE! Find the missing bands!
}

üîç EXTRACTION STRATEGY:
1. First, locate the Absolute Power table - extract all bands for all channels
2. Then, locate the Relative Power table - extract all bands for all channels
3. Double-check: Does each channel's relative power sum to ~100%?
4. If NO, go back and search for missing data in other pages/sections
5. Extract Alpha Peak Frequency (usually noted as "Peak Alpha" or "APF")

Also extract Alpha Peak Frequency (APF) if available (typical range: 8-13 Hz).

**OUTPUT FORMAT RULES**:
- Return ONLY the JSON object (no markdown, no explanations, no code blocks)
- Just pure JSON starting with { and ending with }
- No \`\`\`json markers
- No text before or after the JSON

Return the data in this EXACT JSON format:
{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "O1": 10.0
  }
}

PDF Content (Extracted from pages 13 & 24 - Full relevant sections):
${this.extractRelevantPages(pdfText)}`;
    }
  }

  /**
   * Extract specific pages from PDF (pages 13 and 24)
   * Uses keyword-based smart extraction to find relevant sections
   * @param {string} fullText - Full PDF text
   * @returns {string} Extracted relevant sections
   */
  static extractRelevantPages(fullText) {
    console.log(`  üìÑ Extracting relevant sections from PDF (targeting pages 13 & 24)...`);
    console.log(`  üìö Full text length: ${fullText.length} characters`);

    const extractedSections = [];

    // Keywords for Alpha Peak (usually page 13)
    const alphaPeakKeywords = [
      /z-?scored\s+alpha\s+peak/i,
      /alpha\s+peak\s+frequency/i,
      /peak\s+alpha/i,
      /dominant\s+alpha/i,
      /IAF/i, // Individual Alpha Frequency
      /PAF/i  // Peak Alpha Frequency
    ];

    // Keywords for Power Tables (usually page 24)
    const powerTableKeywords = [
      /absolute\s+power/i,
      /absolute\s+spectral\s+power/i,
      /relative\s+power/i,
      /relative\s+spectral\s+power/i,
      /ŒºV¬≤/,
      /uV\^2/i,
      /microvolt/i
    ];

    // Extract Alpha Peak section
    console.log(`  üîç Searching for Alpha Peak section...`);
    for (const pattern of alphaPeakKeywords) {
      const match = fullText.match(pattern);
      if (match) {
        const matchIndex = match.index;
        const start = Math.max(0, matchIndex - 3000);
        const end = Math.min(fullText.length, matchIndex + 3000);
        const section = fullText.substring(start, end);
        extractedSections.push(`\n=== ALPHA PEAK SECTION ===\n${section}\n`);
        console.log(`  ‚úÖ Found Alpha Peak section at position ${matchIndex}`);
        break;
      }
    }

    // Extract Power Tables section
    console.log(`  üîç Searching for Power Tables section...`);
    for (const pattern of powerTableKeywords) {
      const matches = [...fullText.matchAll(new RegExp(pattern, 'gi'))];
      if (matches.length > 0) {
        console.log(`  ‚úÖ Found ${matches.length} power table reference(s)`);
        // Extract around each match and combine
        matches.forEach((match, idx) => {
          const matchIndex = match.index;
          const start = Math.max(0, matchIndex - 5000);
          const end = Math.min(fullText.length, matchIndex + 10000);
          const section = fullText.substring(start, end);
          extractedSections.push(`\n=== POWER TABLE SECTION ${idx + 1} ===\n${section}\n`);
        });
        break;
      }
    }

    if (extractedSections.length === 0) {
      console.warn(`  ‚ö†Ô∏è  No specific sections found, using first 60000 characters as fallback`);
      return fullText.substring(0, 60000);
    }

    // Combine extracted sections
    let combinedText = extractedSections.join('\n\n');
    console.log(`  ‚úÖ Extracted ${extractedSections.length} relevant sections, total length: ${combinedText.length} characters`);

    // If combined text is too small, add more context from full text
    if (combinedText.length < 5000) {
      console.warn(`  ‚ö†Ô∏è  Extracted text too small (${combinedText.length} chars), adding full PDF context`);
      combinedText = fullText.substring(0, 60000);
    }

    return combinedText;
  }

  /**
   * Validate extracted QEEG data for completeness
   * @param {Object} data - Extracted QEEG data
   * @param {string} condition - 'EC' or 'EO'
   * @returns {Object} Validation result with isValid and missingFields
   */
  static validateExtractedData(data, condition) {
    console.log(`\n  üîç === VALIDATING EXTRACTED DATA (${condition}) ===`);

    const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const requiredBands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];
    const missingFields = [];

    // Check if data structure exists
    if (!data || typeof data !== 'object') {
      return {
        isValid: false,
        missingFields: ['Complete data structure is missing'],
        error: 'No data extracted from PDF'
      };
    }

    // Check absolute power
    if (!data.absolute || typeof data.absolute !== 'object') {
      missingFields.push('absolute power section');
    } else {
      requiredChannels.forEach(channel => {
        if (!data.absolute[channel]) {
          missingFields.push(`absolute.${channel}`);
        } else {
          requiredBands.forEach(band => {
            const value = data.absolute[channel][band];
            if (value === null || value === undefined) {
              missingFields.push(`absolute.${channel}.${band}`);
            }
          });
        }
      });
    }

    // Check relative power
    if (!data.relative || typeof data.relative !== 'object') {
      missingFields.push('relative power section');
    } else {
      requiredChannels.forEach(channel => {
        if (!data.relative[channel]) {
          missingFields.push(`relative.${channel}`);
        } else {
          requiredBands.forEach(band => {
            const value = data.relative[channel][band];
            if (value === null || value === undefined) {
              missingFields.push(`relative.${channel}.${band}`);
            }
          });

          // Validate relative power sums to ~100%
          const sum = requiredBands.reduce((acc, band) => {
            return acc + (data.relative[channel][band] || 0);
          }, 0);

          if (sum < 90 || sum > 110) {
            missingFields.push(`relative.${channel} (sum=${sum.toFixed(1)}%, expected ~100%)`);
          }
        }
      });
    }

    // Check alpha peak
    if (!data.special || (!data.special.alphaPeak && !data.special.O1)) {
      missingFields.push('special.alphaPeak');
    }

    const isValid = missingFields.length === 0;

    console.log(`  üìä Validation Results:`);
    console.log(`     - Status: ${isValid ? '‚úÖ VALID' : '‚ùå INVALID'}`);
    console.log(`     - Missing fields: ${missingFields.length}`);

    if (!isValid) {
      console.log(`  ‚ùå Missing/Invalid Fields:`);
      missingFields.forEach(field => {
        console.log(`     - ${field}`);
      });
    }

    console.log(`  === END VALIDATION ===\n`);

    return {
      isValid,
      missingFields,
      error: isValid ? null : `Incomplete data extraction: ${missingFields.length} fields missing`
    };
  }

  /**
   * Calculate MD5 hash of PDF file for caching
   * @param {Buffer} dataBuffer - PDF file buffer
   * @returns {string} MD5 hash
   */
  static calculatePDFHash(dataBuffer) {
    return crypto.createHash('md5').update(dataBuffer).digest('hex');
  }

  /**
   * Normalize extracted value to consistent decimal places
   * Prevents precision-related variations
   * @param {number} value - The value to normalize
   * @param {number} decimalPlaces - Number of decimal places (default: 2)
   * @returns {number|null} Normalized value
   */
  static normalizeValue(value, decimalPlaces = 2) {
    if (value === null || value === undefined || isNaN(value)) {
      return null;
    }

    // Round to consistent decimal places
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(value * multiplier) / multiplier;
  }

  /**
   * Normalize all values in extracted QEEG data
   * Ensures consistent precision across all measurements
   * @param {Object} extractedData - The raw extracted data
   * @returns {Object} Normalized data
   */
  static normalizeExtractedData(extractedData) {
    const normalized = JSON.parse(JSON.stringify(extractedData)); // Deep clone

    // Normalize absolute power values
    if (normalized.absolute) {
      Object.keys(normalized.absolute).forEach(channel => {
        Object.keys(normalized.absolute[channel]).forEach(band => {
          normalized.absolute[channel][band] =
            this.normalizeValue(normalized.absolute[channel][band], 2);
        });
      });
    }

    // Normalize relative power values
    if (normalized.relative) {
      Object.keys(normalized.relative).forEach(channel => {
        Object.keys(normalized.relative[channel]).forEach(band => {
          normalized.relative[channel][band] =
            this.normalizeValue(normalized.relative[channel][band], 2);
        });
      });
    }

    // Normalize special values (alpha peak, etc.)
    if (normalized.special) {
      Object.keys(normalized.special).forEach(key => {
        normalized.special[key] = this.normalizeValue(normalized.special[key], 2);
      });
    }

    // Normalize zscores if present (for z-score reports)
    if (normalized.zscores) {
      if (normalized.zscores.absolute) {
        Object.keys(normalized.zscores.absolute).forEach(channel => {
          Object.keys(normalized.zscores.absolute[channel]).forEach(band => {
            normalized.zscores.absolute[channel][band] =
              this.normalizeValue(normalized.zscores.absolute[channel][band], 2);
          });
        });
      }
      if (normalized.zscores.relative) {
        Object.keys(normalized.zscores.relative).forEach(channel => {
          Object.keys(normalized.zscores.relative[channel]).forEach(band => {
            normalized.zscores.relative[channel][band] =
              this.normalizeValue(normalized.zscores.relative[channel][band], 2);
          });
        });
      }
    }

    return normalized;
  }

  /**
   * Parse PDF file using Gemini AI with caching for deterministic results
   * @param {Object} file - Multer file object
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   */
  static async parsePDF(file, condition, reportType = 'raw') {
    // üöÄ PARSER SELECTION: Use Traditional, OpenAI, or Gemini based on configuration

    // TRADITIONAL PARSER (Default - No AI, Fast, Deterministic)
    if (AI_SERVICE === 'traditional') {
      console.log(`  üöÄ Using TRADITIONAL PARSER (No AI) for PDF parsing (${condition}, ${reportType.toUpperCase()} mode)`);
      return await TraditionalQeegParser.parsePDF(file, condition, reportType);
    }

    // OPENAI PARSER (Fallback option 1) - Load dynamically if requested
    if (AI_SERVICE === 'openai') {
      console.log(`  üîÄ Loading OpenAI Parser (on-demand)...`);
      if (!OpenAIParser) {
        OpenAIParser = require('./openAIParser');
      }
      console.log(`  üîÄ Using OpenAI GPT-4 for PDF parsing`);
      return await OpenAIParser.parsePDF(file, condition, reportType);
    }

    // GEMINI PARSER (Fallback option 2) - Load dynamically if requested
    if (AI_SERVICE === 'gemini') {
      console.log(`  üîÄ Loading Gemini AI (on-demand)...`);
      if (!genAI) {
        const { GoogleGenerativeAI } = require('@google/generative-ai');
        genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
      }
      if (!rateLimiter) {
        rateLimiter = require('./geminiRateLimiter');
      }
    }

    // GEMINI PARSER (original code follows)
    console.log(`  üîç Parsing PDF with Gemini AI (${condition}, ${reportType.toUpperCase()} mode)...`);

    try {
      // Validate API key before attempting to use it
      this.validateAPIKey();

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);

      // Calculate PDF hash for caching (ensures same PDF = same result)
      const pdfHash = this.calculatePDFHash(dataBuffer);
      const cacheKey = `${pdfHash}_${condition}_${reportType}`;

      console.log(`  üîë PDF Hash: ${pdfHash.substring(0, 12)}... (for deterministic caching)`);

      // Check cache first
      if (extractionCache.has(cacheKey)) {
        cacheStats.hits++;
        cacheStats.totalExtractions++;
        console.log(`  ‚úÖ CACHE HIT! Using cached extraction result (100% deterministic)`);
        console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses, ${((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1)}% hit rate`);
        return extractionCache.get(cacheKey);
      }

      cacheStats.misses++;
      cacheStats.totalExtractions++;
      console.log(`  ‚ö†Ô∏è  Cache miss - extracting data with Gemini AI...`);
      console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses`);

      // Parse PDF with options to extract maximum text
      const pdfData = await pdfParse(dataBuffer, {
        max: 0, // no limit on pages
        version: 'v2.0.550' // use latest PDF.js version
      });

      // Extract text from PDF
      let pdfText = pdfData.text;

      // ‚úÖ IMPROVED: Try multiple extraction methods if initial extraction is small
      if (!pdfText || pdfText.length < 5000) {
        console.log(`  ‚ö†Ô∏è  PDF text too small (${pdfText?.length || 0} chars), trying enhanced extraction methods...`);

        // METHOD 1: Try with page rendering function for better text extraction
        try {
          const altPdfData1 = await pdfParse(dataBuffer, {
            max: 0,
            pagerender: function(pageData) {
              return pageData.getTextContent().then(function(textContent) {
                let text = '';
                textContent.items.forEach(function(item) {
                  text += item.str + ' ';
                  if (item.hasEOL) {
                    text += '\n';
                  }
                });
                return text;
              });
            }
          });

          if (altPdfData1.text && altPdfData1.text.length > pdfText.length) {
            pdfText = altPdfData1.text;
            console.log(`  ‚úÖ Method 1 (pagerender) successful: ${pdfText.length} characters`);
          }
        } catch (method1Error) {
          console.warn(`  ‚ö†Ô∏è  Method 1 failed: ${method1Error.message}`);
        }

        // METHOD 2: Try normalizing whitespace and combining items differently
        if (pdfText.length < 3000) {
          try {
            const altPdfData2 = await pdfParse(dataBuffer, {
              max: 0,
              normalizeWhitespace: true
            });

            if (altPdfData2.text && altPdfData2.text.length > pdfText.length) {
              pdfText = altPdfData2.text;
              console.log(`  ‚úÖ Method 2 (normalizeWhitespace) successful: ${pdfText.length} characters`);
            }
          } catch (method2Error) {
            console.warn(`  ‚ö†Ô∏è  Method 2 failed: ${method2Error.message}`);
          }
        }

        // METHOD 3: Last resort - try without any options
        if (pdfText.length < 2000) {
          try {
            const altPdfData3 = await pdfParse(dataBuffer);

            if (altPdfData3.text && altPdfData3.text.length > pdfText.length) {
              pdfText = altPdfData3.text;
              console.log(`  ‚úÖ Method 3 (default parser) successful: ${pdfText.length} characters`);
            }
          } catch (method3Error) {
            console.warn(`  ‚ö†Ô∏è  Method 3 failed: ${method3Error.message}`);
          }
        }

        if (pdfText.length < 1500) {
          console.error(`  ‚ùå All extraction methods failed to get sufficient text`);
          console.error(`     Final text length: ${pdfText.length} characters`);
          console.error(`     This PDF may be scanned/image-based or have an unusual format`);
        }
      }

      console.log(`  üìÑ Final PDF text length: ${pdfText.length} characters`);

      // Search for key terms in full PDF
      const hasAbsolutePower = pdfText.toLowerCase().includes('absolute power') || pdfText.toLowerCase().includes('absolute spectral');
      const hasRelativePower = pdfText.toLowerCase().includes('relative power') || pdfText.toLowerCase().includes('relative spectral');
      const hasAlphaPeak = pdfText.toLowerCase().includes('alpha peak') || pdfText.toLowerCase().includes('peak alpha');

      console.log(`  üîç PDF Content Check:`);
      console.log(`     - Has "Absolute Power": ${hasAbsolutePower}`);
      console.log(`     - Has "Relative Power": ${hasRelativePower}`);
      console.log(`     - Has "Alpha Peak": ${hasAlphaPeak}`);

      // ‚úÖ IMPROVED VALIDATION: Allow smaller PDFs and accept if EITHER power table is found
      // Changed from strict (3000 chars + BOTH tables) to flexible (1500 chars + AT LEAST ONE table)
      if (pdfText.length < 1500) {
        throw new Error(
          `PDF text extraction too small. Extracted only ${pdfText.length} characters (minimum 1500 required).\n` +
          `This usually means:\n` +
          `1. PDF is corrupted or password-protected\n` +
          `2. PDF contains scanned images instead of text (needs OCR)\n` +
          `3. PDF format is incompatible with parser\n\n` +
          `Please ensure the PDF is a valid QEEG report with extractable text.`
        );
      }

      if (!hasAbsolutePower && !hasRelativePower) {
        throw new Error(
          `PDF does not contain QEEG power tables. Extracted ${pdfText.length} characters but found:\n` +
          `- "Absolute Power" keyword: ${hasAbsolutePower ? 'YES' : 'NO'}\n` +
          `- "Relative Power" keyword: ${hasRelativePower ? 'YES' : 'NO'}\n\n` +
          `Please verify this is a valid QEEG report PDF with frequency band data.`
        );
      }

      // Log warning if only one table type is found (but allow processing to continue)
      if (!hasAbsolutePower || !hasRelativePower) {
        console.warn(`  ‚ö†Ô∏è  WARNING: PDF has incomplete table set:`);
        console.warn(`     - Absolute Power: ${hasAbsolutePower ? '‚úÖ Found' : '‚ùå Missing'}`);
        console.warn(`     - Relative Power: ${hasRelativePower ? '‚úÖ Found' : '‚ùå Missing'}`);
        console.warn(`     Continuing with available data - results may be less accurate`);
      }

      // Try to extract relevant sections (pages 13 & 24)
      const relevantText = this.extractRelevantPages(pdfText);
      console.log(`  üìä Extracted relevant sections length: ${relevantText.length} characters`);

      // Check if extracted text has required keywords
      const extractedHasData = relevantText.toLowerCase().includes('absolute') &&
                               relevantText.toLowerCase().includes('relative');

      // Use full PDF if extraction failed to find tables
      const textToUse = extractedHasData ? relevantText : pdfText;

      console.log(`  üìù Using ${textToUse === pdfText ? 'FULL PDF' : 'EXTRACTED SECTIONS'} (${textToUse.length} chars)`);
      console.log(`  üìù Reason: ${extractedHasData ? 'Found power tables in extracted text' : 'Tables not found in extraction, using full PDF'}`);
      console.log(`  üìù First 2000 chars of text being sent to Gemini:\n${textToUse.substring(0, 2000)}\n...`);

      // Get appropriate extraction prompt based on report type
      const prompt = this.getExtractionPrompt(condition, reportType, textToUse);

      // Initialize Gemini model if not already done
      if (!geminiModel) {
        console.log('  üîß Initializing Gemini model for data extraction...');
        console.log('  üîë API Key status:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');
        console.log('  üîë API Key length:', process.env.GEMINI_API_KEY?.length || 0);
        console.log('  üîë API Key preview:', process.env.GEMINI_API_KEY ? `${process.env.GEMINI_API_KEY.substring(0, 20)}...` : 'N/A');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          console.error('\n  ‚ùå === NO MODELS AVAILABLE ===');
          console.error('  Please check:');
          console.error('  1. GEMINI_API_KEY is correct in .env file');
          console.error('  2. API key has proper permissions');
          console.error('  3. Visit: https://aistudio.google.com/apikey to get a new key');
          console.error('  4. Make sure Generative Language API is enabled');
          console.error('  ================================\n');
          throw new Error('No Gemini models available. Check your API key.');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model from available models');
        }

        // Initialize model with full path and deterministic config
        console.log(`  üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({
          model: modelName,
          generationConfig: {
            temperature: 0,      // Minimum randomness for deterministic extraction
            topK: 1,            // Only pick most likely token
            topP: 1,             // No nucleus sampling
            maxOutputTokens: 8192  // Increased token limit for comprehensive extraction
          }
        });

        // Test the model with a simple call
        console.log(`  üìû Testing ${modelName} with simple call...`);
        try {
          const testResult = await geminiModel.generateContent('Hello');
          const testResponse = await testResult.response;
          const testText = testResponse.text();

          console.log(`  ‚úÖ Model initialized and tested successfully`);
          console.log(`  üìù Test response: ${testText.substring(0, 50)}...`);
        } catch (testError) {
          console.error(`  ‚ùå Model test failed:`, testError.message);
          throw new Error(`Failed to test model ${modelName}: ${testError.message}`);
        }
      }

      console.log(`  ü§ñ Using Gemini AI for data extraction (${condition})...`);

      // üõ°Ô∏è RATE LIMITING: Wait before making API call to respect quotas
      await rateLimiter.waitForRateLimit();

      // Call Gemini API with retry logic for quota/rate limit errors
      let result;
      let retryCount = 0;
      const maxRetries = 3;

      while (retryCount <= maxRetries) {
        try {
          result = await geminiModel.generateContent(prompt);

          // ‚úÖ Record successful API call for quota tracking
          rateLimiter.recordRequest();

          break; // Success, exit retry loop
        } catch (apiError) {
          // Check if it's a quota/rate limit error
          if (apiError.message && (apiError.message.includes('quota') || apiError.message.includes('429'))) {
            const retryDelay = Math.pow(2, retryCount) * 5000; // Exponential backoff: 5s, 10s, 20s

            console.warn(`  ‚ö†Ô∏è  Gemini API quota/rate limit hit (attempt ${retryCount + 1}/${maxRetries + 1})`);

            if (retryCount < maxRetries) {
              console.log(`  ‚è≥ Waiting ${retryDelay / 1000} seconds before retry...`);
              await new Promise(resolve => setTimeout(resolve, retryDelay));
              retryCount++;
              continue;
            } else {
              // Max retries reached, throw enhanced error
              const enhancedError = new Error(
                'Gemini API quota exceeded. Your free tier allows 20 requests per day. ' +
                'Please wait a few hours for quota to reset, or upgrade to a paid plan at https://ai.google.dev/pricing'
              );
              enhancedError.code = 'GEMINI_QUOTA_EXCEEDED';
              enhancedError.originalError = apiError;
              throw enhancedError;
            }
          } else {
            // Not a quota error, throw immediately
            throw apiError;
          }
        }
      }

      const response = await result.response;
      const text = response.text();

      console.log(`  üìù Gemini response received (${condition}), length: ${text.length} characters`);

      // Parse JSON from response (remove markdown code blocks if present)
      let extractedData;
      try {
        const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const rawData = JSON.parse(jsonText);

        // üîß NORMALIZE all values to consistent decimal places
        // This ensures minor extraction variations don't affect calculations
        extractedData = this.normalizeExtractedData(rawData);

        console.log(`  ‚úÖ PDF data extracted and normalized successfully (${condition})`);

        // === ENHANCED DEBUG: Show COMPLETE extracted data ===
        console.log(`\n  üêõ === DEBUG: COMPLETE EXTRACTED DATA (${condition}) ===`);
        console.log(`  üìä ABSOLUTE POWER (ŒºV¬≤):`);
        if (extractedData.absolute) {
          Object.keys(extractedData.absolute).forEach(channel => {
            const bands = extractedData.absolute[channel];
            console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
          });
        }

        console.log(`\n  üìä RELATIVE POWER (%):`);
        if (extractedData.relative) {
          Object.keys(extractedData.relative).forEach(channel => {
            const bands = extractedData.relative[channel];
            const sum = (bands.Delta || 0) + (bands.Theta || 0) + (bands.Alpha || 0) + (bands.Beta || 0) + (bands.HiBeta || 0);
            console.log(`     ${channel}: Delta=${bands.Delta}%, Theta=${bands.Theta}%, Alpha=${bands.Alpha}%, Beta=${bands.Beta}%, HiBeta=${bands.HiBeta}% [Sum=${sum.toFixed(1)}%]`);
          });
        }

        console.log(`\n  üìä SPECIAL VALUES:`);
        if (extractedData.special) {
          console.log(`     Alpha Peak: ${extractedData.special.alphaPeak} Hz`);
          if (extractedData.special.O1) console.log(`     O1: ${extractedData.special.O1} Hz`);
        }

        // If Z-score data exists
        if (extractedData.zscores) {
          console.log(`\n  üìä Z-SCORE DATA (ABSOLUTE):`);
          if (extractedData.zscores.absolute) {
            Object.keys(extractedData.zscores.absolute).forEach(channel => {
              const bands = extractedData.zscores.absolute[channel];
              console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
            });
          }

          console.log(`\n  üìä Z-SCORE DATA (RELATIVE):`);
          if (extractedData.zscores.relative) {
            Object.keys(extractedData.zscores.relative).forEach(channel => {
              const bands = extractedData.zscores.relative[channel];
              console.log(`     ${channel}: Delta=${bands.Delta}, Theta=${bands.Theta}, Alpha=${bands.Alpha}, Beta=${bands.Beta}, HiBeta=${bands.HiBeta}`);
            });
          }
        }
        console.log(`  === END DEBUG: EXTRACTED DATA ===\n`);

      } catch (parseError) {
        console.error(`  ‚ùå Failed to parse JSON from Gemini response (${condition}):`, parseError.message);
        console.error(`  üìÑ Raw response:`, text.substring(0, 500));
        throw new Error(`Failed to parse JSON from Gemini response: ${parseError.message}`);
      }

      // Add detailed logging
      console.log(`  üìä Data extraction summary (${condition}):`);
      console.log(`     - Absolute power channels: ${Object.keys(extractedData.absolute || {}).length}`);
      console.log(`     - Relative power channels: ${Object.keys(extractedData.relative || {}).length}`);
      console.log(`     - Special values: ${JSON.stringify(extractedData.special || {})}`);

      // Log sample extracted values for verification (prove it's real patient data, not static)
      console.log(`\n  üìã Sample Extracted Values (${condition}) - Proof of Dynamic Extraction:`);
      if (extractedData.absolute?.Fz) {
        console.log(`     - Fz Absolute: Theta=${extractedData.absolute.Fz.Theta}, Beta=${extractedData.absolute.Fz.Beta}`);
      }
      if (extractedData.absolute?.Pz) {
        console.log(`     - Pz Absolute: Alpha=${extractedData.absolute.Pz.Alpha}, HiBeta=${extractedData.absolute.Pz.HiBeta}`);
      }
      if (extractedData.relative?.Pz) {
        console.log(`     - Pz Relative: Alpha=${extractedData.relative.Pz.Alpha}, Beta=${extractedData.relative.Pz.Beta}`);
      }
      if (extractedData.absolute?.F3 && extractedData.absolute?.F4) {
        console.log(`     - F3/F4 Absolute Alpha: F3=${extractedData.absolute.F3.Alpha}, F4=${extractedData.absolute.F4.Alpha}`);
      }
      if (extractedData.special?.alphaPeak) {
        console.log(`     - Alpha Peak Frequency: ${extractedData.special.alphaPeak} Hz`);
      }

      // Validate extracted data has minimum required fields
      const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
      const absoluteChannels = Object.keys(extractedData.absolute || {});
      const relativeChannels = Object.keys(extractedData.relative || {});

      const missingAbsolute = requiredChannels.filter(ch => !absoluteChannels.includes(ch));
      const missingRelative = requiredChannels.filter(ch => !relativeChannels.includes(ch));

      if (missingAbsolute.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing absolute power channels: ${missingAbsolute.join(', ')}`);
      }
      if (missingRelative.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing relative power channels: ${missingRelative.join(', ')}`);
      }

      // üîç VALIDATE: Check if relative power sums to ~100% for each channel
      console.log(`\n  üîç Validating relative power values (${condition})...`);
      let incompleteChannels = [];

      for (const channel of requiredChannels) {
        if (extractedData.relative?.[channel]) {
          const bands = extractedData.relative[channel];
          const sum = (bands.Delta || 0) + (bands.Theta || 0) + (bands.Alpha || 0) +
                     (bands.Beta || 0) + (bands.HiBeta || 0);

          // Check if sum is close to 100% (allow ¬±5% tolerance)
          if (sum < 95 || sum > 105) {
            incompleteChannels.push({
              channel,
              sum: sum.toFixed(1),
              bands: {
                Delta: bands.Delta || 0,
                Theta: bands.Theta || 0,
                Alpha: bands.Alpha || 0,
                Beta: bands.Beta || 0,
                HiBeta: bands.HiBeta || 0
              }
            });
          }
        }
      }

      if (incompleteChannels.length > 0) {
        console.error(`\n  ‚ùå ==================== DATA EXTRACTION INCOMPLETE ====================`);
        console.error(`  ‚ùå CRITICAL: ${incompleteChannels.length} channels have incorrect relative power sums!`);
        console.error(`  ‚ùå Relative power MUST sum to ~100% for each channel.`);
        console.error(`  ‚ùå Incomplete extraction will cause INCORRECT ALGORITHM RESULTS!\n`);

        incompleteChannels.forEach(({ channel, sum, bands }) => {
          console.error(`     Channel ${channel}: Sum = ${sum}% (Expected: ~100%)`);
          console.error(`       Delta: ${bands.Delta}% | Theta: ${bands.Theta}% | Alpha: ${bands.Alpha}%`);
          console.error(`       Beta: ${bands.Beta}% | HiBeta: ${bands.HiBeta}%`);

          // Identify which bands are likely missing (have 0 or very low values)
          const missingBands = [];
          Object.entries(bands).forEach(([band, value]) => {
            if (value === 0 || value < 0.1) {
              missingBands.push(band);
            }
          });

          if (missingBands.length > 0) {
            console.error(`       ‚ö†Ô∏è  Likely missing bands: ${missingBands.join(', ')}`);
          }
          console.error('');
        });

        console.error(`  ‚ùå RECOMMENDATION: Check if the PDF contains all frequency band values.`);
        console.error(`  ‚ùå Gemini may need to look in different table sections or pages.`);
        console.error(`  ‚ùå ====================================================================\n`);
      } else {
        console.log(`  ‚úÖ Relative power validation passed: All channels sum to ~100%`);
      }

      // ‚ö†Ô∏è COMPREHENSIVE DATA VALIDATION - Check but allow warnings
      const validation = this.validateExtractedData(extractedData, condition);

      if (!validation.isValid) {
        // Check if data is completely empty (all relative power = 0)
        const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
        const requiredBands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];

        const hasAnyRelativeData = requiredChannels.some(channel => {
          if (!extractedData.relative?.[channel]) return false;
          const sum = requiredBands.reduce((acc, band) => {
            return acc + (extractedData.relative[channel][band] || 0);
          }, 0);
          return sum > 0;
        });

        const hasAnyAbsoluteData = requiredChannels.some(channel => {
          if (!extractedData.absolute?.[channel]) return false;
          const sum = requiredBands.reduce((acc, band) => {
            return acc + (extractedData.absolute[channel][band] || 0);
          }, 0);
          return sum > 0;
        });

        if (!hasAnyRelativeData && !hasAnyAbsoluteData) {
          // Completely failed extraction - throw error
          console.error(`\n  ‚ùå ==================== DATA EXTRACTION COMPLETELY FAILED ====================`);
          console.error(`  ‚ùå CRITICAL: No data was extracted from PDF!`);
          console.error(`  ‚ùå Missing/Invalid fields: ${validation.missingFields.length}`);
          console.error(`  ‚ùå ${validation.error}`);
          console.error(`  ‚ùå ALGORITHM CALCULATION CANNOT PROCEED!`);
          console.error(`  ‚ùå ========================================================================\n`);

          const extractionError = new Error(
            `COMPLETE DATA EXTRACTION FAILURE: ${validation.error}\n` +
            `Missing fields: ${validation.missingFields.join(', ')}\n` +
            `PDF data from pages 13 & 24 was not extracted.\n` +
            `Please ensure the PDF contains valid QEEG tables and try again.`
          );
          extractionError.code = 'COMPLETE_DATA_EXTRACTION_FAILURE';
          extractionError.validation = validation;
          extractionError.condition = condition;
          throw extractionError;
        } else {
          // Partial data extracted - show warnings but continue
          console.warn(`\n  ‚ö†Ô∏è  ==================== PARTIAL DATA EXTRACTION ====================`);
          console.warn(`  ‚ö†Ô∏è  WARNING: Data extraction is incomplete but has some data!`);
          console.warn(`  ‚ö†Ô∏è  Missing/Invalid fields: ${validation.missingFields.length}`);
          console.warn(`  ‚ö†Ô∏è  ${validation.error}`);
          console.warn(`  ‚ö†Ô∏è  Algorithm will proceed with available data.`);
          console.warn(`  ‚ö†Ô∏è  Results may be less accurate.`);
          console.warn(`  ‚ö†Ô∏è  ================================================================\n`);
        }
      } else {
        console.log(`  üéâ Data validation PASSED! All required fields present.`);
      }

      // ‚úÖ CACHE the extraction result for deterministic behavior
      // Same PDF will now ALWAYS return the same values
      extractionCache.set(cacheKey, extractedData);
      console.log(`  üíæ Extraction result cached (key: ${pdfHash.substring(0, 12)}...)`);
      console.log(`  üìä Cache size: ${extractionCache.size} entries`);

      return extractedData;

    } catch (error) {
      console.error(`  ‚ùå Gemini API error (${condition}):`, error.message);

      // Log more details for debugging
      if (error.response) {
        console.error(`  ‚ùå Gemini API Status:`, error.response?.status);
        console.error(`  ‚ùå Gemini API Error:`, error.response?.data);
      }

      console.error(`  üìÑ Error stack:`, error.stack);

      // Re-throw with more context
      const enhancedError = new Error(`Failed to extract QEEG data from PDF using Gemini (${condition}): ${error.message}`);
      enhancedError.code = 'PDF_EXTRACTION_FAILED';
      enhancedError.originalError = error;
      enhancedError.condition = condition;
      throw enhancedError;
    }
  }

  /**
   * Parse CSV file
   */
  static parseCSV(file) {
    console.log('  üìä Parsing CSV file...');

    // Read CSV file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert CSV data to our format
    const data = this.convertCSVToFormat(jsonData);

    console.log('  ‚úÖ CSV parsed successfully');
    return data;
  }

  /**
   * Parse Excel file
   */
  static parseExcel(file) {
    console.log('  üìä Parsing Excel file...');

    // Read Excel file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert Excel data to our format
    const data = this.convertExcelToFormat(jsonData);

    console.log('  ‚úÖ Excel parsed successfully');
    return data;
  }

  /**
   * Convert CSV data to expected format
   */
  static convertCSVToFormat(csvData) {
    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta
    const result = {
      absolute: {},
      relative: {},
      special: { alphaPeak: 10.0, O1: 10.0 }
    };

    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];

    for (const row of csvData) {
      const channel = row.Channel;
      const powerType = row.PowerType?.toLowerCase();

      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {
        result[powerType][channel] = {
          Delta: parseFloat(row.Delta) || 0,
          Theta: parseFloat(row.Theta) || 0,
          Alpha: parseFloat(row.Alpha) || 0,
          Beta: parseFloat(row.Beta) || 0,
          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0
        };
      }
    }

    return result;
  }

  /**
   * Convert Excel data to expected format (same as CSV for now)
   */
  static convertExcelToFormat(excelData) {
    return this.convertCSVToFormat(excelData);
  }

  /**
   * Get cache statistics
   * @returns {Object} Cache statistics
   */
  static getCacheStats() {
    return {
      ...cacheStats,
      cacheSize: extractionCache.size,
      hitRate: cacheStats.totalExtractions > 0
        ? ((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1) + '%'
        : '0%'
    };
  }

  /**
   * Clear extraction cache (useful for testing or memory management)
   * @param {string} pdfHash - Optional: Clear specific PDF hash, or all if not provided
   */
  static clearCache(pdfHash = null) {
    if (pdfHash) {
      // Clear specific PDF
      let cleared = 0;
      for (const key of extractionCache.keys()) {
        if (key.startsWith(pdfHash)) {
          extractionCache.delete(key);
          cleared++;
        }
      }
      console.log(`üóëÔ∏è  Cleared ${cleared} cache entries for PDF hash: ${pdfHash.substring(0, 12)}...`);
    } else {
      // Clear all
      const size = extractionCache.size;
      extractionCache.clear();
      cacheStats.hits = 0;
      cacheStats.misses = 0;
      cacheStats.totalExtractions = 0;
      console.log(`üóëÔ∏è  Cleared entire extraction cache (${size} entries)`);
    }
  }

  /**
   * Get Gemini API quota status
   * @returns {Object} Current quota usage and limits
   */
  static getQuotaStatus() {
    return rateLimiter.getQuotaStatus();
  }
}

module.exports = QEEGParser;
