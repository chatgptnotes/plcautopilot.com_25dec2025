const fs = require('fs');
const crypto = require('crypto');
const pdfParse = require('pdf-parse');
const OpenAI = require('openai');

console.log('üîß Loading OpenAI Parser...');
console.log(`   OpenAI API Key: ${process.env.OPENAI_API_KEY ? 'Present (length: ' + process.env.OPENAI_API_KEY.length + ')' : 'MISSING!'}`);

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

console.log('‚úÖ OpenAI Parser loaded successfully\n');

// In-memory cache (same as Gemini parser)
const extractionCache = new Map();

// Cache statistics
const cacheStats = {
  hits: 0,
  misses: 0,
  totalExtractions: 0
};

class OpenAIParser {
  /**
   * Validate OpenAI API key
   */
  static validateAPIKey() {
    const apiKey = process.env.OPENAI_API_KEY;

    if (!apiKey || apiKey.trim() === '') {
      const error = new Error('OPENAI_API_KEY environment variable is not set');
      error.code = 'MISSING_API_KEY';
      throw error;
    }

    console.log('‚úÖ OpenAI API key validation passed');
    return true;
  }

  /**
   * Get extraction prompt for OpenAI (same logic as Gemini)
   */
  static getExtractionPrompt(condition, reportType, pdfText) {
    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';

    if (reportType === 'zscore') {
      // Z-SCORE extraction prompt
      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.

**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.
- Negative values = below average (lower than normal)
- Zero (0) = average (normal)
- Positive values = above average (higher than normal)

Look for tables labeled with "Z-score", "Z score", "Z", or "Standard Deviation" in the headers.

Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract Z-scores for these frequency bands:
- Delta (1-4 Hz)
- Theta (4-8 Hz)
- Alpha (8-13 Hz)
- Beta (13-30 Hz)
- HiBeta / High Beta (20-30 Hz)

Also extract:
- Alpha Peak Frequency (Hz) and its Z-score if available

If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return ONLY this EXACT JSON format:
{
  "zscores": {
    "absolute": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    },
    "relative": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

PDF Content (ONLY PAGES 13 & 24):
${pdfText}`;

    } else {
      // RAW POWER extraction prompt
      return `You are an expert QEEG data extraction specialist. Your task is to extract COMPLETE frequency band data from this ${conditionName} QEEG report PDF.

üéØ YOUR MISSION: Extract 100% COMPLETE DATA - No Missing Bands Allowed!

üìä WHAT TO EXTRACT:
You must extract THREE pieces of data from this PDF:
1. **Z-scored Alpha Peak** (Hz) - From page 13
2. **Absolute Power (ŒºV¬≤)** - Brain wave power in microvolts squared - From page 24
3. **Relative Power (%)** - Percentage distribution (MUST sum to ~100% per channel) - From page 24

üìç WHERE TO LOOK IN THE PDF:
- ‚ö†Ô∏è IMPORTANT: This content contains EXTRACTED SECTIONS from the PDF (not full pages)!
- The text below contains only the relevant table sections found using keyword matching

  **SECTION 1** - Z-scored Alpha Peak (typically from page 13):
  - Look for "Z-scored Alpha Peak" / "Alpha Peak Frequency" / "Peak Alpha"
  - This is typically a table showing alpha peak frequency (Hz) with z-scores
  - Extract the alpha peak frequency value (usually 8-13 Hz range)

  **SECTION 2** - Power Tables (typically from page 24):
  - Look for TWO tables:
    * "Absolute Power" / "Absolute Spectral Power" / "Absolute" / "ABS" (ŒºV¬≤)
    * "Relative Power" / "Relative Spectral Power" / "Relative" / "REL" (%)
  - Both Absolute AND Relative tables should be in this section
  - Look for headers like "Monopolar" / "Linked Ears" / "Average Reference"

- Each section contains text surrounding the table keywords (¬±3000-8000 characters)

üß† CHANNELS TO EXTRACT (19 channels):
FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

üìä FREQUENCY BANDS (ALL 5 REQUIRED):
For EACH channel, you MUST extract ALL 5 bands:
1. **Delta** (Œ¥) - 0.5-4 Hz
2. **Theta** (Œ∏) - 4-8 Hz
3. **Alpha** (Œ±) - 8-13 Hz
4. **Beta** (Œ≤) - 13-30 Hz
5. **HiBeta** (High Beta / Œ≤Œ≤) - 30-50 Hz

‚ö†Ô∏è CRITICAL REQUIREMENTS:
1. Extract ALL 5 bands for EVERY channel
2. For Relative Power, EACH channel must sum to ~100%
3. Preserve exact decimal values from the PDF
4. Do not skip any channels or bands
5. Extract Alpha Peak frequency from page 13 (look for z-scored value)
6. Extract BOTH Absolute and Relative power tables from page 24

**OUTPUT FORMAT**:
Return ONLY pure JSON (no markdown, no code blocks, no explanations):

{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

NOTES:
- alphaPeak: Extract from Z-scored Alpha Peak table section (typically page 13)
- alphaPeakZscore: If z-score value is available, extract it; otherwise use 0.0
- Absolute & Relative power: Extract from Power tables section (typically page 24)
- This text contains EXTRACTED SECTIONS found using keyword matching
- Sections include context around table keywords (Alpha Peak, Absolute Power, Relative Power)

PDF Content (EXTRACTED TABLE SECTIONS):
${pdfText}`;
    }
  }

  /**
   * Calculate MD5 hash for caching
   */
  static calculatePDFHash(dataBuffer) {
    return crypto.createHash('md5').update(dataBuffer).digest('hex');
  }

  /**
   * Normalize extracted values
   */
  static normalizeValue(value, decimalPlaces = 2) {
    if (value === null || value === undefined || isNaN(value)) {
      return null;
    }
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(value * multiplier) / multiplier;
  }

  /**
   * Normalize all values in extracted data
   */
  static normalizeExtractedData(extractedData) {
    const normalized = JSON.parse(JSON.stringify(extractedData));

    if (normalized.absolute) {
      Object.keys(normalized.absolute).forEach(channel => {
        Object.keys(normalized.absolute[channel]).forEach(band => {
          normalized.absolute[channel][band] =
            this.normalizeValue(normalized.absolute[channel][band], 2);
        });
      });
    }

    if (normalized.relative) {
      Object.keys(normalized.relative).forEach(channel => {
        Object.keys(normalized.relative[channel]).forEach(band => {
          normalized.relative[channel][band] =
            this.normalizeValue(normalized.relative[channel][band], 2);
        });
      });
    }

    if (normalized.special) {
      Object.keys(normalized.special).forEach(key => {
        normalized.special[key] = this.normalizeValue(normalized.special[key], 2);
      });
    }

    if (normalized.zscores) {
      if (normalized.zscores.absolute) {
        Object.keys(normalized.zscores.absolute).forEach(channel => {
          Object.keys(normalized.zscores.absolute[channel]).forEach(band => {
            normalized.zscores.absolute[channel][band] =
              this.normalizeValue(normalized.zscores.absolute[channel][band], 2);
          });
        });
      }
      if (normalized.zscores.relative) {
        Object.keys(normalized.zscores.relative).forEach(channel => {
          Object.keys(normalized.zscores.relative[channel]).forEach(band => {
            normalized.zscores.relative[channel][band] =
              this.normalizeValue(normalized.zscores.relative[channel][band], 2);
          });
        });
      }
    }

    return normalized;
  }

  /**
   * Extract table sections from PDF using keyword-based detection
   * This method searches for actual table headers instead of relying on page numbers
   * @param {Buffer} dataBuffer - PDF file buffer
   * @returns {Promise<string>} - Combined text containing relevant table sections
   */
  static async extractTableSections(dataBuffer) {
    try {
      console.log(`  üìÑ Extracting table sections using keyword detection...`);

      const pdfData = await pdfParse(dataBuffer);
      const fullText = pdfData.text;
      const totalPages = pdfData.numpages;

      console.log(`  üìö PDF has ${totalPages} total pages, ${fullText.length} total characters`);

      const extractedSections = [];

      // === SECTION 1: Z-scored Alpha Peak (Page 13) ===
      const alphaPeakKeywords = [
        /z-?scored\s+alpha\s+peak/i,
        /alpha\s+peak\s+frequency/i,
        /peak\s+alpha/i,
        /dominant\s+alpha/i
      ];

      console.log(`  üîç Searching for Alpha Peak table...`);
      for (const pattern of alphaPeakKeywords) {
        const match = fullText.match(pattern);
        if (match) {
          const matchIndex = match.index;
          // Extract 3000 characters before and 3000 after the match
          const start = Math.max(0, matchIndex - 3000);
          const end = Math.min(fullText.length, matchIndex + 3000);
          const section = fullText.substring(start, end);

          extractedSections.push(`\n=== ALPHA PEAK SECTION (found at position ${matchIndex}) ===\n${section}\n`);
          console.log(`  ‚úÖ Found Alpha Peak table at position ${matchIndex}`);
          break; // Found it, no need to continue
        }
      }

      if (extractedSections.length === 0) {
        console.warn(`  ‚ö†Ô∏è  Alpha Peak table not found with keywords`);
      }

      // === SECTION 2: Absolute & Relative Power Tables (Page 24) ===
      const powerTableKeywords = [
        /absolute\s+power/i,
        /absolute\s+spectral\s+power/i,
        /ŒºV¬≤/i,
        /microvolt/i
      ];

      console.log(`  üîç Searching for Absolute/Relative Power tables...`);
      for (const pattern of powerTableKeywords) {
        const match = fullText.match(pattern);
        if (match) {
          const matchIndex = match.index;
          // Extract larger section (5000 chars) to capture both Absolute AND Relative tables
          const start = Math.max(0, matchIndex - 2000);
          const end = Math.min(fullText.length, matchIndex + 8000); // Larger window for both tables
          const section = fullText.substring(start, end);

          extractedSections.push(`\n=== POWER TABLES SECTION (found at position ${matchIndex}) ===\n${section}\n`);
          console.log(`  ‚úÖ Found Power tables at position ${matchIndex}`);
          break;
        }
      }

      if (extractedSections.length < 2) {
        console.warn(`  ‚ö†Ô∏è  Power tables not found with keywords`);
      }

      // If we found any sections, return them
      if (extractedSections.length > 0) {
        const combinedText = extractedSections.join('\n\n');
        console.log(`  ‚úÖ Extracted ${extractedSections.length} table sections, total ${combinedText.length} characters`);
        return combinedText;
      } else {
        // Fallback: return full PDF text if no tables found
        console.warn(`  ‚ö†Ô∏è  No tables found with keywords, sending full PDF text (${fullText.length} chars)`);
        return fullText;
      }

    } catch (error) {
      console.error(`  ‚ùå Error extracting table sections:`, error.message);
      // Fallback: return full PDF text
      const fallbackData = await pdfParse(dataBuffer);
      return fallbackData.text;
    }
  }

  /**
   * Parse PDF using OpenAI GPT-4
   */
  static async parsePDF(file, condition, reportType = 'raw') {
    console.log(`  üîç Parsing PDF with OpenAI GPT-4 (${condition}, ${reportType.toUpperCase()} mode)...`);

    try {
      // Validate API key
      this.validateAPIKey();

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);

      // Calculate hash for caching
      const pdfHash = this.calculatePDFHash(dataBuffer);
      const cacheKey = `openai_${pdfHash}_${condition}_${reportType}`;

      console.log(`  üîë PDF Hash: ${pdfHash.substring(0, 12)}... (for caching)`);

      // Check cache first
      if (extractionCache.has(cacheKey)) {
        cacheStats.hits++;
        cacheStats.totalExtractions++;
        console.log(`  ‚úÖ CACHE HIT! Using cached extraction result`);
        console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses`);
        return extractionCache.get(cacheKey);
      }

      cacheStats.misses++;
      cacheStats.totalExtractions++;
      console.log(`  ‚ö†Ô∏è  Cache miss - extracting with OpenAI...`);

      // Extract table sections using keyword-based detection
      console.log(`  üéØ Searching for Alpha Peak table and Power tables using keywords...`);
      const pdfText = await this.extractTableSections(dataBuffer);

      // Log extracted text sample
      console.log(`  üìù Extracted PDF text length: ${pdfText.length} characters`);
      if (pdfText.length > 0) {
        console.log(`  üìã Text sample (first 500 chars):`);
        console.log(`  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
        console.log(`  ${pdfText.substring(0, 500).replace(/\n/g, '\n  ')}`);
        console.log(`  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`);
      } else {
        console.warn(`  ‚ö†Ô∏è  WARNING: No text extracted! Sending full PDF to OpenAI...`);
      }

      // Get extraction prompt
      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);

      console.log(`  ü§ñ Calling OpenAI GPT-4...`);

      // Call OpenAI API
      const completion = await openai.chat.completions.create({
        model: "gpt-4o", // Using GPT-4 Turbo for best accuracy
        messages: [
          {
            role: "system",
            content: "You are a medical data extraction expert specializing in QEEG reports. Extract data accurately and return only valid JSON."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0, // Deterministic output
        response_format: { type: "json_object" } // Force JSON response
      });

      const responseText = completion.choices[0].message.content;
      console.log(`  üìù OpenAI response received, length: ${responseText.length} characters`);

      // Parse JSON response
      let extractedData;
      try {
        const jsonText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const rawData = JSON.parse(jsonText);

        // Normalize values
        extractedData = this.normalizeExtractedData(rawData);

        console.log(`  ‚úÖ PDF data extracted and normalized successfully (${condition})`);

        // Enhanced Debug Output - Show Actual Extracted Values
        console.log(`\n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
        console.log(`  ‚ïë  üìÑ EXTRACTED VALUES FROM PDF (${condition})                    ‚ïë`);
        console.log(`  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);

        if (extractedData.absolute) {
          console.log(`  üìä ABSOLUTE POWER (ŒºV¬≤) - ${Object.keys(extractedData.absolute).length} channels:`);
          console.log(`  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
          console.log(`  ‚îÇ Channel‚îÇ Delta  ‚îÇ Theta  ‚îÇ Alpha  ‚îÇ  Beta  ‚îÇ HiBeta ‚îÇ`);
          console.log(`  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
          ['Fz', 'Cz', 'Pz'].forEach(ch => {
            if (extractedData.absolute[ch]) {
              const d = extractedData.absolute[ch];
              console.log(`  ‚îÇ  ${ch.padEnd(5)} ‚îÇ ${String(d.Delta).padStart(6)} ‚îÇ ${String(d.Theta).padStart(6)} ‚îÇ ${String(d.Alpha).padStart(6)} ‚îÇ ${String(d.Beta).padStart(6)} ‚îÇ ${String(d.HiBeta).padStart(6)} ‚îÇ`);
            }
          });
          console.log(`  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n`);
        }

        if (extractedData.relative) {
          console.log(`  üìä RELATIVE POWER (%) - ${Object.keys(extractedData.relative).length} channels:`);
          console.log(`  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
          console.log(`  ‚îÇ Channel‚îÇ Delta  ‚îÇ Theta  ‚îÇ Alpha  ‚îÇ  Beta  ‚îÇ HiBeta ‚îÇ`);
          console.log(`  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
          ['Fz', 'Cz', 'Pz'].forEach(ch => {
            if (extractedData.relative[ch]) {
              const d = extractedData.relative[ch];
              console.log(`  ‚îÇ  ${ch.padEnd(5)} ‚îÇ ${String(d.Delta).padStart(6)} ‚îÇ ${String(d.Theta).padStart(6)} ‚îÇ ${String(d.Alpha).padStart(6)} ‚îÇ ${String(d.Beta).padStart(6)} ‚îÇ ${String(d.HiBeta).padStart(6)} ‚îÇ`);
            }
          });
          console.log(`  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n`);
        }

        if (extractedData.special && extractedData.special.alphaPeak) {
          console.log(`  ‚≠ê ALPHA PEAK: ${extractedData.special.alphaPeak} Hz`);
          if (extractedData.special.alphaPeakZscore) {
            console.log(`  üìà Alpha Peak Z-score: ${extractedData.special.alphaPeakZscore}`);
          }
        }

        console.log(`\n  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

      } catch (parseError) {
        console.error(`  ‚ùå Failed to parse JSON from OpenAI response:`, parseError.message);
        console.error(`  üìÑ Raw response:`, responseText.substring(0, 500));
        throw new Error(`Failed to parse JSON from OpenAI: ${parseError.message}`);
      }

      // Cache the result
      extractionCache.set(cacheKey, extractedData);
      console.log(`  üíæ Result cached (key: ${pdfHash.substring(0, 12)}...)`);

      return extractedData;

    } catch (error) {
      console.error(`  ‚ùå OpenAI API error (${condition}):`, error.message);

      // Enhanced error for quota issues
      if (error.message && error.message.includes('quota')) {
        const enhancedError = new Error(
          'OpenAI API quota exceeded. Please check your API key and billing at https://platform.openai.com/account/billing'
        );
        enhancedError.code = 'OPENAI_QUOTA_EXCEEDED';
        enhancedError.originalError = error;
        throw enhancedError;
      }

      throw error;
    }
  }

  /**
   * Get cache statistics
   */
  static getCacheStats() {
    return {
      ...cacheStats,
      cacheSize: extractionCache.size,
      hitRate: cacheStats.totalExtractions > 0
        ? ((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1) + '%'
        : '0%'
    };
  }
}

module.exports = OpenAIParser;
