const fs = require('fs');
const path = require('path');
const OpenAI = require('openai');
const pdfParse = require('pdf-parse');
const XLSX = require('xlsx');

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

class QEEGParser {
  /**
   * Main method to parse uploaded files
   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data
   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data
   * @returns {Object} Parsed QEEG data
   */
  static async parse(eyesOpenFile, eyesClosedFile) {
    try {
      console.log('üìÑ Parsing QEEG files...');
      console.log('  - Eyes Open:', eyesOpenFile?.originalname);
      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);

      // Determine file types
      const eoFileType = this.getFileType(eyesOpenFile.originalname);
      const ecFileType = this.getFileType(eyesClosedFile.originalname);

      // Parse each file
      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO');
      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC');

      // Combine data
      const combinedData = {
        EO: eyesOpenData,
        EC: eyesClosedData
      };

      console.log('‚úÖ QEEG files parsed successfully');
      return combinedData;

    } catch (error) {
      console.error('‚ùå Error parsing QEEG files:', error);
      throw new Error(`Failed to parse QEEG files: ${error.message}`);
    }
  }

  /**
   * Determine file type from filename
   */
  static getFileType(filename) {
    const ext = path.extname(filename).toLowerCase();
    if (ext === '.pdf') return 'pdf';
    if (ext === '.csv') return 'csv';
    if (ext === '.xlsx' || ext === '.xls') return 'excel';
    throw new Error(`Unsupported file type: ${ext}`);
  }

  /**
   * Parse a single file based on its type
   */
  static async parseFile(file, fileType, condition) {
    if (fileType === 'pdf') {
      return await this.parsePDF(file, condition);
    } else if (fileType === 'csv') {
      return this.parseCSV(file);
    } else if (fileType === 'excel') {
      return this.parseExcel(file);
    }
    throw new Error(`Unknown file type: ${fileType}`);
  }

  /**
   * Parse PDF file using OpenAI Vision API
   */
  static async parsePDF(file, condition) {
    console.log(`  üîç Parsing PDF with OpenAI Vision API (${condition})...`);

    try {
      // Check if OpenAI API key exists
      if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'your-openai-api-key-here') {
        console.error('  ‚ö†Ô∏è OpenAI API key not configured. Using sample data.');
        return this.getSampleDataStructure();
      }

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);
      const pdfData = await pdfParse(dataBuffer);

      // Extract text from PDF
      const pdfText = pdfData.text;

    // Use OpenAI to extract QEEG tables
    const prompt = `You are a QEEG data extraction expert. Extract the following data from this ${condition === 'EO' ? 'Eyes Open' : 'Eyes Closed'} QEEG report:

Extract two tables:
1. **Absolute Power (ŒºV¬≤)** table
2. **Relative Power (%)** table

For each table, extract values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract values for these frequency bands:
- Delta
- Theta
- Alpha
- Beta
- HiBeta (High Beta)

Also extract Alpha Peak Frequency (APF) if available.

Return the data in this EXACT JSON format:
{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "O1": 10.0
  }
}

PDF Content:
${pdfText.substring(0, 15000)}`;

      const response = await openai.chat.completions.create({
        model: 'gpt-4-turbo-preview',
        messages: [
          {
            role: 'system',
            content: 'You are an expert at extracting structured QEEG data from medical reports. Always return valid JSON.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        response_format: { type: 'json_object' }
      });

      const extractedData = JSON.parse(response.choices[0].message.content);
      console.log(`  ‚úÖ PDF data extracted successfully (${condition})`);
      return extractedData;

    } catch (error) {
      console.error(`  ‚ùå OpenAI API error (${condition}):`, error.message);

      // Log more details for debugging
      if (error.response) {
        console.error(`  ‚ùå OpenAI API Status:`, error.response.status);
        console.error(`  ‚ùå OpenAI API Error:`, error.response.data);
      }

      // Fallback: Return sample data structure if OpenAI fails
      console.log('  ‚ö†Ô∏è Using sample data structure as fallback');
      return this.getSampleDataStructure();
    }
  }

  /**
   * Parse CSV file
   */
  static parseCSV(file) {
    console.log('  üìä Parsing CSV file...');

    // Read CSV file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert CSV data to our format
    const data = this.convertCSVToFormat(jsonData);

    console.log('  ‚úÖ CSV parsed successfully');
    return data;
  }

  /**
   * Parse Excel file
   */
  static parseExcel(file) {
    console.log('  üìä Parsing Excel file...');

    // Read Excel file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert Excel data to our format
    const data = this.convertExcelToFormat(jsonData);

    console.log('  ‚úÖ Excel parsed successfully');
    return data;
  }

  /**
   * Convert CSV data to expected format
   */
  static convertCSVToFormat(csvData) {
    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta
    const result = {
      absolute: {},
      relative: {},
      special: { alphaPeak: 10.0, O1: 10.0 }
    };

    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];

    for (const row of csvData) {
      const channel = row.Channel;
      const powerType = row.PowerType?.toLowerCase();

      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {
        result[powerType][channel] = {
          Delta: parseFloat(row.Delta) || 0,
          Theta: parseFloat(row.Theta) || 0,
          Alpha: parseFloat(row.Alpha) || 0,
          Beta: parseFloat(row.Beta) || 0,
          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0
        };
      }
    }

    return result;
  }

  /**
   * Convert Excel data to expected format (same as CSV for now)
   */
  static convertExcelToFormat(excelData) {
    return this.convertCSVToFormat(excelData);
  }

  /**
   * Get sample data structure (fallback)
   */
  static getSampleDataStructure() {
    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const result = {
      absolute: {},
      relative: {},
      special: { alphaPeak: 10.0, O1: 10.0 }
    };

    for (const channel of channels) {
      result.absolute[channel] = {
        Delta: 100,
        Theta: 120,
        Alpha: 200,
        Beta: 150,
        HiBeta: 100
      };
      result.relative[channel] = {
        Delta: 20,
        Theta: 15,
        Alpha: 40,
        Beta: 20,
        HiBeta: 5
      };
    }

    return result;
  }
}

module.exports = QEEGParser;
