/**
 * QEEG Algorithm Calculator
 * Based on Rhea's Report - Calculates 7 brain health parameters
 * Each parameter has 3 sub-metrics, scored 0-3, classified as Low/Medium/High
 */

class AlgorithmCalculator {
  constructor(qeegData) {
    this.data = qeegData;
    this.results = {
      parameters: [],
      rawCalculations: {},
      overallScore: 0
    };
  }

  /**
   * Main calculation method - calculates all 7 parameters
   */
  calculate() {
    console.log('\nðŸ§® ========== STARTING ALGORITHM CALCULATIONS ==========');
    console.log('ðŸ“Š Input Data Structure:', JSON.stringify(this.data, null, 2));

    console.log('\nðŸ› === ENHANCED DEBUG MODE ACTIVATED ===');
    console.log('ðŸ“‹ This debug output will show:');
    console.log('   1. Every raw value extracted from QEEG data');
    console.log('   2. All mathematical formulas and calculations');
    console.log('   3. Threshold comparisons and scoring logic');
    console.log('   4. Final score aggregation for each parameter');
    console.log('===========================================\n');

    const parameters = [
      this.calculateCognition(),
      this.calculateStress(),
      this.calculateFocusAttention(),
      this.calculateBurnoutFatigue(),
      this.calculateEmotionalRegulation(),
      this.calculateLearning(),
      this.calculateCreativity()
    ];

    console.log('\nâœ… Final 7 Parameter Scores Calculated:');
    parameters.forEach((p, i) => {
      console.log(`${i + 1}. ${p.name}: ${p.score}/${p.maxScore} (${p.classification}) ${this.getEmoji(p.classification)}`);
      p.metrics.forEach(m => {
        console.log(`   - ${m.name}: ${m.score} point (value: ${JSON.stringify(m.value)})`);
      });
    });

    // === ENHANCED DEBUG: Show complete calculation summary ===
    console.log('\nðŸ› === DEBUG: COMPLETE CALCULATION SUMMARY ===');
    console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    console.log('â”‚ Parameter                   â”‚ Score â”‚ Classificationâ”‚');
    console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
    parameters.forEach(p => {
      const padding = ' '.repeat(28 - p.name.length);
      console.log(`â”‚ ${p.name}${padding}â”‚  ${p.score}/3  â”‚ ${p.classification.padEnd(12)} â”‚`);
    });
    console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    console.log(`\nðŸ“Š OVERALL BRAIN HEALTH SCORE: ${parameters.reduce((sum, p) => sum + p.score, 0)}/21`);
    console.log('=== END DEBUG: CALCULATION SUMMARY ===\n');

    console.log('========== CALCULATIONS COMPLETE ==========\n');

    this.results.parameters = parameters;
    this.results.overallScore = parameters.reduce((sum, p) => sum + p.score, 0);

    return this.results;
  }

  getEmoji(classification) {
    if (classification === 'Low') return 'ðŸ”´';
    if (classification === 'Medium') return 'ðŸŸ¡';
    return 'ðŸŸ¢';
  }

  // ==================== HELPER METHODS ====================

  /**
   * Get value from QEEG data table
   * @param {string} condition - 'EC' (Eyes Closed) or 'EO' (Eyes Open)
   * @param {string} powerType - 'absolute' or 'relative'
   * @param {string} channel - e.g., 'Fz', 'Cz', 'Pz'
   * @param {string} band - e.g., 'Theta', 'Alpha', 'Beta', 'HiBeta', 'Delta'
   */
  getValue(condition, powerType, channel, band) {
    try {
      return this.data[condition][powerType][channel][band];
    } catch (error) {
      console.error(`Error getting value: ${condition}.${powerType}.${channel}.${band}`);
      return null;
    }
  }

  /**
   * Score a metric based on threshold
   * Returns 1 if condition is met (HEALTHY/NORMAL state by default)
   * Use 'invert: true' for stress/problem indicators
   */
  scoreMetric(value, threshold, comparison = 'less', invert = false) {
    if (value === null || value === undefined) return 0;

    let result = 0;

    if (comparison === 'less') {
      result = value < threshold ? 1 : 0;
    } else if (comparison === 'more') {
      result = value > threshold ? 1 : 0;
    } else if (comparison === 'equal') {
      result = value === threshold ? 1 : 0;
    }

    // Invert for stress/problem indicators (where 1 point = problem detected)
    return invert ? (1 - result) : result;
  }

  /**
   * Classify score to bucket (Low/Medium/High)
   */
  classifyScore(score) {
    if (score <= 1) return 'Low';
    if (score === 2) return 'Medium';
    return 'High';
  }

  // ==================== INDIVIDUAL METRICS ====================

  /**
   * Focus Score (Theta:Beta Ratio) - ABSOLUTE POWER - For Cognition parameter
   * Eyes Open, Absolute Power, Fz & Cz average
   * < 1.5 is normal (as per specification)
   */
  calculateFocusScoreAbsolute() {
    console.log('\n  ðŸ” === Calculating Focus Score (Theta:Beta) - ABSOLUTE POWER ===');
    console.log('  ðŸ“‹ Purpose: Measures mental focus by comparing slow (Theta) vs fast (Beta) brain waves');
    console.log('  ðŸ“Š Data Source: Eyes Open (EO), ABSOLUTE Power (Î¼VÂ²), Channels Fz & Cz');
    console.log('  ðŸŽ¯ Expected: Ratio < 1.5 indicates good focus (more Beta than Theta)\n');

    const fzTheta = this.getValue('EO', 'absolute', 'Fz', 'Theta');
    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');
    const czTheta = this.getValue('EO', 'absolute', 'Cz', 'Theta');
    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');

    console.log('  ðŸ› DEBUG - Step 1: Extract Raw Values from QEEG Data');
    console.log('     â”œâ”€ EO.absolute.Fz.Theta =', fzTheta, 'Î¼VÂ²');
    console.log('     â”œâ”€ EO.absolute.Fz.Beta  =', fzBeta, 'Î¼VÂ²');
    console.log('     â”œâ”€ EO.absolute.Cz.Theta =', czTheta, 'Î¼VÂ²');
    console.log('     â””â”€ EO.absolute.Cz.Beta  =', czBeta, 'Î¼VÂ²');

    // Fix: Use == null to allow 0 values (valid EEG readings)
    // Also check for zero denominators to prevent Infinity/NaN
    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null || fzBeta === 0 || czBeta === 0) {
      console.log('     âŒ Missing or zero Beta values (division by zero prevented), returning 0');
      return { value: null, score: 0 };
    }

    console.log('\n  ðŸ› DEBUG - Step 2: Calculate Theta:Beta Ratios');
    const fzRatio = fzTheta / fzBeta;
    const czRatio = czTheta / czBeta;
    console.log('     â”œâ”€ Fz Ratio = Theta/Beta = ' + fzTheta + ' / ' + fzBeta + ' = ' + fzRatio.toFixed(3));
    console.log('     â””â”€ Cz Ratio = Theta/Beta = ' + czTheta + ' / ' + czBeta + ' = ' + czRatio.toFixed(3));

    console.log('\n  ðŸ› DEBUG - Step 3: Calculate Average Ratio');
    const avgRatio = (fzRatio + czRatio) / 2;
    console.log('     â””â”€ Average = (Fz + Cz) / 2 = (' + fzRatio.toFixed(3) + ' + ' + czRatio.toFixed(3) + ') / 2 = ' + avgRatio.toFixed(3));

    console.log('\n  ðŸ› DEBUG - Step 4: Score Against Threshold');
    console.log('     â”œâ”€ Threshold: < 1.5 = Normal (good focus, per spec)');
    console.log('     â”œâ”€ Actual Value: ' + avgRatio.toFixed(3));
    console.log('     â”œâ”€ Comparison: ' + avgRatio.toFixed(3) + ' < 1.5 ? ' + (avgRatio < 1.5));
    const score = this.scoreMetric(avgRatio, 1.5, 'less');
    console.log('     â””â”€ âœ… SCORE: ' + score + '/1 ' + (score === 1 ? '(PASS - Good focus)' : '(FAIL - Poor focus)'));

    return {
      value: avgRatio,
      score: score,
      description: `Theta:Beta Ratio = ${avgRatio.toFixed(2)} (< 1.5 is normal per spec)`,
      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }
    };
  }

  /**
   * Focus Score (Theta:Beta Ratio) - RELATIVE POWER - For Learning, Creativity, Focus&Attention parameters
   * Eyes Open, Relative Power, Fz & Cz average
   * < 1.5 is normal (as per specification)
   */
  calculateFocusScoreRelative() {
    console.log('\n  ðŸ” === Calculating Focus Score (Theta:Beta) - RELATIVE POWER ===');
    console.log('  ðŸ“‹ Purpose: Measures mental focus by comparing slow (Theta) vs fast (Beta) brain waves');
    console.log('  ðŸ“Š Data Source: Eyes Open (EO), RELATIVE Power (%), Channels Fz & Cz');
    console.log('  ðŸŽ¯ Expected: Ratio < 1.5 indicates good focus (more Beta than Theta)\n');

    const fzTheta = this.getValue('EO', 'relative', 'Fz', 'Theta');
    const fzBeta = this.getValue('EO', 'relative', 'Fz', 'Beta');
    const czTheta = this.getValue('EO', 'relative', 'Cz', 'Theta');
    const czBeta = this.getValue('EO', 'relative', 'Cz', 'Beta');

    console.log('  ðŸ› DEBUG - Step 1: Extract Raw Values from QEEG Data');
    console.log('     â”œâ”€ EO.relative.Fz.Theta =', fzTheta, '%');
    console.log('     â”œâ”€ EO.relative.Fz.Beta  =', fzBeta, '%');
    console.log('     â”œâ”€ EO.relative.Cz.Theta =', czTheta, '%');
    console.log('     â””â”€ EO.relative.Cz.Beta  =', czBeta, '%');

    // Fix: Use == null to allow 0 values (valid EEG readings)
    // Also check for zero denominators to prevent Infinity/NaN
    if (fzTheta == null || fzBeta == null || czTheta == null || czBeta == null || fzBeta === 0 || czBeta === 0) {
      console.log('     âŒ Missing or zero Beta values (division by zero prevented), returning 0');
      return { value: null, score: 0 };
    }

    console.log('\n  ðŸ› DEBUG - Step 2: Calculate Theta:Beta Ratios');
    const fzRatio = fzTheta / fzBeta;
    const czRatio = czTheta / czBeta;
    console.log('     â”œâ”€ Fz Ratio = Theta/Beta = ' + fzTheta + ' / ' + fzBeta + ' = ' + fzRatio.toFixed(3));
    console.log('     â””â”€ Cz Ratio = Theta/Beta = ' + czTheta + ' / ' + czBeta + ' = ' + czRatio.toFixed(3));

    console.log('\n  ðŸ› DEBUG - Step 3: Calculate Average Ratio');
    const avgRatio = (fzRatio + czRatio) / 2;
    console.log('     â””â”€ Average = (Fz + Cz) / 2 = (' + fzRatio.toFixed(3) + ' + ' + czRatio.toFixed(3) + ') / 2 = ' + avgRatio.toFixed(3));

    console.log('\n  ðŸ› DEBUG - Step 4: Score Against Threshold');
    console.log('     â”œâ”€ Threshold: < 1.5 = Normal (good focus, per spec)');
    console.log('     â”œâ”€ Actual Value: ' + avgRatio.toFixed(3));
    console.log('     â”œâ”€ Comparison: ' + avgRatio.toFixed(3) + ' < 1.5 ? ' + (avgRatio < 1.5));
    const score = this.scoreMetric(avgRatio, 1.5, 'less');
    console.log('     â””â”€ âœ… SCORE: ' + score + '/1 ' + (score === 1 ? '(PASS - Good focus)' : '(FAIL - Poor focus)'));

    return {
      value: avgRatio,
      score: score,
      description: `Theta:Beta Ratio = ${avgRatio.toFixed(2)} (< 1.5 is normal per spec)`,
      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }
    };
  }

  /**
   * Alpha Peak - Used in multiple parameters
   * Eyes Closed, Special (highest frequency at Pz or below)
   * > 9 Hz is normal
   */
  calculateAlphaPeak() {
    console.log('\n  ðŸ” === Calculating Alpha Peak ===');
    // Get alpha peak from data - NO DEFAULT VALUE
    const alphaPeak = this.data.EC?.special?.alphaPeak || this.data.EC?.special?.O1 || null;

    console.log('     Raw Value:', alphaPeak);

    // If no data available, return 0 score
    if (alphaPeak === null || alphaPeak === undefined) {
      console.log('     âŒ No data available, returning 0');
      return { value: null, score: 0 };
    }

    const score = this.scoreMetric(alphaPeak, 9, 'more');
    console.log(`     Threshold: > 9 Hz = normal`);
    console.log(`     Result: ${alphaPeak} > 9 = ${alphaPeak > 9}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: alphaPeak,
      score: score,
      description: `Alpha Peak = ${alphaPeak.toFixed(1)} Hz (> 9 is normal)`
    };
  }

  /**
   * Alpha:Theta Balance - Used in multiple parameters
   * Eyes Closed, Absolute Power, Fz, Cz, Pz
   * Order Fz > Cz > Pz is normal (frontal dominance)
   * As per specification: Fz > Cz > Pz is the correct order
   */
  calculateAlphaThetaBalance() {
    console.log('\n  ðŸ” === Calculating Alpha:Theta Balance ===');
    const fzAlpha = this.getValue('EC', 'absolute', 'Fz', 'Alpha');
    const fzTheta = this.getValue('EC', 'absolute', 'Fz', 'Theta');
    const czAlpha = this.getValue('EC', 'absolute', 'Cz', 'Alpha');
    const czTheta = this.getValue('EC', 'absolute', 'Cz', 'Theta');
    const pzAlpha = this.getValue('EC', 'absolute', 'Pz', 'Alpha');
    const pzTheta = this.getValue('EC', 'absolute', 'Pz', 'Theta');

    console.log('     Raw Values - Fz:', { Alpha: fzAlpha, Theta: fzTheta });
    console.log('     Raw Values - Cz:', { Alpha: czAlpha, Theta: czTheta });
    console.log('     Raw Values - Pz:', { Alpha: pzAlpha, Theta: pzTheta });

    // Fix: Use == null to allow 0 values (valid EEG readings)
    // Also check for zero denominators to prevent Infinity/NaN
    if (fzAlpha == null || fzTheta == null || czAlpha == null || czTheta == null || pzAlpha == null || pzTheta == null ||
        fzTheta === 0 || czTheta === 0 || pzTheta === 0) {
      console.log('     âŒ Missing or zero Theta values (division by zero prevented), returning 0');
      return { value: null, score: 0 };
    }

    const fzRatio = fzAlpha / fzTheta;
    const czRatio = czAlpha / czTheta;
    const pzRatio = pzAlpha / pzTheta;

    console.log(`     Ratios - Fz: ${fzRatio.toFixed(2)}, Cz: ${czRatio.toFixed(2)}, Pz: ${pzRatio.toFixed(2)}`);
    console.log(`     Expected Order: Fz > Cz > Pz (frontal dominant per spec)`);
    console.log(`     Actual Order: Fz(${fzRatio.toFixed(2)}) > Cz(${czRatio.toFixed(2)}) > Pz(${pzRatio.toFixed(2)})`);

    // Normal pattern: Fz > Cz > Pz (as per specification)
    const isNormalOrder = fzRatio > czRatio && czRatio > pzRatio;

    console.log(`     Check: ${fzRatio.toFixed(2)} > ${czRatio.toFixed(2)} = ${fzRatio > czRatio}`);
    console.log(`     Check: ${czRatio.toFixed(2)} > ${pzRatio.toFixed(2)} = ${czRatio > pzRatio}`);
    console.log(`     âœ… SCORE: ${isNormalOrder ? 1 : 0}/1`);

    return {
      value: { fz: fzRatio.toFixed(2), cz: czRatio.toFixed(2), pz: pzRatio.toFixed(2) },
      score: isNormalOrder ? 1 : 0,
      description: `Alpha:Theta Order = ${isNormalOrder ? 'Fz > Cz > Pz (Normal per spec)' : 'Abnormal order'}`,
      details: { fzRatio, czRatio, pzRatio, order: isNormalOrder }
    };
  }

  /**
   * Arousal Score (HiBeta:Beta Ratio) - Used in multiple parameters
   * Eyes Open, Absolute Power, Fz & Cz average
   * < 1 is normal
   */
  calculateArousalScore() {
    console.log('\n  ðŸ” === Calculating Arousal Score (HiBeta:Beta) ===');
    const fzBeta = this.getValue('EO', 'absolute', 'Fz', 'Beta');
    const fzHiBeta = this.getValue('EO', 'absolute', 'Fz', 'HiBeta');
    const czBeta = this.getValue('EO', 'absolute', 'Cz', 'Beta');
    const czHiBeta = this.getValue('EO', 'absolute', 'Cz', 'HiBeta');

    console.log('     Raw Values - Fz:', { Beta: fzBeta, HiBeta: fzHiBeta });
    console.log('     Raw Values - Cz:', { Beta: czBeta, HiBeta: czHiBeta });

    // Fix: Use == null to allow 0 values (valid EEG readings)
    // Also check for zero denominators to prevent Infinity/NaN
    if (fzBeta == null || fzHiBeta == null || czBeta == null || czHiBeta == null || fzBeta === 0 || czBeta === 0) {
      console.log('     âŒ Missing or zero Beta values (division by zero prevented), returning 0');
      return { value: null, score: 0 };
    }

    const fzRatio = fzHiBeta / fzBeta;
    const czRatio = czHiBeta / czBeta;
    const avgRatio = (fzRatio + czRatio) / 2;
    const score = this.scoreMetric(avgRatio, 1, 'less');

    console.log(`     Fz ratio (HiBeta/Beta): ${fzRatio.toFixed(3)}`);
    console.log(`     Cz ratio (HiBeta/Beta): ${czRatio.toFixed(3)}`);
    console.log(`     Average: ${avgRatio.toFixed(3)}`);
    console.log(`     Threshold: < 1 = normal (low arousal)`);
    console.log(`     Result: ${avgRatio.toFixed(3)} < 1 = ${avgRatio < 1}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: avgRatio,
      score: score,
      description: `Arousal Score = ${avgRatio.toFixed(2)} (< 1 is normal)`,
      details: { fzRatio: fzRatio.toFixed(2), czRatio: czRatio.toFixed(2) }
    };
  }

  /**
   * Relaxation Score - Used in multiple parameters
   * Eyes Closed, ABSOLUTE Power, Pz, Alpha/Beta
   * > 1 is healthy (as per specification)
   */
  calculateRelaxationScore() {
    console.log('\n  ðŸ” === Calculating Relaxation Score ===');
    console.log('  ðŸ“‹ Purpose: Measures ability to relax by comparing Alpha vs Beta waves');
    console.log('  ðŸ“Š Data Source: Eyes Closed (EC), ABSOLUTE Power (Î¼VÂ²), Pz channel (posterior)');
    console.log('  ðŸŽ¯ Expected: Alpha/Beta > 1 indicates good relaxation capacity (per spec)\n');

    const pzAlpha = this.getValue('EC', 'absolute', 'Pz', 'Alpha');
    const pzBeta = this.getValue('EC', 'absolute', 'Pz', 'Beta');

    console.log('  ðŸ› DEBUG - Step 1: Extract Raw Values from QEEG Data');
    console.log('     â”œâ”€ EC.absolute.Pz.Alpha =', pzAlpha, 'Î¼VÂ²');
    console.log('     â””â”€ EC.absolute.Pz.Beta  =', pzBeta, 'Î¼VÂ²');

    // Fix: Use == null to allow 0 values (valid EEG readings)
    if (pzAlpha == null || pzBeta == null || pzBeta === 0) {
      console.log('     âš ï¸ Missing or zero Beta value, returning 0');
      return { value: null, score: 0 };
    }

    console.log('\n  ðŸ› DEBUG - Step 2: Calculate Alpha:Beta Ratio');
    const ratio = pzAlpha / pzBeta;
    console.log('     â””â”€ Ratio = Alpha/Beta = ' + pzAlpha + ' / ' + pzBeta + ' = ' + ratio.toFixed(2));

    console.log('\n  ðŸ› DEBUG - Step 3: Score Against Threshold');
    console.log('     â”œâ”€ Threshold: > 1.0 (per specification)');
    console.log('     â”œâ”€ Actual Value: ' + ratio.toFixed(2));
    console.log('     â”œâ”€ Comparison: ' + ratio.toFixed(2) + ' > 1.0 ? ' + (ratio > 1.0));

    // As per specification: > 1 is healthy
    const score = ratio > 1.0 ? 1 : 0;
    console.log('     â””â”€ âœ… SCORE: ' + score + '/1 ' + (score === 1 ? '(PASS - Good relaxation)' : '(FAIL - Poor relaxation)'));

    console.log('\n  ðŸ’¡ Interpretation:');
    if (ratio > 1) {
      console.log('     â†’ High Alpha relative to Beta = Good relaxation capacity');
      console.log('     â†’ Brain can easily shift into relaxed, calm state');
    } else {
      console.log('     â†’ Low Alpha relative to Beta = Difficulty relaxing');
      console.log('     â†’ May indicate stress or hyperarousal');
    }

    return {
      value: ratio,
      score: score,
      description: `Relaxation Score = ${ratio.toFixed(2)} (> 1 is healthy per spec)`
    };
  }

  /**
   * Regeneration (Alpha Modulation) - Used in multiple parameters
   * EO & EC, Relative Power, Pz, (EC-EO)/EC * 100
   * > 30% is healthy
   */
  calculateRegeneration() {
    console.log('\n  ðŸ” === Calculating Regeneration (Alpha Modulation) ===');
    console.log('     Using: EC vs EO relative power at Pz');
    const ecAlpha = this.getValue('EC', 'relative', 'Pz', 'Alpha');
    const eoAlpha = this.getValue('EO', 'relative', 'Pz', 'Alpha');

    console.log('     Raw Values:', { 'EC Alpha': ecAlpha, 'EO Alpha': eoAlpha });

    // Fix: Use == null to allow 0 values (valid EEG readings)
    if (ecAlpha == null || eoAlpha == null || ecAlpha === 0) {
      console.log('     âŒ Missing or zero EC Alpha value, returning 0');
      return { value: null, score: 0 };
    }

    const modulation = ((ecAlpha - eoAlpha) / ecAlpha) * 100;
    const score = this.scoreMetric(modulation, 30, 'more');

    console.log(`     Formula: ((EC - EO) / EC) Ã— 100`);
    console.log(`     Calculation: ((${ecAlpha} - ${eoAlpha}) / ${ecAlpha}) Ã— 100`);
    console.log(`     Modulation: ${modulation.toFixed(1)}%`);
    console.log(`     Threshold: > 30% = healthy (good alpha reactivity)`);
    console.log(`     Result: ${modulation.toFixed(1)}% > 30% = ${modulation > 30}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: modulation,
      score: score,
      description: `Alpha Modulation = ${modulation.toFixed(1)}% (> 30% is healthy)`
    };
  }

  /**
   * Focus Theta (Relative Power) - Used in Focus & Attention
   * Eyes Open, Relative Power, Fz & Cz average
   * < 20% is normal
   */
  calculateFocusTheta() {
    console.log('\n  ðŸ” === Calculating Focus Theta ===');
    console.log('     Using: EO relative power at Fz and Cz');
    const fzTheta = this.getValue('EO', 'relative', 'Fz', 'Theta');
    const czTheta = this.getValue('EO', 'relative', 'Cz', 'Theta');

    console.log('     Raw Values:', { 'Fz Theta': fzTheta, 'Cz Theta': czTheta });

    // Fix: Use == null to allow 0 values (valid EEG readings)
    if (fzTheta == null || czTheta == null) {
      console.log('     âŒ Missing values, returning 0');
      return { value: null, score: 0 };
    }

    const avgTheta = (fzTheta + czTheta) / 2;
    const score = this.scoreMetric(avgTheta, 20, 'less');

    console.log(`     Average: (${fzTheta} + ${czTheta}) / 2 = ${avgTheta.toFixed(1)}%`);
    console.log(`     Threshold: < 20% = normal (low frontal theta)`);
    console.log(`     Result: ${avgTheta.toFixed(1)}% < 20% = ${avgTheta < 20}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: avgTheta,
      score: score,
      description: `Focus Theta = ${avgTheta.toFixed(1)}% (< 20% is normal)`
    };
  }

  /**
   * Excessive Delta - Used in Burnout & Fatigue
   * Eyes Open, Relative Power, avg of Fz, C3, Cz, C4, P3, Pz, P4
   * < 70% is normal
   */
  calculateExcessiveDelta() {
    console.log('\n  ðŸ” === Calculating Excessive Delta ===');
    console.log('     Using: EO relative power, averaging 7 channels');
    const channels = ['Fz', 'C3', 'Cz', 'C4', 'P3', 'Pz', 'P4'];
    let sum = 0;
    let count = 0;
    const channelValues = {};

    for (const channel of channels) {
      const delta = this.getValue('EO', 'relative', channel, 'Delta');
      channelValues[channel] = delta !== null ? delta : 'N/A';
      if (delta !== null) {
        sum += delta;
        count++;
      }
    }

    console.log('     Channel Values:', channelValues);
    console.log(`     Valid channels: ${count}/7`);

    if (count === 0) {
      console.log('     âŒ No valid channel data, returning 0');
      return { value: null, score: 0 };
    }

    const avgDelta = sum / count;
    const score = this.scoreMetric(avgDelta, 70, 'less');

    console.log(`     Sum: ${sum.toFixed(2)}, Count: ${count}`);
    console.log(`     Average Delta: ${avgDelta.toFixed(1)}%`);
    console.log(`     Threshold: < 70% = normal (low delta during wakefulness)`);
    console.log(`     Result: ${avgDelta.toFixed(1)}% < 70% = ${avgDelta < 70}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: avgDelta,
      score: score,
      description: `Excessive Delta = ${avgDelta.toFixed(1)}% (< 70% is normal)`
    };
  }

  /**
   * Alpha Asymmetry (Frontal) - Used in Emotional Regulation
   * Eyes Closed, Absolute Power, F3 & F4
   * F4/F3 < 1 is normal
   */
  calculateAlphaAsymmetry() {
    console.log('\n  ðŸ” === Calculating Alpha Asymmetry (Frontal) ===');
    console.log('     Using: EC absolute power at F3 and F4');
    const f3Alpha = this.getValue('EC', 'absolute', 'F3', 'Alpha');
    const f4Alpha = this.getValue('EC', 'absolute', 'F4', 'Alpha');

    console.log('     Raw Values:', { 'F3 Alpha': f3Alpha, 'F4 Alpha': f4Alpha });

    // Fix: Use == null to allow 0 values (valid EEG readings)
    if (f3Alpha == null || f4Alpha == null || f3Alpha === 0) {
      console.log('     âŒ Missing or zero F3 value, returning 0');
      return { value: null, score: 0 };
    }

    const ratio = f4Alpha / f3Alpha;
    const score = this.scoreMetric(ratio, 1, 'less');

    console.log(`     Ratio: F4/F3 = ${f4Alpha} / ${f3Alpha} = ${ratio.toFixed(3)}`);
    console.log(`     Threshold: < 1 = normal (left frontal dominance, positive affect)`);
    console.log(`     Result: ${ratio.toFixed(3)} < 1 = ${ratio < 1}`);
    console.log(`     âœ… SCORE: ${score}/1`);

    return {
      value: ratio,
      score: score,
      description: `Alpha Asymmetry = ${ratio.toFixed(2)} (< 1 is normal)`
    };
  }

  // ==================== 7 PARAMETER CALCULATIONS ====================

  /**
   * 1. Cognition
   * - Focus Score (Theta:Beta Ratio)
   * - Alpha Peak
   * - Alpha:Theta Balance
   */
  calculateCognition() {
    console.log('\nðŸ“Š ==================== COGNITION PARAMETER ====================');
    console.log('ðŸ“‹ Input Data Verification:');
    console.log('   EO.absolute.Fz:', this.data.EO?.absolute?.Fz);
    console.log('   EO.absolute.Cz:', this.data.EO?.absolute?.Cz);
    console.log('   EC.absolute.Fz:', this.data.EC?.absolute?.Fz);
    console.log('   EC.absolute.Cz:', this.data.EC?.absolute?.Cz);
    console.log('   EC.absolute.Pz:', this.data.EC?.absolute?.Pz);
    console.log('   EC.special.alphaPeak:', this.data.EC?.special?.alphaPeak);
    console.log('==============================================================\n');

    const metric1 = this.calculateFocusScoreAbsolute(); // Use ABSOLUTE power for Cognition
    const metric2 = this.calculateAlphaPeak();
    const metric3 = this.calculateAlphaThetaBalance();

    const totalScore = metric1.score + metric2.score + metric3.score;
    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);

    return {
      name: 'Cognition',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Focus Score (Theta:Beta)', ...metric1 },
        { name: 'Alpha Peak', ...metric2 },
        { name: 'Alpha:Theta Balance', ...metric3 }
      ]
    };
  }

  /**
   * 2. Stress (Note: 0/3 is healthy, 3/3 is high stress)
   * - Arousal Score (inverted: abnormal = 1 point)
   * - Relaxation Score (inverted: abnormal = 1 point)
   * - Regeneration (inverted: abnormal = 1 point)
   */
  calculateStress() {
    console.log('\nðŸ“Š === STRESS PARAMETER (0/3 = Healthy, 3/3 = High Stress) ===');
    const metric1 = this.calculateArousalScore();
    const metric2 = this.calculateRelaxationScore();
    const metric3 = this.calculateRegeneration();

    // Invert scores: 0->1, 1->0 (so abnormal values add to stress score)
    const invertedScore1 = 1 - metric1.score;
    const invertedScore2 = 1 - metric2.score;
    const invertedScore3 = 1 - metric3.score;

    console.log(`\n  ðŸ”„ INVERTING SCORES (abnormal values = stress):`);
    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (stress): ${invertedScore1}`);
    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (stress): ${invertedScore2}`);
    console.log(`     Regeneration normal score: ${metric3.score} â†’ Inverted (stress): ${invertedScore3}`);

    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;
    console.log(`\n  ðŸ“Š STRESS TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);

    return {
      name: 'Stress',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Arousal Score', ...metric1, score: invertedScore1 },
        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },
        { name: 'Regeneration (Alpha Modulation)', ...metric3, score: invertedScore3 }
      ]
    };
  }

  /**
   * 3. Focus & Attention
   * - Focus Theta
   * - Alpha:Theta Balance
   * - Focus Score (Theta:Beta)
   */
  calculateFocusAttention() {
    console.log('\nðŸ“Š Calculating FOCUS & ATTENTION...');
    const metric1 = this.calculateFocusTheta();
    const metric2 = this.calculateAlphaThetaBalance();
    const metric3 = this.calculateFocusScoreRelative(); // Use RELATIVE power

    const totalScore = metric1.score + metric2.score + metric3.score;
    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);

    return {
      name: 'Focus & Attention',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Focus Theta', ...metric1 },
        { name: 'Alpha:Theta Balance', ...metric2 },
        { name: 'Focus Score (Theta:Beta)', ...metric3 }
      ]
    };
  }

  /**
   * 4. Burnout & Fatigue (Note: 0/3 is healthy)
   * - Arousal Score (inverted: abnormal = 1 point)
   * - Relaxation Score (inverted: abnormal = 1 point)
   * - Excessive Delta (inverted: abnormal = 1 point)
   */
  calculateBurnoutFatigue() {
    console.log('\nðŸ“Š === BURNOUT & FATIGUE PARAMETER (0/3 = Healthy, 3/3 = High Burnout) ===');
    const metric1 = this.calculateArousalScore();
    const metric2 = this.calculateRelaxationScore();
    const metric3 = this.calculateExcessiveDelta();

    // Invert scores: 0->1, 1->0 (so abnormal values add to burnout score)
    const invertedScore1 = 1 - metric1.score;
    const invertedScore2 = 1 - metric2.score;
    const invertedScore3 = 1 - metric3.score;

    console.log(`\n  ðŸ”„ INVERTING SCORES (abnormal values = burnout):`);
    console.log(`     Arousal normal score: ${metric1.score} â†’ Inverted (burnout): ${invertedScore1}`);
    console.log(`     Relaxation normal score: ${metric2.score} â†’ Inverted (burnout): ${invertedScore2}`);
    console.log(`     Excessive Delta normal score: ${metric3.score} â†’ Inverted (burnout): ${invertedScore3}`);

    const totalScore = invertedScore1 + invertedScore2 + invertedScore3;
    console.log(`\n  ðŸ“Š BURNOUT TOTAL: ${invertedScore1} + ${invertedScore2} + ${invertedScore3} = ${totalScore}/3`);

    return {
      name: 'Burnout & Fatigue',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Arousal Score', ...metric1, score: invertedScore1 },
        { name: 'Relaxation Score', ...metric2, score: invertedScore2 },
        { name: 'Excessive Delta', ...metric3, score: invertedScore3 }
      ]
    };
  }

  /**
   * 5. Emotional Regulation
   * - Alpha Asymmetry
   * - Arousal Score
   * - Regeneration
   */
  calculateEmotionalRegulation() {
    console.log('\nðŸ“Š Calculating EMOTIONAL REGULATION...');
    const metric1 = this.calculateAlphaAsymmetry();
    const metric2 = this.calculateArousalScore();
    const metric3 = this.calculateRegeneration();

    const totalScore = metric1.score + metric2.score + metric3.score;
    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);

    return {
      name: 'Emotional Regulation',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Alpha Asymmetry (Frontal)', ...metric1 },
        { name: 'Arousal Score', ...metric2 },
        { name: 'Regeneration (Alpha Modulation)', ...metric3 }
      ]
    };
  }

  /**
   * 6. Learning
   * - Alpha Peak
   * - Focus Score (Theta:Beta)
   * - Arousal Score
   */
  calculateLearning() {
    console.log('\nðŸ“Š Calculating LEARNING...');
    const metric1 = this.calculateAlphaPeak();
    const metric2 = this.calculateFocusScoreRelative(); // Use RELATIVE power
    const metric3 = this.calculateArousalScore();

    const totalScore = metric1.score + metric2.score + metric3.score;
    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);

    return {
      name: 'Learning',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Alpha Peak', ...metric1 },
        { name: 'Focus Score (Theta:Beta)', ...metric2 },
        { name: 'Arousal Score', ...metric3 }
      ]
    };
  }

  /**
   * 7. Creativity
   * - Relaxation Score
   * - Focus Score (Theta:Beta)
   * - Alpha Peak
   */
  calculateCreativity() {
    console.log('\nðŸ“Š Calculating CREATIVITY...');
    const metric1 = this.calculateRelaxationScore();
    const metric2 = this.calculateFocusScoreRelative(); // Use RELATIVE power
    const metric3 = this.calculateAlphaPeak();

    const totalScore = metric1.score + metric2.score + metric3.score;
    console.log(`   Total: ${metric1.score} + ${metric2.score} + ${metric3.score} = ${totalScore}/3`);

    return {
      name: 'Creativity',
      score: totalScore,
      maxScore: 3,
      classification: this.classifyScore(totalScore),
      metrics: [
        { name: 'Relaxation Score', ...metric1 },
        { name: 'Focus Score (Theta:Beta)', ...metric2 },
        { name: 'Alpha Peak', ...metric3 }
      ]
    };
  }
}

module.exports = AlgorithmCalculator;
