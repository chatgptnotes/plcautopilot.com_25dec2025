import DatabaseService from './databaseService';
import toast from 'react-hot-toast';

class AlertService {
  constructor() {
    this.alertThresholds = {
      warning: 0.8, // 80% usage
      critical: 1.0, // 100% usage
      trial: 7 // days left in trial
    };

    this.checkIntervalId = null;
    this.isRunning = false;
    this.inMemoryAlerts = []; // Store alerts in memory instead of database
  }

  // Start the automated alert system
  start() {
    if (this.isRunning) {
      console.log('Alert service already running');
      return;
    }

    this.isRunning = true;
    // Check alerts every 5 minutes (300000ms)
    this.checkIntervalId = setInterval(() => {
      this.checkAllClinics();
    }, 300000);

    // Run initial check
    this.checkAllClinics();
    console.log('Alert service started');
  }

  // Stop the automated alert system
  stop() {
    if (this.checkIntervalId) {
      clearInterval(this.checkIntervalId);
      this.checkIntervalId = null;
    }
    this.isRunning = false;
    console.log('Alert service stopped');
  }

  // Check all clinics for alerts
  async checkAllClinics() {
    try {
      const clinics = await DatabaseService.get('clinics') || [];

      if (!Array.isArray(clinics)) {
        console.error('Clinics data is not an array:', clinics);
        return;
      }

      clinics.forEach(clinic => {
        if (clinic.isActive) {
          this.checkClinicUsage(clinic);
          this.checkTrialStatus(clinic);
        }
      });
    } catch (error) {
      console.error('Error checking clinic alerts:', error);
    }
  }

  // Check clinic usage and generate alerts
  checkClinicUsage(clinic) {
    const usagePercentage = (clinic.reportsUsed || 0) / (clinic.reportsAllowed || 10);
    
    // Critical alert - 100% or more usage
    if (usagePercentage >= this.alertThresholds.critical) {
      this.createAlert(clinic.id, {
        type: 'critical',
        category: 'usage',
        title: 'Report Limit Reached',
        message: `Clinic ${clinic.name} has used all ${clinic.reportsAllowed || 10} allocated reports.`,
        action: 'purchase_reports',
        data: {
          reportsUsed: clinic.reportsUsed || 0,
          reportsAllowed: clinic.reportsAllowed || 10
        }
      });
    }
    // Warning alert - 80% or more usage
    else if (usagePercentage >= this.alertThresholds.warning) {
      this.createAlert(clinic.id, {
        type: 'warning',
        category: 'usage',
        title: 'Report Limit Warning',
        message: `Clinic ${clinic.name} has used ${Math.round(usagePercentage * 100)}% of their allocated reports.`,
        action: 'consider_purchase',
        data: {
          reportsUsed: clinic.reportsUsed || 0,
          reportsAllowed: clinic.reportsAllowed || 10,
          percentage: Math.round(usagePercentage * 100)
        }
      });
    }
  }

  // Check trial status
  checkTrialStatus(clinic) {
    if (clinic.subscriptionStatus === 'trial' && clinic.trialEndDate) {
      const endDate = new Date(clinic.trialEndDate);
      const now = new Date();
      const daysLeft = Math.ceil((endDate - now) / (1000 * 60 * 60 * 24));
      
      if (daysLeft <= 0) {
        // Trial expired
        this.createAlert(clinic.id, {
          type: 'critical',
          category: 'trial',
          title: 'Trial Expired',
          message: `Trial period for clinic ${clinic.name} has expired.`,
          action: 'upgrade_subscription',
          data: {
            trialEndDate: clinic.trialEndDate,
            daysExpired: Math.abs(daysLeft)
          }
        });
        
        // Deactivate clinic if trial expired
        DatabaseService.update('clinics', clinic.id, {
          subscriptionStatus: 'expired',
          isActive: false
        });
      }
      else if (daysLeft <= this.alertThresholds.trial) {
        // Trial ending soon
        this.createAlert(clinic.id, {
          type: 'warning',
          category: 'trial',
          title: 'Trial Ending Soon',
          message: `Trial for clinic ${clinic.name} will expire in ${daysLeft} day${daysLeft > 1 ? 's' : ''}.`,
          action: 'upgrade_subscription',
          data: {
            trialEndDate: clinic.trialEndDate,
            daysLeft: daysLeft
          }
        });
      }
    }
  }

  // Create an alert record
  async createAlert(clinicId, alertData) {
    const alertId = `${clinicId}_${alertData.category}_${alertData.type}`;

    // Check if similar alert already exists and is recent
    const existingAlert = await this.getRecentAlert(clinicId, alertData.category, alertData.type);
    if (existingAlert) {
      // Update existing alert instead of creating duplicate
      existingAlert.updatedAt = new Date().toISOString();
      existingAlert.count = (existingAlert.count || 1) + 1;
      return existingAlert;
    }

    // Create new alert in memory (don't save to database to avoid UUID issues)
    const alert = {
      id: alertId,
      clinicId,
      ...alertData,
      status: 'active',
      count: 1,
      acknowledged: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    // Add to in-memory storage
    this.inMemoryAlerts.push(alert);

    // Show toast notification for critical alerts
    if (alertData.type === 'critical') {
      toast.error(alertData.message, { duration: 8000 });
    } else if (alertData.type === 'warning') {
      toast.error(alertData.message, { duration: 6000 });
    }

    return alert;
  }

  // Get recent alert of same type to avoid duplicates
  async getRecentAlert(clinicId, category, type) {
    const recentThreshold = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours ago

    return this.inMemoryAlerts.find(alert =>
      alert.clinicId === clinicId &&
      alert.category === category &&
      alert.type === type &&
      alert.status === 'active' &&
      new Date(alert.createdAt) > recentThreshold
    );
  }

  // Get active alerts for a clinic
  async getClinicAlerts(clinicId, activeOnly = true) {
    let alerts = this.inMemoryAlerts.filter(alert => alert.clinicId === clinicId);

    if (activeOnly) {
      alerts = alerts.filter(alert => alert.status === 'active');
    }

    return alerts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  }

  // Get all active alerts across all clinics
  async getAllActiveAlerts() {
    return this.inMemoryAlerts
      .filter(alert => alert.status === 'active')
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  }

  // Acknowledge an alert
  async acknowledgeAlert(alertId) {
    const alert = this.inMemoryAlerts.find(a => a.id === alertId);
    if (alert) {
      alert.acknowledged = true;
      alert.acknowledgedAt = new Date().toISOString();
    }
  }

  // Dismiss/resolve an alert
  async dismissAlert(alertId) {
    const alert = this.inMemoryAlerts.find(a => a.id === alertId);
    if (alert) {
      alert.status = 'resolved';
      alert.resolvedAt = new Date().toISOString();
    }
  }

  // Get alert statistics
  async getAlertStats() {
    const activeAlerts = this.inMemoryAlerts.filter(alert => alert.status === 'active');

    const stats = {
      total: this.inMemoryAlerts.length,
      active: activeAlerts.length,
      critical: activeAlerts.filter(alert => alert.type === 'critical').length,
      warning: activeAlerts.filter(alert => alert.type === 'warning').length,
      byCategory: {}
    };

    // Group by category
    activeAlerts.forEach(alert => {
      stats.byCategory[alert.category] = (stats.byCategory[alert.category] || 0) + 1;
    });

    return stats;
  }

  // Send email notifications (mock implementation)
  async sendEmailNotification(alert, clinic) {
    // In production, this would integrate with an email service
    console.log(`Mock Email Notification:
      To: ${clinic.email}
      Subject: ${alert.title}
      Message: ${alert.message}
      Type: ${alert.type}
    `);
    
    // Simulate email sending delay
    return new Promise(resolve => setTimeout(resolve, 1000));
  }

  // Initialize alerts table if it doesn't exist
  initializeAlertsTable() {
    // Alerts are now stored in memory, no need for localStorage
    // Only initialize if not already initialized
    if (!this.inMemoryAlerts) {
      this.inMemoryAlerts = [];
    }
    console.log('Alert service initialized with in-memory storage');
  }
}

export default new AlertService();