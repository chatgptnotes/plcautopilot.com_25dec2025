const { GoogleGenerativeAI } = require('@google/generative-ai');

class GeminiService {
  constructor() {
    console.log('\nüîß Initializing Gemini Service...');
    this.apiKey = process.env.GEMINI_API_KEY;

    if (!this.apiKey) {
      console.error('‚ùå CRITICAL: GEMINI_API_KEY not found in environment variables!');
      console.error('   Please check your .env file');
    } else {
      console.log('‚úÖ Gemini API Key found');
      console.log('   Key length:', this.apiKey.length);
      console.log('   Key preview:', `${this.apiKey.substring(0, 15)}...`);
    }

    this.genAI = this.apiKey ? new GoogleGenerativeAI(this.apiKey) : null;
    this.model = null;
    console.log('‚úÖ Gemini Service initialized\n');
  }

  /**
   * Fetch available Gemini models
   */
  async fetchAvailableModels() {
    try {
      console.log('üîç Fetching available Gemini models for PDF generation...');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1/models?key=${this.apiKey}`
      );

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      const supportedModels = (data.models || []).filter(model =>
        model.supportedGenerationMethods?.includes('generateContent')
      );

      console.log(`‚úÖ Found ${supportedModels.length} models for PDF generation`);
      return supportedModels;
    } catch (error) {
      console.error('‚ùå Failed to fetch models:', error.message);
      return [];
    }
  }

  /**
   * Select best model for PDF generation
   */
  selectBestModel(models) {
    if (!models || models.length === 0) return null;

    // Prefer flash models for speed
    const preferences = ['flash', 'pro'];

    for (const preference of preferences) {
      const found = models.find(m =>
        m.name.toLowerCase().includes(preference)
      );
      if (found) {
        console.log(`‚úÖ Selected model for PDF: ${found.name}`);
        return found.name;
      }
    }

    console.log(`‚úÖ Using first available model: ${models[0].name}`);
    return models[0].name;
  }

  /**
   * Initialize the Gemini model
   */
  async initModel() {
    if (!this.genAI) {
      throw new Error('Gemini API not initialized. Please check GEMINI_API_KEY.');
    }

    console.log('üîß Initializing Gemini model for PDF generation...');
    console.log('üîë API Key status:', this.apiKey ? 'Present' : 'MISSING');

    // Fetch available models dynamically
    const availableModels = await this.fetchAvailableModels();

    if (availableModels.length === 0) {
      console.error('\n‚ùå No models available for PDF generation!');
      console.error('Please check your GEMINI_API_KEY at https://aistudio.google.com/apikey\n');
      throw new Error('No Gemini models available. Check your API key.');
    }

    // Select best model
    const modelName = this.selectBestModel(availableModels);

    if (!modelName) {
      throw new Error('Could not select a valid model for PDF generation');
    }

    // Initialize model with full path
    console.log(`üîß Initializing model: ${modelName}`);
    this.model = this.genAI.getGenerativeModel({ model: modelName });

    // Test the model
    console.log('üìû Testing model...');
    try {
      const testResult = await this.model.generateContent('Hello');
      const testResponse = await testResult.response;
      testResponse.text();
      console.log('‚úÖ Model initialized and tested successfully for PDF generation');
    } catch (testError) {
      console.error(`‚ùå Model test failed:`, testError.message);
      throw new Error(`Failed to test model ${modelName}: ${testError.message}`);
    }

    return this.model;
  }

  /**
   * System prompt for brain performance report generation
   */
  getReportGenerationPrompt() {
    return `You are an expert neuroscience report generator powered by AI. Your task is to create a comprehensive, visually appealing, and easy-to-understand brain performance infographic report for patients.

üéØ YOUR ROLE:
Generate a professional single-page A4 infographic-style brain health report based on QEEG (Quantitative Electroencephalography) analysis results. The report must be informative yet accessible to non-medical readers.

üìä INPUT DATA:
You will receive 7 brain performance parameters with their scores, classifications, and sub-metrics:
1. **Cognition** - Mental processing, focus ability, and alpha-theta balance
2. **Stress** - Arousal levels, relaxation capacity, and regeneration ability
3. **Focus & Attention** - Concentration ability, theta levels, and mental alertness
4. **Burnout & Fatigue** - Energy levels, exhaustion markers, and delta wave patterns
5. **Emotional Regulation** - Mood stability, frontal alpha asymmetry, and emotional control
6. **Learning** - Cognitive flexibility, memory formation, and neural plasticity
7. **Creativity** - Divergent thinking, relaxation state, and innovative capacity

üìã SCORING SYSTEM:
- Each parameter is scored from 0-3 points
- Classification: Low (0-1), Medium (2), High (3)
- Sub-metrics contribute individual points to the total score
- **Special Note**: For Stress and Burnout parameters, LOWER scores are BETTER (0/3 = Healthy, 3/3 = High Problem)

üé® INFOGRAPHIC REPORT REQUIREMENTS:

1. **Visual Design**:
   - Modern, clean, and colorful layout
   - Use vibrant but professional colors
   - Each parameter should have a distinct visual identity
   - Icons and graphical elements for each brain function
   - Color-coded scoring system (Green = Optimal, Yellow = Moderate, Red = Needs Attention)

2. **Content Structure**:
   - Patient-friendly language (avoid heavy medical jargon)
   - One-line impactful summary for each parameter
   - Clear explanation of what each metric means in daily life
   - Practical interpretation of scores
   - Holistic overall summary

3. **Parameter Presentation**:
   - Parameter name in bold, large font
   - Score displayed prominently (e.g., "2/3 - Medium")
   - Color-coded badge/banner based on classification
   - List all sub-metrics with checkmarks (‚úì) or crosses (‚úó)
   - Simple explanation of what each sub-metric indicates

4. **Color Coding Guidelines**:
   For HEALTH parameters (Cognition, Focus, Emotional Regulation, Learning, Creativity):
   - High (3/3): #38A169 (Green) - Excellent performance
   - Medium (2/3): #F59E0B (Amber) - Good, room for improvement
   - Low (0-1/3): #E53E3E (Red) - Needs attention

   For PROBLEM parameters (Stress, Burnout):
   - Low (0/3): #38A169 (Green) - Healthy, no issues
   - Medium (1-2/3): #F59E0B (Amber) - Moderate concern
   - High (3/3): #E53E3E (Red) - High concern

5. **Interpretations Guidelines**:
   - Explain what HIGH scores mean for each parameter
   - Explain what LOW scores mean
   - Connect brain metrics to real-life implications
   - Examples:
     * "High Focus & Attention (3/3): Your brain shows excellent concentration ability and minimal distracting theta activity"
     * "Low Stress (0/3): Great news! Your brain shows healthy relaxation patterns and low arousal"
     * "Medium Cognition (2/3): Good cognitive function with room for optimization in alpha-theta balance"

6. **Sub-Metrics Explanation Examples**:
   - "Focus Score (Theta:Beta Ratio): ‚úì Optimal - Your frontal brain regions show balanced activity for sustained attention"
   - "Relaxation Score: ‚úó Below threshold - Your brain may have difficulty shifting into relaxed states"
   - "Alpha Peak: ‚úì Normal - Healthy alpha rhythm frequency indicates good brain maturation"

7. **Overall Summary Requirements**:
   - Synthesize all 7 parameters into a cohesive narrative
   - Highlight strengths and areas for improvement
   - Provide context about what the overall pattern suggests
   - Maintain encouraging and constructive tone
   - 3-5 sentences maximum

8. **Recommendations**:
   - Provide 4-6 actionable, personalized recommendations
   - Base suggestions on the actual scores received
   - Include lifestyle, cognitive training, or mindfulness suggestions
   - Keep recommendations practical and achievable

üì§ OUTPUT FORMAT:

Return ONLY a valid JSON object (no markdown, no code blocks, no explanations) with this EXACT structure:

{
  "title": "Brain Performance Analysis Report",
  "patientSummary": "A comprehensive 3-5 sentence summary synthesizing all parameters, highlighting key strengths and areas for growth, with an encouraging tone",
  "parameters": [
    {
      "name": "Cognition",
      "score": 2,
      "maxScore": 3,
      "bucket": "Medium",
      "bucketColor": "#F59E0B",
      "icon": "üß†",
      "summary": "One impactful sentence summarizing this parameter's meaning and result",
      "subparameters": [
        {
          "name": "Focus Score (Theta:Beta Ratio)",
          "score": 1,
          "interpretation": "Clear explanation of what this score means in daily life",
          "details": "Technical detail if helpful: actual value and threshold"
        }
      ]
    }
  ],
  "recommendations": [
    "Specific actionable recommendation based on the actual scores",
    "Another personalized suggestion",
    "Lifestyle tip relevant to the results",
    "Cognitive exercise or mindfulness practice if applicable"
  ],
  "layoutSuggestions": {
    "colorScheme": "Professional palette: Deep blue header (#323956), parameter colors as specified, white background (#FFFFFF)",
    "structure": "Grid layout: 2 columns for parameters, header with title and patient info, summary and recommendations at bottom"
  }
}

üö® CRITICAL REQUIREMENTS:
1. Return PURE JSON only - no ```json```, no markdown, no extra text
2. Include ALL subparameters from input data - don't skip any
3. Use the EXACT maxScore value from input (always 3 for these parameters)
4. Remember: For Stress and Burnout, LOW scores are GOOD, HIGH scores are CONCERNING
5. Each subparameter must have a score (0 or 1), interpretation, and optional details
6. Icons should be brain-related emojis: üß† üí° üéØ ‚ö° üòå üìö üé® or similar
7. Make interpretations relatable - focus on real-world meaning, not just EEG jargon
8. Ensure bucketColor uses valid hex codes
9. Overall tone: Professional yet warm, informative yet encouraging

‚ú® QUALITY CHECKLIST:
- Are all 7 parameters included?
- Do all parameters have their sub-metrics listed?
- Are interpretations written in simple, patient-friendly language?
- Is the color coding correct (especially for Stress/Burnout inverse scoring)?
- Does the summary provide a holistic view?
- Are recommendations specific and actionable?

Generate the report now based on the brain parameters data provided below.`;
  }

  /**
   * Generate brain performance report using Gemini AI
   * @param {Object} brainParameters - The 7 brain parameters with scores and buckets
   * @returns {Promise<Object>} Generated report structure
   */
  async generateBrainPerformanceReport(brainParameters) {
    try {
      console.log('\nüîë Checking Gemini API configuration...');
      console.log('   API Key exists:', !!this.apiKey);
      console.log('   API Key length:', this.apiKey ? this.apiKey.length : 0);
      console.log('   API Key preview:', this.apiKey ? `${this.apiKey.substring(0, 10)}...` : 'MISSING');

      if (!this.model) {
        console.log('üì± Initializing Gemini model...');
        await this.initModel();
      }

      console.log('ü§ñ Generating brain performance report with Gemini AI...');
      console.log('üìä Input parameters count:', Object.keys(brainParameters).length);

      // Create the prompt with system instructions and data
      const systemPrompt = this.getReportGenerationPrompt();
      const dataPrompt = `\n\nBrain Parameters Data:\n${JSON.stringify(brainParameters, null, 2)}\n\nPlease generate the infographic report description in JSON format as specified.`;

      const fullPrompt = systemPrompt + dataPrompt;
      console.log('üìù Prompt length:', fullPrompt.length, 'characters');

      // Generate content
      console.log('‚è≥ Calling Gemini API...');
      const result = await this.model.generateContent(fullPrompt);
      const response = await result.response;
      const text = response.text();

      console.log('‚úÖ Gemini response received!');
      console.log('   Response length:', text.length, 'characters');

      // Try to parse JSON from the response
      let reportData;
      try {
        // Remove markdown code blocks if present
        const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        reportData = JSON.parse(jsonText);
      } catch (parseError) {
        console.error('Failed to parse JSON response:', parseError);
        // Return raw text if JSON parsing fails
        reportData = {
          title: 'Brain Performance Report',
          rawContent: text,
          parameters: [],
          error: 'Failed to parse structured response'
        };
      }

      return {
        success: true,
        data: reportData,
        rawResponse: text
      };

    } catch (error) {
      console.error('\n‚ùå === GEMINI API ERROR ===');
      console.error('Error Type:', error.constructor.name);
      console.error('Error Message:', error.message);
      console.error('Error Code:', error.code || 'N/A');
      console.error('Error Status:', error.status || 'N/A');
      console.error('Full Error:', JSON.stringify(error, null, 2));
      console.error('Stack:', error.stack);
      console.error('==========================\n');

      return {
        success: false,
        error: error.message,
        errorDetails: {
          type: error.constructor.name,
          code: error.code,
          status: error.status
        },
        data: null
      };
    }
  }

  /**
   * Generate simple text completion
   * @param {string} prompt - The prompt text
   * @returns {Promise<string>} Generated text
   */
  async generateText(prompt) {
    try {
      if (!this.model) {
        await this.initModel();
      }

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text();

    } catch (error) {
      console.error('Error generating text with Gemini:', error);
      throw error;
    }
  }

  /**
   * Test Gemini API connection
   */
  async testConnection() {
    try {
      const response = await this.generateText('Hello! Please respond with "OK" if you can read this.');
      console.log('Gemini API test response:', response);
      return { success: true, response };
    } catch (error) {
      console.error('Gemini API test failed:', error);
      return { success: false, error: error.message };
    }
  }
}

module.exports = new GeminiService();
