const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const pdfParse = require('pdf-parse');
const XLSX = require('xlsx');

// Initialize Gemini AI client
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
let geminiModel = null;

// In-memory cache for PDF extraction results (ensures deterministic behavior)
// Key: PDF MD5 hash ‚Üí Value: Extracted QEEG data
const extractionCache = new Map();

// Cache statistics for monitoring
const cacheStats = {
  hits: 0,
  misses: 0,
  totalExtractions: 0
};

class QEEGParser {
  /**
   * Fetch available Gemini models that support generateContent
   * @returns {Promise<Array>} List of available models
   */
  static async fetchAvailableModels() {
    try {
      console.log('üîç Fetching available Gemini models...');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1/models?key=${process.env.GEMINI_API_KEY}`
      );

      if (!response.ok) {
        throw new Error(`API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      // Filter models that support generateContent
      const supportedModels = (data.models || []).filter(model =>
        model.supportedGenerationMethods?.includes('generateContent')
      );

      console.log(`‚úÖ Found ${supportedModels.length} models that support generateContent:`);
      supportedModels.forEach(model => {
        console.log(`   - ${model.name}`);
      });

      return supportedModels;
    } catch (error) {
      console.error('‚ùå Failed to fetch models:', error.message);
      return [];
    }
  }

  /**
   * Select best available model from list
   * @param {Array} models - List of available models
   * @returns {string|null} Model name to use
   */
  static selectBestModel(models) {
    if (!models || models.length === 0) return null;

    // Priority: flash models (fastest) > pro models > any other
    const preferences = ['flash', 'pro'];

    for (const preference of preferences) {
      const found = models.find(m =>
        m.name.toLowerCase().includes(preference)
      );
      if (found) {
        console.log(`‚úÖ Selected model: ${found.name}`);
        return found.name;
      }
    }

    // Fallback to first available
    console.log(`‚úÖ Using first available model: ${models[0].name}`);
    return models[0].name;
  }

  /**
   * Validate Gemini API key is configured and appears valid
   * @throws {Error} if API key is missing or invalid format
   */
  static validateAPIKey() {
    const apiKey = process.env.GEMINI_API_KEY;

    // Check if key exists
    if (!apiKey || apiKey.trim() === '') {
      const error = new Error('GEMINI_API_KEY environment variable is not set');
      error.code = 'MISSING_API_KEY';
      throw error;
    }

    // Check if key is placeholder
    if (apiKey === 'your-gemini-api-key-here' || apiKey.includes('placeholder')) {
      const error = new Error('GEMINI_API_KEY is set to placeholder value. Please configure a valid Gemini API key.');
      error.code = 'INVALID_API_KEY';
      throw error;
    }

    console.log('‚úÖ Gemini API key validation passed');
    return true;
  }

  /**
   * Test Gemini API connection with a simple request
   * @returns {Promise<boolean>} true if connection successful
   * @throws {Error} if connection fails
   */
  static async testAPIConnection() {
    try {
      this.validateAPIKey();

      console.log('üîå Testing Gemini API connection...');

      if (!geminiModel) {
        console.log('üîë API Key check:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          throw new Error('No Gemini models available. Check your API key at https://aistudio.google.com/apikey');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model');
        }

        // Initialize model with full path
        console.log(`üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({ model: modelName });

        // Test it with simple call
        console.log('üìû Testing model with simple call...');
        const testResult = await geminiModel.generateContent('Hello');
        await testResult.response;
        console.log('‚úÖ Model initialized and tested successfully');
      }

      const result = await geminiModel.generateContent('Reply with OK');
      const response = await result.response;
      const text = response.text();

      if (text) {
        console.log('‚úÖ Gemini API connection successful');
        return true;
      } else {
        throw new Error('Gemini API returned unexpected response');
      }

    } catch (error) {
      console.error('‚ùå Gemini API connection test failed:', error.message);
      const enhancedError = new Error(`Gemini API connection test failed: ${error.message}`);
      enhancedError.code = 'API_CONNECTION_FAILED';
      enhancedError.originalError = error;
      throw enhancedError;
    }
  }

  /**
   * Detect report type (raw power values or Z-scores)
   * @param {Object} file - Multer file object
   * @returns {Promise<string>} 'raw' or 'zscore'
   */
  static async detectReportType(file) {
    try {
      console.log(`üîç Detecting report type for: ${file.originalname}`);

      const dataBuffer = fs.readFileSync(file.path);
      const pdfData = await pdfParse(dataBuffer);
      const text = pdfData.text.toLowerCase();

      // Keyword detection
      const zscoreKeywords = ['z-score', 'z score', 'z =', 'z=', 'standard deviation', 'sd from mean'];
      const rawKeywords = ['absolute power (Œºv¬≤)', 'absolute power (uv¬≤)', 'relative power (%)', 'Œºv¬≤', 'uv¬≤'];

      let zscoreCount = 0;
      let rawCount = 0;

      // Count keyword occurrences
      zscoreKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        zscoreCount += matches;
      });

      rawKeywords.forEach(keyword => {
        const matches = (text.match(new RegExp(keyword, 'g')) || []).length;
        rawCount += matches;
      });

      console.log(`   Z-score keywords found: ${zscoreCount}`);
      console.log(`   Raw power keywords found: ${rawCount}`);

      // Decision logic
      if (zscoreCount > rawCount && zscoreCount >= 3) {
        console.log(`‚úÖ Detected: Z-SCORE report`);
        return 'zscore';
      } else if (rawCount > zscoreCount && rawCount >= 2) {
        console.log(`‚úÖ Detected: RAW POWER report`);
        return 'raw';
      } else if (zscoreCount > 0 && rawCount > 0) {
        // Mixed report - check for table structure
        if (text.includes('z-score table') || text.includes('z score table')) {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring Z-SCORE`);
          return 'zscore';
        } else {
          console.log(`‚ö†Ô∏è Mixed report detected - preferring RAW POWER`);
          return 'raw';
        }
      } else {
        // Fallback: assume raw if unclear
        console.warn(`‚ö†Ô∏è Could not clearly detect report type - defaulting to RAW POWER`);
        return 'raw';
      }

    } catch (error) {
      console.error(`‚ùå Error detecting report type for ${file.originalname}:`, error.message);
      // Safe default
      console.warn(`   Defaulting to RAW POWER mode`);
      return 'raw';
    }
  }

  /**
   * Main method to parse uploaded files
   * @param {Object} eyesOpenFile - Multer file object for Eyes Open data
   * @param {Object} eyesClosedFile - Multer file object for Eyes Closed data
   * @returns {Object} Parsed QEEG data
   */
  static async parse(eyesOpenFile, eyesClosedFile) {
    try {
      console.log('\nüìÑ === QEEG File Parsing Started ===');
      console.log('  - Eyes Open:', eyesOpenFile?.originalname);
      console.log('  - Eyes Closed:', eyesClosedFile?.originalname);

      // STEP 1: Detect report types
      console.log('\nüîç STEP 1: Detecting report types...');
      const eoReportType = await this.detectReportType(eyesOpenFile);
      const ecReportType = await this.detectReportType(eyesClosedFile);

      console.log(`\nüìä Detection Results:`);
      console.log(`  - Eyes Open: ${eoReportType.toUpperCase()}`);
      console.log(`  - Eyes Closed: ${ecReportType.toUpperCase()}`);

      // STEP 2: Validate matching types
      console.log('\n‚úì STEP 2: Validating report type consistency...');
      if (eoReportType !== ecReportType) {
        const error = new Error(
          `‚ùå Mismatched report types detected!\n\n` +
          `Eyes Open is ${eoReportType.toUpperCase()}, but Eyes Closed is ${ecReportType.toUpperCase()}.\n\n` +
          `Both files must be the same type (either both RAW POWER or both Z-SCORE reports).\n` +
          `Please upload matching report types and try again.`
        );
        error.code = 'REPORT_TYPE_MISMATCH';
        throw error;
      }

      const reportType = eoReportType;
      console.log(`‚úÖ Report type validated: ${reportType.toUpperCase()} mode\n`);

      // STEP 3: Determine file formats (pdf, csv, excel)
      console.log('üìÅ STEP 3: Determining file formats...');
      const eoFileType = this.getFileType(eyesOpenFile.originalname);
      const ecFileType = this.getFileType(eyesClosedFile.originalname);
      console.log(`  - Eyes Open: ${eoFileType}`);
      console.log(`  - Eyes Closed: ${ecFileType}\n`);

      // STEP 4: Parse each file with appropriate method
      console.log('üìñ STEP 4: Extracting data from files...');
      const eyesOpenData = await this.parseFile(eyesOpenFile, eoFileType, 'EO', reportType);
      const eyesClosedData = await this.parseFile(eyesClosedFile, ecFileType, 'EC', reportType);

      // STEP 5: Combine data with metadata
      console.log('\nüîó STEP 5: Combining data...');
      const combinedData = {
        EO: eyesOpenData,
        EC: eyesClosedData,
        dataType: reportType // Add metadata
      };

      console.log(`‚úÖ QEEG files parsed successfully in ${reportType.toUpperCase()} mode`);
      console.log('=== QEEG File Parsing Completed ===\n');
      return combinedData;

    } catch (error) {
      console.error('\n‚ùå === QEEG File Parsing Failed ===');
      console.error('Error:', error.message);
      if (error.code === 'REPORT_TYPE_MISMATCH') {
        // Re-throw mismatch errors with original message
        throw error;
      } else {
        throw new Error(`Failed to parse QEEG files: ${error.message}`);
      }
    }
  }

  /**
   * Determine file type from filename
   */
  static getFileType(filename) {
    const ext = path.extname(filename).toLowerCase();
    if (ext === '.pdf') return 'pdf';
    if (ext === '.csv') return 'csv';
    if (ext === '.xlsx' || ext === '.xls') return 'excel';
    throw new Error(`Unsupported file type: ${ext}`);
  }

  /**
   * Parse a single file based on its type
   */
  static async parseFile(file, fileType, condition, reportType = 'raw') {
    if (fileType === 'pdf') {
      return await this.parsePDF(file, condition, reportType);
    } else if (fileType === 'csv') {
      return this.parseCSV(file);
    } else if (fileType === 'excel') {
      return this.parseExcel(file);
    }
    throw new Error(`Unknown file type: ${fileType}`);
  }

  /**
   * Get extraction prompt based on report type
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   * @param {string} pdfText - PDF text content
   * @returns {string} Extraction prompt
   */
  static getExtractionPrompt(condition, reportType, pdfText) {
    const conditionName = condition === 'EO' ? 'Eyes Open' : 'Eyes Closed';

    if (reportType === 'zscore') {
      // Z-SCORE extraction prompt
      return `You are a QEEG Z-score data extraction expert. Extract Z-score values from this ${conditionName} QEEG report.

**IMPORTANT**: Z-scores represent standard deviations from the mean. They typically range from -3 to +3.
- Negative values = below average (lower than normal)
- Zero (0) = average (normal)
- Positive values = above average (higher than normal)

Look for tables labeled with "Z-score", "Z score", "Z", or "Standard Deviation" in the headers.

Extract Z-score values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract Z-scores for these frequency bands:
- Delta (1-4 Hz)
- Theta (4-8 Hz)
- Alpha (8-13 Hz)
- Beta (13-30 Hz)
- HiBeta / High Beta (20-30 Hz)

Also extract:
- Alpha Peak Frequency (Hz) and its Z-score if available

If you cannot find Z-scores for a particular channel or band, use 0.0 as the default value.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return ONLY this EXACT JSON format:
{
  "zscores": {
    "absolute": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    },
    "relative": {
      "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
      "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
    }
  },
  "special": {
    "alphaPeak": 10.0,
    "alphaPeakZscore": 0.0
  }
}

PDF Content:
${pdfText.substring(0, 15000)}`;

    } else {
      // RAW POWER extraction prompt (existing)
      return `You are a QEEG data extraction expert. Extract the following data from this ${conditionName} QEEG report:

Extract two tables:
1. **Absolute Power (ŒºV¬≤)** table
2. **Relative Power (%)** table

For each table, extract values for these EEG channels: FP1, FP2, F7, F3, Fz, F4, F8, T3, C3, Cz, C4, T4, T5, P3, Pz, P4, T6, O1, O2

For each channel, extract values for these frequency bands:
- Delta
- Theta
- Alpha
- Beta
- HiBeta (High Beta)

Also extract Alpha Peak Frequency (APF) if available.

**CRITICAL**: Your response must be ONLY the JSON object. Do NOT include:
- No markdown formatting (no \`\`\`json or \`\`\`)
- No explanations before or after
- No comments
- Just pure JSON that starts with { and ends with }

Return the data in this EXACT JSON format:
{
  "absolute": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "relative": {
    "Fz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Cz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "Pz": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "F4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "C4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P3": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 },
    "P4": { "Delta": 0.0, "Theta": 0.0, "Alpha": 0.0, "Beta": 0.0, "HiBeta": 0.0 }
  },
  "special": {
    "alphaPeak": 10.0,
    "O1": 10.0
  }
}

PDF Content:
${pdfText.substring(0, 15000)}`;
    }
  }

  /**
   * Calculate MD5 hash of PDF file for caching
   * @param {Buffer} dataBuffer - PDF file buffer
   * @returns {string} MD5 hash
   */
  static calculatePDFHash(dataBuffer) {
    return crypto.createHash('md5').update(dataBuffer).digest('hex');
  }

  /**
   * Normalize extracted value to consistent decimal places
   * Prevents precision-related variations
   * @param {number} value - The value to normalize
   * @param {number} decimalPlaces - Number of decimal places (default: 2)
   * @returns {number|null} Normalized value
   */
  static normalizeValue(value, decimalPlaces = 2) {
    if (value === null || value === undefined || isNaN(value)) {
      return null;
    }

    // Round to consistent decimal places
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.round(value * multiplier) / multiplier;
  }

  /**
   * Normalize all values in extracted QEEG data
   * Ensures consistent precision across all measurements
   * @param {Object} extractedData - The raw extracted data
   * @returns {Object} Normalized data
   */
  static normalizeExtractedData(extractedData) {
    const normalized = JSON.parse(JSON.stringify(extractedData)); // Deep clone

    // Normalize absolute power values
    if (normalized.absolute) {
      Object.keys(normalized.absolute).forEach(channel => {
        Object.keys(normalized.absolute[channel]).forEach(band => {
          normalized.absolute[channel][band] =
            this.normalizeValue(normalized.absolute[channel][band], 2);
        });
      });
    }

    // Normalize relative power values
    if (normalized.relative) {
      Object.keys(normalized.relative).forEach(channel => {
        Object.keys(normalized.relative[channel]).forEach(band => {
          normalized.relative[channel][band] =
            this.normalizeValue(normalized.relative[channel][band], 2);
        });
      });
    }

    // Normalize special values (alpha peak, etc.)
    if (normalized.special) {
      Object.keys(normalized.special).forEach(key => {
        normalized.special[key] = this.normalizeValue(normalized.special[key], 2);
      });
    }

    // Normalize zscores if present (for z-score reports)
    if (normalized.zscores) {
      if (normalized.zscores.absolute) {
        Object.keys(normalized.zscores.absolute).forEach(channel => {
          Object.keys(normalized.zscores.absolute[channel]).forEach(band => {
            normalized.zscores.absolute[channel][band] =
              this.normalizeValue(normalized.zscores.absolute[channel][band], 2);
          });
        });
      }
      if (normalized.zscores.relative) {
        Object.keys(normalized.zscores.relative).forEach(channel => {
          Object.keys(normalized.zscores.relative[channel]).forEach(band => {
            normalized.zscores.relative[channel][band] =
              this.normalizeValue(normalized.zscores.relative[channel][band], 2);
          });
        });
      }
    }

    return normalized;
  }

  /**
   * Parse PDF file using Gemini AI with caching for deterministic results
   * @param {Object} file - Multer file object
   * @param {string} condition - 'EO' or 'EC'
   * @param {string} reportType - 'raw' or 'zscore'
   */
  static async parsePDF(file, condition, reportType = 'raw') {
    console.log(`  üîç Parsing PDF with Gemini AI (${condition}, ${reportType.toUpperCase()} mode)...`);

    try {
      // Validate API key before attempting to use it
      this.validateAPIKey();

      // Read PDF file
      const dataBuffer = fs.readFileSync(file.path);

      // Calculate PDF hash for caching (ensures same PDF = same result)
      const pdfHash = this.calculatePDFHash(dataBuffer);
      const cacheKey = `${pdfHash}_${condition}_${reportType}`;

      console.log(`  üîë PDF Hash: ${pdfHash.substring(0, 12)}... (for deterministic caching)`);

      // Check cache first
      if (extractionCache.has(cacheKey)) {
        cacheStats.hits++;
        cacheStats.totalExtractions++;
        console.log(`  ‚úÖ CACHE HIT! Using cached extraction result (100% deterministic)`);
        console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses, ${((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1)}% hit rate`);
        return extractionCache.get(cacheKey);
      }

      cacheStats.misses++;
      cacheStats.totalExtractions++;
      console.log(`  ‚ö†Ô∏è  Cache miss - extracting data with Gemini AI...`);
      console.log(`  üìä Cache Stats: ${cacheStats.hits} hits, ${cacheStats.misses} misses`);

      const pdfData = await pdfParse(dataBuffer);

      // Extract text from PDF
      const pdfText = pdfData.text;

      // Get appropriate extraction prompt based on report type
      const prompt = this.getExtractionPrompt(condition, reportType, pdfText);

      // Initialize Gemini model if not already done
      if (!geminiModel) {
        console.log('  üîß Initializing Gemini model for data extraction...');
        console.log('  üîë API Key status:', process.env.GEMINI_API_KEY ? 'Present' : 'MISSING');
        console.log('  üîë API Key length:', process.env.GEMINI_API_KEY?.length || 0);
        console.log('  üîë API Key preview:', process.env.GEMINI_API_KEY ? `${process.env.GEMINI_API_KEY.substring(0, 20)}...` : 'N/A');

        // Fetch available models dynamically
        const availableModels = await this.fetchAvailableModels();

        if (availableModels.length === 0) {
          console.error('\n  ‚ùå === NO MODELS AVAILABLE ===');
          console.error('  Please check:');
          console.error('  1. GEMINI_API_KEY is correct in .env file');
          console.error('  2. API key has proper permissions');
          console.error('  3. Visit: https://aistudio.google.com/apikey to get a new key');
          console.error('  4. Make sure Generative Language API is enabled');
          console.error('  ================================\n');
          throw new Error('No Gemini models available. Check your API key.');
        }

        // Select best model
        const modelName = this.selectBestModel(availableModels);

        if (!modelName) {
          throw new Error('Could not select a valid model from available models');
        }

        // Initialize model with full path and deterministic config
        console.log(`  üîß Initializing model: ${modelName}`);
        geminiModel = genAI.getGenerativeModel({
          model: modelName,
          generationConfig: {
            temperature: 0,      // Minimum randomness for deterministic extraction
            topK: 1,            // Only pick most likely token
            topP: 1             // No nucleus sampling
          }
        });

        // Test the model with a simple call
        console.log(`  üìû Testing ${modelName} with simple call...`);
        try {
          const testResult = await geminiModel.generateContent('Hello');
          const testResponse = await testResult.response;
          const testText = testResponse.text();

          console.log(`  ‚úÖ Model initialized and tested successfully`);
          console.log(`  üìù Test response: ${testText.substring(0, 50)}...`);
        } catch (testError) {
          console.error(`  ‚ùå Model test failed:`, testError.message);
          throw new Error(`Failed to test model ${modelName}: ${testError.message}`);
        }
      }

      console.log(`  ü§ñ Using Gemini AI for data extraction (${condition})...`);

      // Call Gemini API
      const result = await geminiModel.generateContent(prompt);
      const response = await result.response;
      const text = response.text();

      console.log(`  üìù Gemini response received (${condition}), length: ${text.length} characters`);

      // Parse JSON from response (remove markdown code blocks if present)
      let extractedData;
      try {
        const jsonText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const rawData = JSON.parse(jsonText);

        // üîß NORMALIZE all values to consistent decimal places
        // This ensures minor extraction variations don't affect calculations
        extractedData = this.normalizeExtractedData(rawData);

        console.log(`  ‚úÖ PDF data extracted and normalized successfully (${condition})`);
      } catch (parseError) {
        console.error(`  ‚ùå Failed to parse JSON from Gemini response (${condition}):`, parseError.message);
        console.error(`  üìÑ Raw response:`, text.substring(0, 500));
        throw new Error(`Failed to parse JSON from Gemini response: ${parseError.message}`);
      }

      // Add detailed logging
      console.log(`  üìä Data extraction summary (${condition}):`);
      console.log(`     - Absolute power channels: ${Object.keys(extractedData.absolute || {}).length}`);
      console.log(`     - Relative power channels: ${Object.keys(extractedData.relative || {}).length}`);
      console.log(`     - Special values: ${JSON.stringify(extractedData.special || {})}`);

      // Log sample extracted values for verification (prove it's real patient data, not static)
      console.log(`\n  üìã Sample Extracted Values (${condition}) - Proof of Dynamic Extraction:`);
      if (extractedData.absolute?.Fz) {
        console.log(`     - Fz Absolute: Theta=${extractedData.absolute.Fz.Theta}, Beta=${extractedData.absolute.Fz.Beta}`);
      }
      if (extractedData.absolute?.Pz) {
        console.log(`     - Pz Absolute: Alpha=${extractedData.absolute.Pz.Alpha}, HiBeta=${extractedData.absolute.Pz.HiBeta}`);
      }
      if (extractedData.relative?.Pz) {
        console.log(`     - Pz Relative: Alpha=${extractedData.relative.Pz.Alpha}, Beta=${extractedData.relative.Pz.Beta}`);
      }
      if (extractedData.absolute?.F3 && extractedData.absolute?.F4) {
        console.log(`     - F3/F4 Absolute Alpha: F3=${extractedData.absolute.F3.Alpha}, F4=${extractedData.absolute.F4.Alpha}`);
      }
      if (extractedData.special?.alphaPeak) {
        console.log(`     - Alpha Peak Frequency: ${extractedData.special.alphaPeak} Hz`);
      }

      // Validate extracted data has minimum required fields
      const requiredChannels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
      const absoluteChannels = Object.keys(extractedData.absolute || {});
      const relativeChannels = Object.keys(extractedData.relative || {});

      const missingAbsolute = requiredChannels.filter(ch => !absoluteChannels.includes(ch));
      const missingRelative = requiredChannels.filter(ch => !relativeChannels.includes(ch));

      if (missingAbsolute.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing absolute power channels: ${missingAbsolute.join(', ')}`);
      }
      if (missingRelative.length > 0) {
        console.warn(`  ‚ö†Ô∏è  Missing relative power channels: ${missingRelative.join(', ')}`);
      }

      // ‚úÖ CACHE the extraction result for deterministic behavior
      // Same PDF will now ALWAYS return the same values
      extractionCache.set(cacheKey, extractedData);
      console.log(`  üíæ Extraction result cached (key: ${pdfHash.substring(0, 12)}...)`);
      console.log(`  üìä Cache size: ${extractionCache.size} entries`);

      return extractedData;

    } catch (error) {
      console.error(`  ‚ùå Gemini API error (${condition}):`, error.message);

      // Log more details for debugging
      if (error.response) {
        console.error(`  ‚ùå Gemini API Status:`, error.response?.status);
        console.error(`  ‚ùå Gemini API Error:`, error.response?.data);
      }

      console.error(`  üìÑ Error stack:`, error.stack);

      // Re-throw with more context
      const enhancedError = new Error(`Failed to extract QEEG data from PDF using Gemini (${condition}): ${error.message}`);
      enhancedError.code = 'PDF_EXTRACTION_FAILED';
      enhancedError.originalError = error;
      enhancedError.condition = condition;
      throw enhancedError;
    }
  }

  /**
   * Parse CSV file
   */
  static parseCSV(file) {
    console.log('  üìä Parsing CSV file...');

    // Read CSV file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert CSV data to our format
    const data = this.convertCSVToFormat(jsonData);

    console.log('  ‚úÖ CSV parsed successfully');
    return data;
  }

  /**
   * Parse Excel file
   */
  static parseExcel(file) {
    console.log('  üìä Parsing Excel file...');

    // Read Excel file
    const workbook = XLSX.readFile(file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Convert Excel data to our format
    const data = this.convertExcelToFormat(jsonData);

    console.log('  ‚úÖ Excel parsed successfully');
    return data;
  }

  /**
   * Convert CSV data to expected format
   */
  static convertCSVToFormat(csvData) {
    // Assuming CSV has structure: Channel, PowerType, Delta, Theta, Alpha, Beta, HiBeta
    const result = {
      absolute: {},
      relative: {},
      special: { alphaPeak: 10.0, O1: 10.0 }
    };

    const channels = ['Fz', 'Cz', 'Pz', 'F3', 'F4', 'C3', 'C4', 'P3', 'P4'];
    const bands = ['Delta', 'Theta', 'Alpha', 'Beta', 'HiBeta'];

    for (const row of csvData) {
      const channel = row.Channel;
      const powerType = row.PowerType?.toLowerCase();

      if (channels.includes(channel) && (powerType === 'absolute' || powerType === 'relative')) {
        result[powerType][channel] = {
          Delta: parseFloat(row.Delta) || 0,
          Theta: parseFloat(row.Theta) || 0,
          Alpha: parseFloat(row.Alpha) || 0,
          Beta: parseFloat(row.Beta) || 0,
          HiBeta: parseFloat(row.HiBeta || row.HighBeta) || 0
        };
      }
    }

    return result;
  }

  /**
   * Convert Excel data to expected format (same as CSV for now)
   */
  static convertExcelToFormat(excelData) {
    return this.convertCSVToFormat(excelData);
  }

  /**
   * Get cache statistics
   * @returns {Object} Cache statistics
   */
  static getCacheStats() {
    return {
      ...cacheStats,
      cacheSize: extractionCache.size,
      hitRate: cacheStats.totalExtractions > 0
        ? ((cacheStats.hits / cacheStats.totalExtractions) * 100).toFixed(1) + '%'
        : '0%'
    };
  }

  /**
   * Clear extraction cache (useful for testing or memory management)
   * @param {string} pdfHash - Optional: Clear specific PDF hash, or all if not provided
   */
  static clearCache(pdfHash = null) {
    if (pdfHash) {
      // Clear specific PDF
      let cleared = 0;
      for (const key of extractionCache.keys()) {
        if (key.startsWith(pdfHash)) {
          extractionCache.delete(key);
          cleared++;
        }
      }
      console.log(`üóëÔ∏è  Cleared ${cleared} cache entries for PDF hash: ${pdfHash.substring(0, 12)}...`);
    } else {
      // Clear all
      const size = extractionCache.size;
      extractionCache.clear();
      cacheStats.hits = 0;
      cacheStats.misses = 0;
      cacheStats.totalExtractions = 0;
      console.log(`üóëÔ∏è  Cleared entire extraction cache (${size} entries)`);
    }
  }
}

module.exports = QEEGParser;
