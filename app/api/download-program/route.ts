import { NextRequest, NextResponse } from 'next/server';

interface DownloadRequest {
  programCode: string;
  platform: string;
  plcModel: string;
  language: 'LD' | 'ST' | 'IL' | 'FBD' | 'SFC';
  projectName: string;
}

export async function POST(req: NextRequest) {
  try {
    const body: DownloadRequest = await req.json();
    const { programCode, platform, plcModel, language, projectName } = body;

    // Generate appropriate file format based on platform
    const fileData = generatePlatformFile(programCode, platform, plcModel, language, projectName);

    // Return file with appropriate headers
    return new NextResponse(fileData.content, {
      headers: {
        'Content-Type': fileData.mimeType,
        'Content-Disposition': `attachment; filename="${fileData.filename}"`,
      },
    });
  } catch (error) {
    console.error('Error generating download:', error);
    return NextResponse.json(
      { error: 'Failed to generate downloadable file' },
      { status: 500 }
    );
  }
}

function generatePlatformFile(
  code: string,
  platform: string,
  plcModel: string,
  language: string,
  projectName: string
): { content: string; filename: string; mimeType: string } {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const safeName = projectName.replace(/[^a-zA-Z0-9_-]/g, '_');

  switch (platform.toLowerCase()) {
    case 'schneider':
    case 'schneider electric':
      return generateSchneiderFile(code, plcModel, language, safeName, timestamp);

    case 'siemens':
      return generateSiemensFile(code, plcModel, language, safeName, timestamp);

    case 'rockwell':
    case 'allen-bradley':
      return generateRockwellFile(code, plcModel, language, safeName, timestamp);

    case 'mitsubishi':
      return generateMitsubishiFile(code, plcModel, language, safeName, timestamp);

    case 'codesys':
      return generateCodesysFile(code, plcModel, language, safeName, timestamp);

    default:
      return generateGenericFile(code, platform, language, safeName, timestamp);
  }
}

function generateSchneiderFile(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // EcoStruxure Machine Expert Basic uses PLCopen XML format
  const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0201"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xsi:schemaLocation="http://www.plcopen.org/xml/tc6_0201">
  <fileHeader companyName="PLCAutoPilot"
              productName="EcoStruxure Machine Expert - Basic"
              productVersion="2.0"
              productRelease=""
              creationDateTime="${new Date().toISOString()}"
              contentDescription="${projectName}"/>

  <contentHeader name="${projectName}"
                 modificationDateTime="${new Date().toISOString()}">
    <coordinateInfo>
      <fbd><scaling x="1" y="1"/></fbd>
      <ld><scaling x="1" y="1"/></ld>
      <sfc><scaling x="1" y="1"/></sfc>
    </coordinateInfo>
  </contentHeader>

  <types>
    <dataTypes/>
    <pous>
      <pou name="PLC_PRG" pouType="program">
        <interface>
          <localVars>
            <!-- Variables extracted from program -->
          </localVars>
        </interface>
        <body>
          <${language.toLowerCase()}>
            ${escapeXml(code)}
          </${language.toLowerCase()}>
        </body>
      </pou>
    </pous>
  </types>

  <instances>
    <configurations>
      <configuration name="${plcModel}">
        <resource name="Application">
          <task name="PlcTask" interval="PT0.01S" priority="1">
            <pouInstance name="PLC_PRG" typeName="PLC_PRG"/>
          </task>
        </resource>
      </configuration>
    </configurations>
  </instances>

  <addData>
    <data name="generatedBy" value="PLCAutoPilot" />
    <data name="timestamp" value="${timestamp}" />
    <data name="targetPLC" value="${plcModel}" />
  </addData>
</project>`;

  return {
    content: xmlContent,
    filename: `${projectName}_${plcModel}_${timestamp}.smbp`,
    mimeType: 'application/octet-stream',
  };
}

function generateSiemensFile(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // TIA Portal uses .scl (for ST) or .awl (for IL) format
  let fileExt = 'scl';
  let header = '';

  if (language === 'ST') {
    fileExt = 'scl';
    header = `// Generated by PLCAutoPilot
// Project: ${projectName}
// Target: ${plcModel}
// Date: ${new Date().toISOString()}

FUNCTION_BLOCK "${projectName}"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
`;
  } else if (language === 'IL') {
    fileExt = 'awl';
    header = `// Generated by PLCAutoPilot
// Project: ${projectName}
// Target: ${plcModel}
// Date: ${new Date().toISOString()}

FUNCTION_BLOCK "${projectName}"
TITLE = 'PLC Program'
VERSION : 0.1
`;
  } else {
    // For LD/FBD, generate XML format
    return generateSiemensXML(code, plcModel, language, projectName, timestamp);
  }

  const content = `${header}

BEGIN
${code}
END_FUNCTION_BLOCK`;

  return {
    content,
    filename: `${projectName}_${plcModel}_${timestamp}.${fileExt}`,
    mimeType: 'text/plain',
  };
}

function generateSiemensXML(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  const xmlContent = `<?xml version="1.0" encoding="utf-8"?>
<Document>
  <Engineering version="V17" />
  <SW.Blocks.FB ID="0">
    <AttributeList>
      <Name>${projectName}</Name>
      <Number>1</Number>
      <ProgrammingLanguage>${language}</ProgrammingLanguage>
    </AttributeList>
    <ObjectList>
      <SW.Blocks.CompileUnit>
        <AttributeList>
          <NetworkSource>
            <FlgNet xmlns="http://www.siemens.com/automation/Openness/SW/NetworkSource/FlgNet/v4">
              ${escapeXml(code)}
            </FlgNet>
          </NetworkSource>
        </AttributeList>
      </SW.Blocks.CompileUnit>
    </ObjectList>
  </SW.Blocks.FB>
</Document>`;

  return {
    content: xmlContent,
    filename: `${projectName}_${plcModel}_${timestamp}.xml`,
    mimeType: 'application/xml',
  };
}

function generateRockwellFile(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // Rockwell uses .L5X format (XML)
  const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<RSLogix5000Content SchemaRevision="1.0"
                    SoftwareRevision="32.00"
                    TargetName="${plcModel}"
                    TargetType="Controller"
                    ContainsContext="true">

  <Controller Use="Context" Name="${projectName}">
    <Programs>
      <Program Use="Context" Name="MainProgram">
        <Routines>
          <Routine Use="Context" Name="MainRoutine" Type="${language === 'LD' ? 'RLL' : 'ST'}">
            <RLLContent>
              <Rung Number="0" Type="N">
                <Comment><![CDATA[Generated by PLCAutoPilot - ${timestamp}]]></Comment>
                <Text><![CDATA[${escapeXml(code)}]]></Text>
              </Rung>
            </RLLContent>
          </Routine>
        </Routines>
      </Program>
    </Programs>

    <Tags>
      <Tag Name="GeneratedBy" TagType="Base" DataType="STRING" Constant="true">
        <Data>PLCAutoPilot</Data>
      </Tag>
      <Tag Name="GeneratedDate" TagType="Base" DataType="STRING" Constant="true">
        <Data>${timestamp}</Data>
      </Tag>
    </Tags>
  </Controller>
</RSLogix5000Content>`;

  return {
    content: xmlContent,
    filename: `${projectName}_${plcModel}_${timestamp}.L5X`,
    mimeType: 'application/xml',
  };
}

function generateMitsubishiFile(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // Mitsubishi GX Works uses .gxw format (proprietary binary)
  // We'll generate a text format that can be imported
  const content = `'******************************************************************************
' Project: ${projectName}
' Target PLC: ${plcModel}
' Generated: ${timestamp}
' Generated by: PLCAutoPilot
'******************************************************************************

${code}

'******************************************************************************
' End of Program
'******************************************************************************`;

  return {
    content,
    filename: `${projectName}_${plcModel}_${timestamp}.txt`,
    mimeType: 'text/plain',
  };
}

function generateCodesysFile(
  code: string,
  plcModel: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // CODESYS uses .export format
  const content = `<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0200">
  <fileHeader companyName="PLCAutoPilot"
              productName="CODESYS"
              productVersion="3.5"
              creationDateTime="${new Date().toISOString()}" />

  <contentHeader name="${projectName}"
                 modificationDateTime="${new Date().toISOString()}">
    <coordinateInfo>
      <fbd><scaling x="1" y="1"/></fbd>
      <ld><scaling x="1" y="1"/></ld>
      <sfc><scaling x="1" y="1"/></sfc>
    </coordinateInfo>
  </contentHeader>

  <types>
    <pous>
      <pou name="PLC_PRG" pouType="program">
        <interface>
          <localVars />
        </interface>
        <body>
          <${language.toLowerCase()}>
            ${escapeXml(code)}
          </${language.toLowerCase()}>
        </body>
      </pou>
    </pous>
  </types>

  <instances>
    <configurations>
      <configuration name="${plcModel}">
        <resource name="Application">
          <task name="Task0" interval="t#10ms" priority="1">
            <pouInstance name="PLC_PRG" typeName="PLC_PRG" />
          </task>
        </resource>
      </configuration>
    </configurations>
  </instances>
</project>`;

  return {
    content,
    filename: `${projectName}_${plcModel}_${timestamp}.export`,
    mimeType: 'application/xml',
  };
}

function generateGenericFile(
  code: string,
  platform: string,
  language: string,
  projectName: string,
  timestamp: string
): { content: string; filename: string; mimeType: string } {
  // Generic IEC 61131-3 format
  const content = `(*******************************************************************************
 * Project: ${projectName}
 * Platform: ${platform}
 * Language: ${language}
 * Generated: ${timestamp}
 * Generated by: PLCAutoPilot
 *******************************************************************************)

PROGRAM PLC_PRG
VAR
  (* Variables will be declared here *)
END_VAR

(* Main Program Logic *)
${code}

END_PROGRAM

(*******************************************************************************
 * End of Program
 *******************************************************************************)`;

  return {
    content,
    filename: `${projectName}_${timestamp}.st`,
    mimeType: 'text/plain',
  };
}

function escapeXml(unsafe: string): string {
  return unsafe
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}
