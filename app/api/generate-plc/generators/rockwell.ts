// Simple model interface for generation
interface PLCModelSimple {
  manufacturer: string;
  series: string;
  model: string;
  fileExtension: string;
}

export async function generateRockwellProgram(logic: string, model: PLCModelSimple) {
  const requirements = parseLogic(logic);
  const content = generateRSLogixContent(requirements, model);
  const filename = `${requirements.projectName || 'PLC_Program'}_${model.model}${model.fileExtension}`;

  return { content, filename };
}

function parseLogic(logic: string): any {
  const lightMatch = logic.match(/(\d+)\s+(?:sequential\s+)?lights?/i);
  const timeMatch = logic.match(/(\d+)\s+seconds?/i);

  return {
    projectName: extractProjectName(logic),
    numLights: lightMatch ? parseInt(lightMatch[1]) : 3,
    delaySeconds: timeMatch ? parseInt(timeMatch[1]) : 3,
    rawLogic: logic,
  };
}

function extractProjectName(logic: string): string {
  const nameMatch = logic.match(/(?:project|program|name):\s*([^\n.]+)/i);
  return nameMatch
    ? nameMatch[1].trim().replace(/[^a-zA-Z0-9_]/g, '_')
    : 'Sequential_Program';
}

function generateRSLogixContent(requirements: any, model: PLCModelSimple): string {
  // Generate Ladder Logic in text format for Rockwell
  const { numLights, delaySeconds, projectName } = requirements;

  return `; Rockwell Automation ${model.model} Program
; Generated by PLCAutoPilot
; Project: ${projectName}
; Description: ${requirements.rawLogic}

;--------------------------------------------------------------------
; MAIN PROGRAM - Sequential Lights Control
;--------------------------------------------------------------------

;--------------------------------------------------------------------
; Rung 0: Start/Stop Control with Seal-in
;--------------------------------------------------------------------
; |--[START_BTN]--+--]/[STOP_BTN]--(SEQUENCE_RUN)--|
; |               |                                 |
; |--[SEQ_RUN]----+                                 |
;
LD      I:0/0              ; START button
OR      B3:0/0             ; Seal-in (SEQUENCE_RUN)
ANDN    I:0/1              ; NOT STOP button
OTE     B3:0/0             ; Output to SEQUENCE_RUN

;--------------------------------------------------------------------
; Rung 1: Light 1 - Immediate Activation
;--------------------------------------------------------------------
; |--[SEQUENCE_RUN]--(LIGHT_1)--|
;
LD      B3:0/0             ; SEQUENCE_RUN
OTE     O:0/0              ; LIGHT_1

${generateRockwellTimerRungs(numLights, delaySeconds)}

;--------------------------------------------------------------------
; END OF PROGRAM
;--------------------------------------------------------------------
`;
}

function generateRockwellTimerRungs(numLights: number, delaySeconds: number): string {
  let rungs = '';
  let rungNum = 2;

  for (let i = 1; i < numLights; i++) {
    const timerIdx = i - 1;
    const lightIdx = i;
    const inputAddr = timerIdx === 0 ? 'B3:0/0' : `T4:${timerIdx - 1}.DN`;

    rungs += `
;--------------------------------------------------------------------
; Rung ${rungNum}: Timer ${timerIdx + 1} (${delaySeconds} seconds)
;--------------------------------------------------------------------
; |--[INPUT_COND]--[TON T4:${timerIdx}]--|
;                  Preset: ${delaySeconds}s
LD      ${inputAddr}
TON     T4:${timerIdx}
        ${delaySeconds * 1000}    ; Preset in ms
        1000                       ; Time base

;--------------------------------------------------------------------
; Rung ${rungNum + 1}: Light ${lightIdx + 1} - Activate after Timer ${timerIdx + 1}
;--------------------------------------------------------------------
; |--[T4:${timerIdx}.DN]--(LIGHT_${lightIdx + 1})--|
;
LD      T4:${timerIdx}.DN
OTE     O:0/${lightIdx}    ; LIGHT_${lightIdx + 1}
`;
    rungNum += 2;
  }

  return rungs;
}
