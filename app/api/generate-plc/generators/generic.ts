import { PLCModel } from '../../../data/plc-models';

export async function generateGenericProgram(logic: string, model: PLCModel) {
  const requirements = parseLogic(logic);
  const content = generateIEC61131Content(requirements, model);
  const filename = `${requirements.projectName || 'PLC_Program'}_${model.model}${model.fileExtension}`;

  return { content, filename };
}

function parseLogic(logic: string): any {
  const lightMatch = logic.match(/(\d+)\s+(?:sequential\s+)?lights?/i);
  const timeMatch = logic.match(/(\d+)\s+seconds?/i);

  return {
    projectName: extractProjectName(logic),
    numLights: lightMatch ? parseInt(lightMatch[1]) : 3,
    delaySeconds: timeMatch ? parseInt(timeMatch[1]) : 3,
    rawLogic: logic,
  };
}

function extractProjectName(logic: string): string {
  const nameMatch = logic.match(/(?:project|program|name):\s*([^\n.]+)/i);
  return nameMatch
    ? nameMatch[1].trim().replace(/[^a-zA-Z0-9_]/g, '_')
    : 'Sequential_Program';
}

function generateIEC61131Content(requirements: any, model: PLCModel): string {
  // Generate IEC 61131-3 Structured Text (universal format)
  const { numLights, delaySeconds, projectName } = requirements;

  return `(* ${model.manufacturer} ${model.model} Program *)
(* Generated by PLCAutoPilot - IEC 61131-3 Structured Text *)
(* Project: ${projectName} *)
(* Description: ${requirements.rawLogic} *)
(* Compatible with: ${model.programmingLanguages.join(', ')} *)

PROGRAM Sequential_Lights_Control
VAR
  (* Inputs *)
  START_BTN AT %IX0.0 : BOOL;
  STOP_BTN AT %IX0.1 : BOOL;

  (* Outputs *)
  ${Array.from({ length: numLights }, (_, i) => `LIGHT_${i + 1} AT %QX0.${i} : BOOL;`).join('\n  ')}

  (* Internal Variables *)
  SEQUENCE_RUN : BOOL := FALSE;
  ${Array.from({ length: numLights - 1 }, (_, i) => `TIMER_${i + 1} : TON;`).join('\n  ')}
END_VAR

(*--------------------------------------------------------------------*)
(* Main Program Logic *)
(*--------------------------------------------------------------------*)

(* Start/Stop Control with Seal-in *)
SEQUENCE_RUN := (START_BTN OR SEQUENCE_RUN) AND NOT STOP_BTN;

(* Light 1 - Immediate Activation *)
LIGHT_1 := SEQUENCE_RUN;

${generateIEC61131TimerLogic(numLights, delaySeconds)}

END_PROGRAM


(*====================================================================*)
(* LADDER DIAGRAM EQUIVALENT *)
(*====================================================================*)
(*
  Rung 0: Start/Stop Control
  |--[START]--+--]/[STOP]--(SEQUENCE_RUN)--|
  |           |                             |
  |--[SEQ]----+                             |

  Rung 1: Light 1 (Immediate)
  |--[SEQUENCE_RUN]--(LIGHT_1)--|

${generateLadderDiagram(numLights)}
*)

(*====================================================================*)
(* I/O ASSIGNMENT *)
(*====================================================================*)
(*
  INPUTS:
    %IX0.0 - START_BTN (Start Button)
    %IX0.1 - STOP_BTN (Stop Button)

  OUTPUTS:
    ${Array.from({ length: numLights }, (_, i) => `%QX0.${i} - LIGHT_${i + 1} (Light ${i + 1})`).join('\n    ')}

  TIMERS:
    ${Array.from({ length: numLights - 1 }, (_, i) => `TIMER_${i + 1} - ${delaySeconds}s delay`).join('\n    ')}
*)

(*====================================================================*)
(* FUNCTION BLOCKS *)
(*====================================================================*)

(* Timer On Delay (TON) Function Block *)
(* Standard IEC 61131-3 Timer *)
(*
  TIMER_x(IN := condition,
          PT := T#${delaySeconds}S);
  Output: TIMER_x.Q (Done bit)
*)

(* End of Program *)
`;
}

function generateIEC61131TimerLogic(numLights: number, delaySeconds: number): string {
  let logic = '';

  for (let i = 1; i < numLights; i++) {
    const timerIdx = i - 1;
    const lightIdx = i;
    const inputCond = timerIdx === 0 ? 'SEQUENCE_RUN' : `TIMER_${timerIdx}.Q`;

    logic += `
(* Timer ${timerIdx + 1} + Light ${lightIdx + 1} - Activate after ${(timerIdx + 1) * delaySeconds} seconds *)
TIMER_${timerIdx + 1}(IN := ${inputCond},
                     PT := T#${delaySeconds}S);
LIGHT_${lightIdx + 1} := TIMER_${timerIdx + 1}.Q;
`;
  }

  return logic;
}

function generateLadderDiagram(numLights: number): string {
  let ladder = '';

  for (let i = 1; i < numLights; i++) {
    const timerIdx = i - 1;
    const lightIdx = i;
    const inputCond = timerIdx === 0 ? 'SEQUENCE_RUN' : `TIMER_${timerIdx}.Q`;

    ladder += `
  Rung ${i + 1}: Timer ${timerIdx + 1} + Light ${lightIdx + 1}
  |--[${inputCond}]--[TIMER_${timerIdx + 1}]--(LIGHT_${lightIdx + 1})--|
`;
  }

  return ladder;
}
