import { PLCModel } from '../../../data/plc-models';

export async function generateSiemensProgram(logic: string, model: PLCModel) {
  const requirements = parseLogic(logic);
  const content = generateTIAPortalContent(requirements, model);
  const filename = `${requirements.projectName || 'PLC_Program'}_${model.model}${model.fileExtension}`;

  return { content, filename };
}

function parseLogic(logic: string): any {
  // Extract requirements from logic description
  const lightMatch = logic.match(/(\d+)\s+(?:sequential\s+)?lights?/i);
  const timeMatch = logic.match(/(\d+)\s+seconds?/i);

  return {
    projectName: extractProjectName(logic),
    numLights: lightMatch ? parseInt(lightMatch[1]) : 3,
    delaySeconds: timeMatch ? parseInt(timeMatch[1]) : 3,
    rawLogic: logic,
  };
}

function extractProjectName(logic: string): string {
  const nameMatch = logic.match(/(?:project|program|name):\s*([^\n.]+)/i);
  return nameMatch
    ? nameMatch[1].trim().replace(/[^a-zA-Z0-9_]/g, '_')
    : 'Sequential_Program';
}

function generateTIAPortalContent(requirements: any, model: PLCModel): string {
  // Generate basic SCL (Structured Control Language) program for Siemens
  const { numLights, delaySeconds, projectName } = requirements;

  return `(* Siemens ${model.model} Program *)
(* Generated by PLCAutoPilot *)
(* Project: ${projectName} *)
(* Description: ${requirements.rawLogic} *)

FUNCTION_BLOCK "Main"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
VAR_INPUT
  START_BTN : Bool;    // %I0.0
  STOP_BTN : Bool;     // %I0.1
END_VAR
VAR_OUTPUT
  ${Array.from({ length: numLights }, (_, i) => `LIGHT_${i + 1} : Bool;    // %Q0.${i}`).join('\n  ')}
END_VAR
VAR
  SEQUENCE_RUN : Bool;
  ${Array.from({ length: numLights - 1 }, (_, i) => `TIMER_${i + 1} : TON;`).join('\n  ')}
END_VAR
BEGIN
  // Start/Stop Control with Seal-in
  #SEQUENCE_RUN := (#START_BTN OR #SEQUENCE_RUN) AND NOT #STOP_BTN;

  // Light 1 - Immediate
  #LIGHT_1 := #SEQUENCE_RUN;

${generateSiemensTimerLogic(numLights, delaySeconds)}
END_FUNCTION_BLOCK

(* End of Program *)
`;
}

function generateSiemensTimerLogic(numLights: number, delaySeconds: number): string {
  let logic = '';

  for (let i = 1; i < numLights; i++) {
    const timerIdx = i - 1;
    const lightIdx = i;
    const inputCond = timerIdx === 0 ? '#SEQUENCE_RUN' : `#TIMER_${timerIdx}.Q`;

    logic += `
  // Timer ${timerIdx + 1} + Light ${lightIdx + 1}
  #TIMER_${timerIdx + 1}(IN := ${inputCond},
                         PT := T#${delaySeconds}S);
  #LIGHT_${lightIdx + 1} := #TIMER_${timerIdx + 1}.Q;
`;
  }

  return logic;
}
